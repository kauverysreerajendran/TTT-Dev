{% extends "base.html" %} 
{% load static %} 
{% load stock_filters %} 
{% block content %}

<style>
/* ========== Tablet override â€” paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */


@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }

.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(5)  { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 105px !important; max-width: 105px !important; }
  #order-listing th:nth-child(8)  { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(11) { min-width: 110px !important; max-width: 110px !important; }
  #order-listing th:nth-child(12) { min-width: 100px !important; max-width: 105px !important; }
  #order-listing th:nth-child(13) { min-width: 125px !important; max-width: 120px !important; }
  #order-listing th:nth-child(14) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(15) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(16) { min-width: 120px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }

  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
  border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 85px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 90px;
  max-width: 95px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 110px;
  max-width: 110px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 80px;
  max-width: 80px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 90px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 140px;
  max-width: 150px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(20) {
  min-width: 100px;
  max-width: 110px;
} /* Remarks for IS Pick Table */

@media (min-width: 600px) and (max-width: 900px) {
  #order-listing {
    table-layout: auto !important; /* Let columns auto-fit content */
    width: 100% !important;
    min-width: unset !important;
    max-width: 100vw !important;
  }
  /* Adjust width for all headings (th) and cells (td) */
  #order-listing th,
  #order-listing td {
    min-width: 90px !important;
    max-width: 90px !important;
    width: 180px !important;
  }
  #order-listing th {
    position: relative;
    padding-right: 48px !important; /* More space for filter icon */
    white-space: normal !important;
    overflow: visible !important;
    text-overflow: ellipsis;
  }
  #order-listing th .fa-filter {
    position: absolute;
    right: 18px !important;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
    background: transparent;
    pointer-events: auto;
  }
}
/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}


/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 94px 175px 150px !important;
  gap: 0px !important;
  max-height: 300px;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding-right: 10px;
  margin-top: 10px;
  border: 1px solid #ddd;
}

#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* For the 4-column layout (with validation status) */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 50px 1fr 100px 140px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
 
/* Styling individual grid cells, only inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #f7f7f7;
  padding: 8px 12px;
  font-size: 12px;
  border: 1px solid #ddd;
  margin: 0; /* reset any margin from <p> or others */
}
 
/* S.no column specific styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 600;
  padding: 8px 4px; /* Reduced horizontal padding for S.no */
}
 
/* For mobile responsiveness */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 80px 100px !important;
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 2px; /* Further reduced padding on mobile */
    font-size: 11px;
  }
}
 
/* For very small screens */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 30px 1fr 70px 90px !important;
  }
}
</style>
 

<div class="content-wrapper">
  <!-- <h5 class="text-left mt-0 mb-3">Recovery Onboard Pick Table</h5> -->
  
    <div class="col-12 grid-margin stretch-card">
      <div class="card">
                <div class="card-body">
              <h5 class="text-left mt-0 mb-4" style="font-weight:700;">Recovery Onboard Pick Table</h5>

            <!-- Table Section -->
            <div class="table-responsive" style="overflow: scroll !important">
<table id="order-listing" class="table">
               <thead>
                  <tr>
                    <th>
                      S.No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Last <br> Updated
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating <br> Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polishing <br>  Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating <br> Color
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Category
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polish Finish
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Version
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Tray Cate- <br>Capacity
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Source
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      No of <br> Trays
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Input <br> Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Process Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Action
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Current Stage
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Remarks
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                  </tr>
                </thead>
                <tbody>
  {% for data in master_data %}
    <tr
      {% if data.hold_lot %}
        class="row-inactive"
      {% endif %}
    >                 
<!-- S.No Column - Only show toggle for Admin users -->

<!-- Updated S.No Column - Replace the existing S.No td section with this -->
<td>
  <span style="display:flex; align-items:center; gap:3px;">
    {% if is_admin %}
      <!-- Admin users: Show toggle switch -->
      <label class="hold-toggle-switch" style="margin-bottom:0;">
        {% if not data.hold_lot %}
          <input type="checkbox" class="hold-toggle-btn" checked />
          <span class="hold-slider"></span>
        {% else %}
          <input type="checkbox" class="hold-toggle-btn" />
          <span class="hold-slider"></span>
        {% endif %}
      </label>
      
      <!-- Hold remark icon -->
      <span class="hold-remark-icon" 
            style="display:{% if data.hold_lot or data.release_lot %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
            title="{% if data.holding_reason %}Holding Reason: {{ data.holding_reason }}{% endif %}{% if data.holding_reason and data.release_reason %}&#10;{% endif %}{% if data.release_reason %}Release Reason: {{ data.release_reason }}{% endif %}">
        {% if data.hold_lot or data.release_lot %}
          <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
        {% endif %}
      </span>
    {% else %}
      <!-- Normal users: Show only view icon if there's a holding/release reason -->
      {% if data.hold_lot or data.release_lot or data.holding_reason or data.release_reason %}
        <span class="hold-remark-icon" 
              style="display:inline-block; cursor:pointer;" 
              title="{% if data.holding_reason %}Holding Reason: {{ data.holding_reason }}{% endif %}{% if data.holding_reason and data.release_reason %}&#10;{% endif %}{% if data.release_reason %}Release Reason: {{ data.release_reason }}{% endif %}">
          <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:12px; height:12px;" />
        </span>
      {% endif %}
    {% endif %}
    
    <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>
  </span>
</td>

    <!-- Last Updated Column -->
     <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.date_time|date:"d-M-y" }}<br>
      <span style="display:inline-block; margin-top:4px;">{{ data.date_time|date:"h:i A"  }}</span>
    </td>

    <!-- Plating Stk No Column -->
<td {% if data.hold_lot %}class="row-inactive-blur"{% endif %} style="white-space:normal;word-break:break-all;">
  <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
    {{ data.plating_stk_no|highlight_plating_color|safe_html }}

    <div class="model-image-tooltip"
         style="position: absolute; left: 238%; top: 0%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 10010; display: flex; align-items: center; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s;">          
          <!-- Platign Stk No - Hover - Info & close btn -->
        <button class="close-btn" style="position:absolute; top:18px; right:8px;">Close</button>
        <button class="info-btn" style="position:absolute; top:18px; left:8px;">Info</button>
         <button class="img-scroll-left" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8592;</button>
      <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
        {% for img_url in data.model_images %}
          <img src="{{ img_url }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
        {% endfor %}
      </div>
      <button class="img-scroll-right" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8594;</button>
    </div>
  </span>
</td>

    <!-- Polishing Stk No Column -->
<td {% if data.hold_lot %}class="row-inactive-blur"{% endif %}>
                      {{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}
                    </td>


    <!-- Plating Color Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.plating_color|default:"N/A" }}
    </td>

    <!-- Category Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.category|default:"N/A" }}
    </td>

    <!-- Polish Finish Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.polish_finish|default:"N/A" }}
    </td>

    <!-- Version Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.version__version_internal|default:"N/A" }}
    </td>

    <!-- Tray Type and Capacity Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.tray_type|default:"N/A" }}-{{ data.tray_capacity|default:"0" }}
    </td>

    <!-- Source Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.location__location_name|default:"N/A" }}
    </td>

    <!-- No of Trays Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.no_of_trays|default:"0" }}
    </td>

    <!-- Input Qty Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      {{ data.total_batch_quantity|default:"0" }}
    </td>

    <!-- Process Status Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      <!-- Dynamic Process Status based on conditions -->
      {% if data.Moved_to_D_Picker %}
        <div
          title="Tray Scan"
          class="d-flex align-items-center justify-content-center rounded-circle ms-1"
          style="
            width: 28px;
            height: 28px;
            background-color: #0c8249;
            color: white;
            font-weight: bold;
          "
        >
          T
        </div>
      {% elif data.Draft_Saved %}
        <div
        title="Tray Scan"
        class="d-flex align-items-center justify-content-center rounded-circle ms-1"
        style="
          width: 28px;
          height: 28px;
         background: linear-gradient(
            to right,
            green 50%,
            #bfbfbf 50%
          );
          color: white;
          font-weight: bold;
          line-height: 20px;
          text-align: center;
          padding-top: 1px;
          padding-right: 1px;"
      >
          T
        </div>
      
      {% else %}
        <div
          title="Tray Scan"
          class="d-flex align-items-center justify-content-center rounded-circle ms-1"
          style="
            width: 28px;
            height: 28px;
            background-color: #d3d2d2;
            color: white;
            font-weight: bold;
          "
        >
          T
        </div>
      {% endif %}
    </td>

<!-- Action Column - Only show Edit and Delete for Admin users -->
    <td {% if data.hold_lot %}class="row-inactive-blur"{% endif %}>
      {% if is_admin %}
        <!-- Admin users see Edit and Delete buttons -->
        {% if not data.Moved_to_D_Picker %}
          <a href="#" class="edit-qty-btn" data-batch-id="{{ data.batch_id }}">
            <img src="{% static 'assets/icons/edit1.png' %}" alt="Edit" style="width: 24px; margin-right: 8px; height: auto"/>
          </a>
        {% else %}
          <span style="opacity:0.5; pointer-events:none; display:inline-block;">
            <img src="{% static 'assets/icons/edit1.png' %}" alt="Edit Disabled" style="width: 24px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5);"/>
          </span>
        {% endif %}
        
        {% if not data.Moved_to_D_Picker %}
          <a href="#" title="Delete">
            <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 24px; margin-right: 8px; height: auto; cursor:pointer;" />
          </a>
        {% else %}
          <span title="Cannot delete after moved" style="opacity:0.5; pointer-events:none; display:inline-block;">
            <img src="{% static 'assets/icons/bin.png' %}" alt="Delete Disabled" style="width: 24px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5); cursor:not-allowed;" />
          </span>
        {% endif %}
      {% endif %}
      <!-- Normal users: Edit and Delete icons are completely hidden -->
      
      <!-- Tray Scan button is visible for all users -->
<!-- Update the Tray Scan button section in your template: -->
{% if not data.Moved_to_D_Picker %}
  <a href="#" class="text-primary tray-scan-btn" style="text-decoration: underline"
     data-batch-id="{{ data.batch_id }}" 
     data-model-no="{{ data.model_stock_no__model_no }}"
     data-no-of-trays="{{ data.no_of_trays }}" 
     data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
     data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}" 
     data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
     data-top-tray-qty-verified="{{ data.top_tray_qty_verified }}" 
     data-draft-saved="{{data.Draft_Saved}}"
     data-total-batch-quantity="{{ data.total_batch_quantity|default:'0' }}"
     data-model-image="{{ data.model_images.0|default:'' }}"
     data-needs-top-tray-scan="{{ data.needs_top_tray_scan|yesno:'true,false' }}"
     data-tray-scan-status="{{ data.tray_scan_status|yesno:'true,false' }}">
    
    <!-- âœ… ENHANCED: Show "Set Top Tray" button when needed -->
    {% if data.needs_top_tray_scan %}
      Set Top Tray
    {% else %}
      Tray Scan
    {% endif %}
  </a>
{% endif %}
    </td>

<!-- Lot Status Column - Updated with Hold Logic -->
<td
  {% if data.hold_lot %}
    class="row-inactive-blur"
  {% endif %}
>
  <!-- Dynamic Lot Status based on conditions with Hold Logic -->
  {% if data.hold_lot %}
    <!-- When hold_lot is True, show "On Hold" status -->
    <div
      class="d-inline-block px-3 fw-semibold text-center rounded-pill"
      style="
        border: 1px solid #dc3545;
        background-color: #f8d7da;
        color: #721c24;
        font-size: 13px;
        white-space: nowrap;
        padding: 5px;
        
      "
    >
      On Hold
    </div>
  {% elif data.Moved_to_D_Picker %}
    <!-- Yet To Release Status -->
    <div
      class="d-inline-block px-3 fw-semibold text-center rounded-pill"
      style="
        border: 1px solid #0d5d17;
        background-color: #c5f9c2;
        color: #2f801b;
        font-size: 13px;
        white-space: nowrap;
        padding: 5px;
        
      "
    >
      Yet To Release
    </div>
  {% elif data.Draft_Saved %}
    <!-- Draft Status -->
    <div
      class="d-inline-block px-3 fw-semibold text-center rounded-pill"
      style="
        border: 1px solid #4997ac;
        background-color: #d1f2f3;
        color: #03425d;
        font-size: 13px;
        white-space: nowrap;
        padding: 5px;
        
      "
    >
      Draft
    </div>
  
  {% else %}
    <!-- Yet to Start Status -->
    <div
      class="d-inline-block px-3 fw-semibold text-center rounded-pill"
      style="
        border: 1px solid #a6a6a6;
        background-color: #dcdada;
        color: #505050;
        font-size: 13px;
        white-space: nowrap;
        padding: 5px;
      "
    >
      Yet to Start
    </div>
  {% endif %}
</td>

    <!-- Current Stage Column -->
    <td
      {% if data.hold_lot %}
        class="row-inactive-blur"
      {% endif %}
    >
      <div
        class="d-inline-block px-3 fw-semibold text-center rounded-pill"
        style="
          border: 1px solid #9adeed;
          background-color: #d1edf3;
          color: #033b5d;
          font-size: 12px;
          padding: 5px;
        "
      >
        {% if data.last_procees_module == "DayPlanning" %}
          {{ data.last_procees_module }}
        {% else %}
          Recovery Onboard
        {% endif %}
      </div>
    </td>

<!-- Updated Remarks Column - Replace the existing Remarks td section with this -->
<td
  {% if data.hold_lot %}
    class="row-inactive-blur"
  {% endif %}
>
    <!-- Admin users: Show audio and remark icons if not moved -->
    {% if not data.Moved_to_D_Picker %}
      <!-- VoiceRec with tooltip (audio remark) -->
      <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
        <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
        <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
          
          <!-- Audio recording UI placeholder -->
          <div style="display: flex; align-items: center; gap: 10px;">
            <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
              <i class="fa fa-microphone"></i>
            </button>
            <span style="font-size: 14px; color: #333;">Hold to record audio</span>
              <div style="text-align: right; margin-top: 10px;">
            <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
              <i class="fa fa-send"></i>
            </button>
          </div>
          </div>
        
        </div>
      </a>

      <a
      href="#"
      title="Add Remark"
      class="remark-tooltip-trigger"
      style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; position: relative; cursor: pointer;"
    >
      <img
        src="{% static 'assets/icons/chat_icon.png' %}"
        alt="Chat"
  style="width: 20px; height: 20px; {% if data.dp_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% else %}opacity: 0.7;{% endif %}">


      <div
        class="remark-tooltip"
        style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 300px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
      >
        <div
          style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid #fff;"
        ></div>
        <textarea
          placeholder="Type your remark..."
          style="width: 85%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
          {% if data.dp_pick_remarks %}readonly{% endif %}
        >{{ data.dp_pick_remarks|default_if_none:"" }}</textarea>
        <div style="text-align: right; margin-top: -35px">
          {% if not data.dp_pick_remarks %}
          <button
            type="button"
            style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
          >
            <i class="fa fa-send"></i>
          </button>
          {% else %}
          <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
            <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
            Remark already saved and cannot be edited.
          </div>
          {% endif %}
        </div>
      </div>
    </a>
    {% else %}
      <!-- Audio Remark Icon (disabled) -->
      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; opacity: 0.5; pointer-events: none;">
        <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
      </span>
      <!-- Chat Remark Icon (disabled) -->
      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; opacity: 0.5; pointer-events: none;">
        <img src="{% static 'assets/icons/chat_icon.png' %}" alt="Chat Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
      </span>

    {% endif %}
</td>

  </tr>
  {% empty %}
  <tr>
    <td colspan="15" class="text-center">No data available</td>
  </tr>
  {% endfor %}
</tbody>
              </table>


            <div
            id="trayScanModal"
            class="tray-scan-modal"
            id="trayScanModal"
          >
            <div class="tray-scan-modal-content">
              <span id="closeTrayScanModal" class="tray-scan-close"
                >&times;</span
              >

              <!-- New top header container: title + user profile aligned left -->
<!-- Header Section -->
    <div class="modal-top-header" style="display: flex; align-items: center; gap: 24px; margin-top: 5px !important; margin-bottom: 10px; padding-bottom: 0px; border-bottom: 1px solid #eee;">
      <img src="/static/assets/images/imagePlaceholder.png" alt="User Profile" style="border-radius: 50%; width: 44px; height: 44px; object-fit: cover;" />
      
      <div style="font-weight: 600; color: #222; font-size: 17px;">
        Model No:
        <span id="modalModelNo" style="color: #028084; font-weight: 700;">(Fetch Dynamically)</span>
      </div>

      <div style="font-weight: 600; color: #222; font-size: 17px;">
        Input Qty:
        <span id="modalTrayQty" style="color: #028084; font-weight: 700;">(Fetch Dynamically)</span>
      </div>
    </div>

              
                                <!-- Redo icon for clearing "tray ID" -->
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;margin-right: 10px;">
      <h5 style="margin: 0; font-weight: 600; color: #595959;">R- Onboard - Tray Scan</h5>
      <div style="display: flex; align-items: center; gap: 16px;">
<div id="trayScanSummary" style="font-weight: 600; font-size: 15px; color: #028084; margin-bottom: 0; white-space: nowrap;">
  Qty to Scan: 0/0
</div>
        <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="trayIDRedoBtn" title="Clear Tray IDs" style="width: 24px; height: 24px; cursor: pointer;" />
      </div>
    </div>

              <!-- trayScanDetails will be a scrollable 3-column grid with headers and unlimited rows -->
              <div id="trayScanDetails" class="table-grid">
                <!-- Headers -->
                <div>S.no</div>
                <div>Tray ID</div>
                <div>Tray Quantity</div>
<div class="tray-validation-status-header">Tray Validation Status
<span style="margin-left: 10px;">
    <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
    <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
  </span>

</div>

                <!-- Example rows (replace with dynamic content) -->
              </div>
              <!-- Ã¢Å“â€¦ NEW BUTTONS SECTION -->
              
              <div class="tray-scan-modal-buttons"
                style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
                <button id="trayScanDraftBtn" type="button" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
                <button id="trayScanSubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
                <button id="trayScanCancelBtn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">Cancel</button>
              </div>
              <div id="trayQtyErrorFooter" style="color: red; font-size: 14px; text-align: center; min-height: 5px; margin-top: 4px;"></div>
              
            </div>
            <div
              id="trayScanModal_DayPlanning"
              class="tray-scan-modal-DayPlanning"
            >
              <div class="tray-scan-modal-DayPlanning-content">
                <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly"
                  >&times;</span
                >
                <!-- New top header container: title + user profile aligned left -->
                <div
                  class="modal-top-header"
                  style="
                    display: flex;
                    align-items: center;
                    gap: 20px;
                    padding-bottom: 10px;
                  "
                >
                  <div
                    class="user-profile"
                    style="display: flex; align-items: center; gap: 8px"
                  >
                    <img
                      src="/static/assets/images/imagePlaceholder.png"
                      alt="User Profile"
                      style="
                        border-radius: 50%;
                        width: 50px;
                        height: 50px;
                        object-fit: cover;
                      "
                    />
                    <span>Model No:</span>
                    <h6 id="modalModelNo_DayPlanning">(Fetch Dynamically)</h6>
                  </div>
                </div>
                <!-- Redo icon for clearing "tray ID" -->
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                  <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                    Recovery Onboard - Tray Scan (Read Only)
                  </h5>
                  <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 13px; font-weight: 500; cursor: pointer;">
                      Tray Validate
                  </button>

                  <!-- Hidden input field - completely invisible to users -->
                  <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />

                  <img
                      src="{% static 'assets/icons/redo2.png' %}"
                      alt="Redo"
                      id="trayScanRedoBtn"
                      style="width: 24px; height: 24px; cursor: pointer; margin-left: 8px;"
                      title="Clear Tray IDs"
                  />
                </div>
                
                <!-- Error message container - initially hidden -->
                <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 14px; text-align: center;">
                  <span id="trayErrorText"></span>
                </div>
                
                <!-- trayScanDetails_DayPlanning will be a scrollable 3-column grid with headers and unlimited rows -->
                <div id="trayScanDetails_DayPlanning" class="table-grid">
                  <!-- Headers -->
                  <div>S.no</div>
                  <div>Tray ID</div>
                  <div>Tray Quantity</div>
                  <div class="tray-validation-status-header">Tray Validation Status
                    <span style="margin-left: 10px;">
            <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
            <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
            </span>
                  </div>
                  <!-- Example rows (replace with dynamic content) -->
                </div>
                <!-- No buttons for read-only modal -->
              </div>
            </div>
                        <!-- End of Tray Scan Modal Window -->

            </div> 

                    <div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
            <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
              <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
              <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
              <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
              <div style="text-align:right; margin-top:10px;">
                <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
              </div>
              <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
            </div>
          </div>
        </div>






            <!-- Pagination Section -->

 <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>â€¦</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>â€¦</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!-- Script for Sorting the Table for each rows -->
  {% block script %}


<script nonce="{{ csp_nonce }}">
// Complete Redo Script with Row Removal Functionality

document.addEventListener("DOMContentLoaded", function () {
  const trayIDRedoBtn = document.getElementById("trayIDRedoBtn");
  if (trayIDRedoBtn) {
    trayIDRedoBtn.addEventListener("click", function () {
      const detailsDiv = document.getElementById("trayScanDetails");
      if (!detailsDiv) return;

      // âœ… ENHANCED: Always restore from backup original data (never modified)
      const originalDataToRestore = window.backupOriginalTrayScanData || window.originalTrayScanData;
      
      if (originalDataToRestore && originalDataToRestore.length > 0) {
        // âœ… CRITICAL: Restore window.originalTrayScanData from backup
        window.originalTrayScanData = JSON.parse(JSON.stringify(originalDataToRestore));
        
        console.log('ðŸ”„ Redo: Restoring from backup data with', originalDataToRestore.length, 'rows');
        // Build new HTML structure with original row count and values
        let html = `
            <div style="min-height:32px;">S.no</div>
            <div style="min-height:32px;">Tray ID</div>
            <div style="min-height:32px;">Tray Quantity</div>
        `;
        for (let i = 0; i < originalDataToRestore.length; i++) {
          html += `
            <div style="min-height:32px;">${i === 0 ? '1 (Top Tray)' : (i + 1)}</div>
            <div style="min-height:32px;">
                <input type="text" class="form-control tray-id-input" value="${originalDataToRestore[i].trayId || ''}" data-draft-id="${originalDataToRestore[i].draftId || ''}" data-position="${i}" style="width: 100%;" />
            </div>
            <div style="min-height:32px;">
                ${
                  i === 0
                    ? `<div style="display: flex; align-items: center; justify-content: space-between;">
                        <input type="number" class="form-control tray-qty-input" value="${originalDataToRestore[i].trayQty || ''}" style="width: 60px;" readonly />
                        <div style="display: flex; align-items: center; gap: 27px;">
                            <input type="checkbox" class="tray-verify-checkbox" style="width: 18px; height: 18px; cursor: pointer;" ${originalDataToRestore[i].topTrayQtyVerified ? 'checked disabled' : ''} />
                            <img src="{% static 'assets/icons/edit2.png' %}" alt="Edit" class="tray-edit-btn" style="width: 18px; height: 18px; cursor: pointer;${originalDataToRestore[i].topTrayQtyVerified ? 'opacity:0.5;pointer-events:none;' : ''}" />
                        </div>
                      </div>`
                    : `<input type="number" class="form-control" value="${originalDataToRestore[i].trayQty || ''}" style="width: 100%;" readonly />`
                }
            </div>
          `;
        }
        detailsDiv.innerHTML = html;

        // âœ… TRAY ID INPUT EVENT LISTENERS
        const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
        trayIdInputs.forEach((input, idx, allInputs) => {
            input.addEventListener('input', function () {
                let prevError = input.parentNode.querySelector('.tray-id-error');
                if (prevError) prevError.remove();
                input.style.borderColor = '';
                input.style.backgroundColor = '';
                updateUIElements();
            });
        
            input.addEventListener('blur', async function () {
                let prevError = input.parentNode.querySelector('.tray-id-error');
                if (prevError) prevError.remove();
        
                const trayId = input.value.trim();
                if (!trayId) {
                    updateUIElements();
                    return;
                }
        
                // Check for duplicates in modal
                let duplicateInModal = false;
                allInputs.forEach((otherInput, otherIdx) => {
                    if (otherIdx !== idx && otherInput.value.trim() === trayId) {
                        duplicateInModal = true;
                    }
                });
                if (duplicateInModal) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'tray-id-error';
                    errorDiv.style.color = 'red';
                    errorDiv.style.fontSize = '12px';
                    errorDiv.textContent = 'Already scanned in a row!';
                    input.parentNode.appendChild(errorDiv);
                    input.focus();
                    input.select();
                    updateUIElements();
                    return;
                }
        
                // Backend validation
                try {
                    const currentBatchId = window.currentTrayScanBatchId || '';
                    const resp = await fetch(`/recovery_dp/rec_tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}&batch_id=${encodeURIComponent(currentBatchId)}`);
                    const result = await resp.json();
        
                    if (result.tray_not_in_system) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = '#d32f2f';
                        errorDiv.style.fontSize = '11px';
                        errorDiv.style.fontWeight = 'bold';
                        errorDiv.style.backgroundColor = '#ffebee';
                        errorDiv.style.padding = '4px 6px';
                        errorDiv.style.borderRadius = '4px';
                        errorDiv.style.marginTop = '4px';
                        errorDiv.innerHTML = `<div style="color: #d32f2f;">âŒ Invalid Barcode ID</div>`;
                        input.parentNode.appendChild(errorDiv);
                        input.style.borderColor = '#d32f2f';
                        input.style.backgroundColor = '#ffebee';
                        input.focus();
                        input.select();
                    } else if (result.already_scanned) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = '#d32f2f';
                        errorDiv.style.fontSize = '11px';
                        errorDiv.style.fontWeight = 'bold';
                        errorDiv.style.backgroundColor = '#ffebee';
                        errorDiv.style.padding = '4px 6px';
                        errorDiv.style.borderRadius = '4px';
                        errorDiv.style.marginTop = '4px';
                        errorDiv.innerHTML = `<div style="color: #d32f2f;">âŒ Already Scanned</div>`;
                        input.parentNode.appendChild(errorDiv);
                        input.style.borderColor = '#d32f2f';
                        input.style.backgroundColor = '#ffebee';
                        input.focus();
                        input.select();
                    } else if (result.tray_type_error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = 'red';
                        errorDiv.style.fontSize = '11px';
                        errorDiv.style.fontWeight = 'bold';
                        errorDiv.style.backgroundColor = '#ffebee';
                        errorDiv.style.padding = '4px 6px';
                        errorDiv.style.borderRadius = '4px';
                        errorDiv.style.marginTop = '4px';
                        errorDiv.innerHTML = `
                            <div style="color: #d32f2f;">âŒ Tray Type Mismatch</div>
                            <div style="font-size: 10px; margin-top: 2px;">
                                Batch Type: <strong>${result.batch_tray_type || 'Not Set'}</strong><br>
                                Scanned Type: <strong>${result.scanned_tray_type || 'Not Set'}</strong>
                            </div>
                        `;
                        input.parentNode.appendChild(errorDiv);
                        input.style.borderColor = '#ff5722';
                        input.style.backgroundColor = '#fff3e0';
                        input.focus();
                        input.select();
                    } else if (!result.available) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = 'red';
                        errorDiv.style.fontSize = '12px';
                        errorDiv.textContent = result.error || 'Tray not available!';
                        input.parentNode.appendChild(errorDiv);
                        input.style.borderColor = '#d32f2f';
                        input.style.backgroundColor = '#ffebee';
                        input.focus();
                        input.select();
                    } else if (result.delink_tray) {
                        input.style.borderColor = '#4caf50';
                        input.style.backgroundColor = '#f1f8e9';
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'tray-id-success';
                        infoDiv.style.color = '#2e7d32';
                        infoDiv.style.fontSize = '11px';
                        infoDiv.style.fontWeight = 'bold';
                        infoDiv.innerHTML = `âœ… Delinked - available for reuse`;
                        input.parentNode.appendChild(infoDiv);
                        setTimeout(() => {
                            if (infoDiv.parentNode) {
                                infoDiv.parentNode.removeChild(infoDiv);
                            }
                        }, 2000);
                    } else if (result.available) {
                        input.style.borderColor = '#4caf50';
                        input.style.backgroundColor = '#f1f8e9';
                        if (result.status === 'pre_configured') {
                            const successDiv = document.createElement('div');
                            successDiv.className = 'tray-id-success';
                            successDiv.style.color = '#2e7d32';
                            successDiv.style.fontSize = '11px';
                            successDiv.style.fontWeight = 'bold';
                            successDiv.innerHTML = `âœ… Available (${result.tray_type || 'Type not set'})`;
                            input.parentNode.appendChild(successDiv);
                            setTimeout(() => {
                                if (successDiv.parentNode) {
                                    successDiv.parentNode.removeChild(successDiv);
                                }
                            }, 2000);
                        }
                    }
                } catch (e) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'tray-id-error';
                    errorDiv.style.color = '#ff5722';
                    errorDiv.style.fontSize = '12px';
                    errorDiv.textContent = 'Validation error - please try again';
                    input.parentNode.appendChild(errorDiv);
                }
            });
        
            input.addEventListener('keydown', async function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                    setTimeout(() => {
                        if (!input.parentNode.querySelector('.tray-id-error')) {
                            const nextInput = allInputs[idx + 1];
                            if (nextInput) {
                                nextInput.focus();
                                nextInput.select();
                            }
                        } else {
                            input.focus();
                            input.select();
                        }
                    }, 50);
                }
            });
        });
        
        // âœ… TOP TRAY QUANTITY EDIT FUNCTIONALITY WITH ROW REMOVAL
        const editBtn = detailsDiv.querySelector('.tray-edit-btn');
        const qtyInput = detailsDiv.querySelector('.tray-qty-input');
        const trayCapacity = window.currentModalConfig ? window.currentModalConfig.trayCapacity : 12;
        const errorFooter = document.getElementById('trayQtyErrorFooter');
        
        if (editBtn && qtyInput) {
            // Remove previous listeners by cloning
            const newEditBtn = editBtn.cloneNode(true);
            editBtn.parentNode.replaceChild(newEditBtn, editBtn);
        
            const newQtyInput = qtyInput.cloneNode(true);
            qtyInput.parentNode.replaceChild(newQtyInput, qtyInput);
        
            // âœ… ENHANCED: Store original quantity when edit starts (for decrease-only validation)
            let originalQuantity = parseInt(newQtyInput.value, 10) || 0;
        
            newEditBtn.addEventListener('click', function (e) {
                e.preventDefault();
                // âœ… Capture original quantity at edit time
                originalQuantity = parseInt(newQtyInput.value, 10) || 0;
                console.log('âœï¸ Edit started - Original quantity:', originalQuantity);
                
                newQtyInput.removeAttribute('readonly');
                newQtyInput.focus();
                newQtyInput.select();
            });
        
            newQtyInput.addEventListener('input', function () {
                if (errorFooter) {
                    errorFooter.textContent = 'Qty modified';
                    errorFooter.style.color = '#007bff';
                }
                let val = parseInt(newQtyInput.value, 10) || 0;
                
                // âœ… ENHANCED: Only allow decrease from original quantity
                if (val > originalQuantity) {
                    newQtyInput.value = originalQuantity;
                    if (errorFooter) {
                        errorFooter.textContent = `Quantity can only be decreased. Maximum allowed: ${originalQuantity}`;
                        errorFooter.style.color = '#d32f2f';
                    }
                    val = originalQuantity;
                } else if (val > trayCapacity) {
                    newQtyInput.value = trayCapacity;
                    if (errorFooter) errorFooter.textContent = `Tray Qty cannot exceed Tray Capacity (${trayCapacity})`;
                } else if (val < 0) {
                    newQtyInput.value = 0;
                    val = 0;
                }
               
                updateUIElements();
            });
        
            newQtyInput.addEventListener('keydown', function (ev) {
                if (ev.key === 'Enter') {
                    newQtyInput.setAttribute('readonly', 'readonly');
                    newQtyInput.blur();
                }
            });
        
            newQtyInput.addEventListener('blur', function () {
                newQtyInput.setAttribute('readonly', 'readonly');
                if (errorFooter) errorFooter.textContent = '';
            });
        }

        // âœ… CHECKBOX VALIDATION LISTENER
        const verifyCheckbox = detailsDiv.querySelector('input[type="checkbox"]');
        if (verifyCheckbox) {
            verifyCheckbox.addEventListener('change', function() {
                if (verifyCheckbox.checked) {
                    if (!validateAllTrayIds()) {
                        verifyCheckbox.checked = false;
                        if (errorFooter) {
                            errorFooter.textContent = '';
                        }
                        Swal.fire({
                            icon: 'warning',
                            title: 'Incomplete Data',
                            text: 'Please fill all Tray IDs before verifying.',
                            confirmButtonColor: '#007bff'
                        });
                        return;
                    }
                    if (errorFooter) {
                        errorFooter.textContent = 'Top tray qty verified';
                        errorFooter.style.color = 'green';
                    }
                } else {
                    if (errorFooter) {
                        errorFooter.textContent = '';
                    }
                }
                updateUIElements();
            });
        }
                
        updateUIElements();

        // Restore modal total quantity display
        const modalTrayQty = document.getElementById("modalTrayQty");
        if (modalTrayQty) {
          let total = 0;
          for (let i = 0; i < originalDataToRestore.length; i++) {
            total += parseInt(originalDataToRestore[i].trayQty, 10) || 0;
          }
          modalTrayQty.textContent = total;
          console.log('ðŸ“ˆ Modal quantity restored to:', total);
        }

        // Re-attach event listeners
        setTimeout(() => {
          if (typeof attachEnhancedEventListeners === "function") attachEnhancedEventListeners();
          if (typeof updateTrayScanSummary === "function") updateTrayScanSummary();
          
          // âœ… ENHANCED: Auto-focus first tray ID input after redo
          autoFocusFirstTrayInput();
        }, 50);
      }

      // Remove all tray-id-error messages
      detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());

      // Remove trayQtyErrorFooter message (removes "Top tray qty verified" and others)
      const trayQtyErrorFooter = document.getElementById('trayQtyErrorFooter');
      if (trayQtyErrorFooter) {
        trayQtyErrorFooter.textContent = '';
        trayQtyErrorFooter.style.color = '';
      }
      // Reset checkbox to unchecked and enabled (only if not permanently verified)
      const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
      if (verifyCheckbox && !verifyCheckbox.disabled) {
        verifyCheckbox.checked = false;
      }

      // Update validation state
      updateUIElements();

      // Update Tray Scan Summary
      updateTrayScanSummary();
      
      // âœ… ENHANCED: Auto-focus first tray ID input after cleanup
      setTimeout(() => {
        autoFocusFirstTrayInput();
      }, 100);
    });
  }
});



// âœ… ENHANCED: Re-attach all event listeners after rebuild
function reattachAllEventListenersAfterRebuild() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return;
  
  console.log('ðŸ”— Re-attaching all event listeners after rebuild');

  // âœ… 1. TRAY ID INPUT EVENT LISTENERS
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
  trayIdInputs.forEach((input, idx, allInputs) => {
      input.addEventListener('input', function () {
          let prevError = input.parentNode.querySelector('.tray-id-error');
          if (prevError) prevError.remove();
          input.style.borderColor = '';
          input.style.backgroundColor = '';
          updateUIElements();
      });
  
      input.addEventListener('blur', async function () {
          let prevError = input.parentNode.querySelector('.tray-id-error');
          if (prevError) prevError.remove();
  
          const trayId = input.value.trim();
          if (!trayId) {
              updateUIElements();
              return;
          }
  
          // Check for duplicates in modal
          let duplicateInModal = false;
          allInputs.forEach((otherInput, otherIdx) => {
              if (otherIdx !== idx && otherInput.value.trim() === trayId) {
                  duplicateInModal = true;
              }
          });
          if (duplicateInModal) {
              const errorDiv = document.createElement('div');
              errorDiv.className = 'tray-id-error';
              errorDiv.style.color = 'red';
              errorDiv.style.fontSize = '12px';
              errorDiv.textContent = 'Already scanned in a row!';
              input.parentNode.appendChild(errorDiv);
              input.focus();
              input.select();
              updateUIElements();
              return;
          }
  
          // Backend validation
          try {
              const currentBatchId = window.currentTrayScanBatchId || '';
              const resp = await fetch(`/recovery_dp/rec_tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}&batch_id=${encodeURIComponent(currentBatchId)}`);
              const result = await resp.json();
  
              if (result.tray_not_in_system) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = '#d32f2f';
                  errorDiv.style.fontSize = '11px';
                  errorDiv.style.fontWeight = 'bold';
                  errorDiv.style.backgroundColor = '#ffebee';
                  errorDiv.style.padding = '4px 6px';
                  errorDiv.style.borderRadius = '4px';
                  errorDiv.style.marginTop = '4px';
                  errorDiv.innerHTML = `<div style="color: #d32f2f;">âŒ Invalid Barcode ID</div>`;
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#d32f2f';
                  input.style.backgroundColor = '#ffebee';
                  input.focus();
                  input.select();
              } else if (result.already_scanned) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = '#d32f2f';
                  errorDiv.style.fontSize = '11px';
                  errorDiv.style.fontWeight = 'bold';
                  errorDiv.style.backgroundColor = '#ffebee';
                  errorDiv.style.padding = '4px 6px';
                  errorDiv.style.borderRadius = '4px';
                  errorDiv.style.marginTop = '4px';
                  errorDiv.innerHTML = `<div style="color: #d32f2f;">âŒ Already Scanned</div>`;
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#d32f2f';
                  input.style.backgroundColor = '#ffebee';
                  input.focus();
                  input.select();
              } else if (result.tray_type_error) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = 'red';
                  errorDiv.style.fontSize = '11px';
                  errorDiv.style.fontWeight = 'bold';
                  errorDiv.style.backgroundColor = '#ffebee';
                  errorDiv.style.padding = '4px 6px';
                  errorDiv.style.borderRadius = '4px';
                  errorDiv.style.marginTop = '4px';
                  errorDiv.innerHTML = `
                      <div style="color: #d32f2f;">âŒ Tray Type Mismatch</div>
                      <div style="font-size: 10px; margin-top: 2px;">
                          Batch Type: <strong>${result.batch_tray_type || 'Not Set'}</strong><br>
                          Scanned Type: <strong>${result.scanned_tray_type || 'Not Set'}</strong>
                      </div>
                  `;
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#ff5722';
                  input.style.backgroundColor = '#fff3e0';
                  input.focus();
                  input.select();
              } else if (!result.available) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = 'red';
                  errorDiv.style.fontSize = '12px';
                  errorDiv.textContent = result.error || 'Tray not available!';
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#d32f2f';
                  input.style.backgroundColor = '#ffebee';
                  input.focus();
                  input.select();
              } else if (result.delink_tray) {
                  input.style.borderColor = '#4caf50';
                  input.style.backgroundColor = '#f1f8e9';
                  const infoDiv = document.createElement('div');
                  infoDiv.className = 'tray-id-success';
                  infoDiv.style.color = '#2e7d32';
                  infoDiv.style.fontSize = '11px';
                  infoDiv.style.fontWeight = 'bold';
                  infoDiv.innerHTML = `âœ… Delinked - available for reuse`;
                  input.parentNode.appendChild(infoDiv);
                  setTimeout(() => {
                      if (infoDiv.parentNode) {
                          infoDiv.parentNode.removeChild(infoDiv);
                      }
                  }, 2000);
              } else if (result.available) {
                  input.style.borderColor = '#4caf50';
                  input.style.backgroundColor = '#f1f8e9';
                  if (result.status === 'pre_configured') {
                      const successDiv = document.createElement('div');
                      successDiv.className = 'tray-id-success';
                      successDiv.style.color = '#2e7d32';
                      successDiv.style.fontSize = '11px';
                      successDiv.style.fontWeight = 'bold';
                      successDiv.innerHTML = `âœ… Available (${result.tray_type || 'Type not set'})`;
                      input.parentNode.appendChild(successDiv);
                      setTimeout(() => {
                          if (successDiv.parentNode) {
                              successDiv.parentNode.removeChild(successDiv);
                          }
                      }, 2000);
                  }
              }
          } catch (e) {
              const errorDiv = document.createElement('div');
              errorDiv.className = 'tray-id-error';
              errorDiv.style.color = '#ff5722';
              errorDiv.style.fontSize = '12px';
              errorDiv.textContent = 'Validation error - please try again';
              input.parentNode.appendChild(errorDiv);
          }
      });
  
      input.addEventListener('keydown', async function (e) {
          if (e.key === 'Enter') {
              e.preventDefault();
              input.blur();
              setTimeout(() => {
                  if (!input.parentNode.querySelector('.tray-id-error')) {
                      const nextInput = allInputs[idx + 1];
                      if (nextInput) {
                          nextInput.focus();
                          nextInput.select();
                      }
                  } else {
                      input.focus();
                      input.select();
                  }
              }, 50);
          }
      });
  });

  // âœ… 2. TOP TRAY QUANTITY EDIT FUNCTIONALITY 
  const editBtn = detailsDiv.querySelector('.tray-edit-btn');
  const qtyInput = detailsDiv.querySelector('.tray-qty-input');
  const trayCapacity = window.currentModalConfig ? window.currentModalConfig.trayCapacity : 12;
  const errorFooter = document.getElementById('trayQtyErrorFooter');
  
  if (editBtn && qtyInput) {
      // âœ… ENHANCED: Store original quantity for decrease-only validation
      let originalQuantity = parseInt(qtyInput.value, 10) || 0;
      
      editBtn.addEventListener('click', function (e) {
          e.preventDefault();
          // âœ… Capture original quantity at edit time
          originalQuantity = parseInt(qtyInput.value, 10) || 0;
          console.log('âœï¸ Edit started after rebuild - Original quantity:', originalQuantity);
          
          qtyInput.removeAttribute('readonly');
          qtyInput.focus();
          qtyInput.select();
      });
  
      qtyInput.addEventListener('input', function () {
          if (errorFooter) {
              errorFooter.textContent = 'Qty modified';
              errorFooter.style.color = '#007bff';
          }          
          let val = parseInt(qtyInput.value, 10) || 0;
          
          // âœ… ENHANCED: Only allow decrease from original quantity
          if (val > originalQuantity) {
              qtyInput.value = originalQuantity;
              if (errorFooter) {
                  errorFooter.textContent = `Quantity can only be decreased. Maximum allowed: ${originalQuantity}`;
                  errorFooter.style.color = '#d32f2f';
              }
              val = originalQuantity;
          } else if (val > trayCapacity) {
              qtyInput.value = trayCapacity;
              if (errorFooter) errorFooter.textContent = `Tray Qty cannot exceed Tray Capacity (${trayCapacity})`;
          } else if (val < 0) {
              qtyInput.value = 0;
              val = 0;
          }
          
         
          updateUIElements();
      });
  
      qtyInput.addEventListener('keydown', function (ev) {
          if (ev.key === 'Enter') {
              qtyInput.setAttribute('readonly', 'readonly');
              qtyInput.blur();
          }
      });
  
      qtyInput.addEventListener('blur', function () {
          qtyInput.setAttribute('readonly', 'readonly');
          if (errorFooter) errorFooter.textContent = '';
      });
  }

  // âœ… 3. CHECKBOX VALIDATION LISTENER
const verifyCheckbox = detailsDiv.querySelector('input[type="checkbox"]');
if (verifyCheckbox) {
    verifyCheckbox.addEventListener('change', function() {
        if (verifyCheckbox.checked) {
            if (!validateAllTrayIds()) {
                verifyCheckbox.checked = false;
                if (errorFooter) {
                    errorFooter.textContent = '';
                }
                Swal.fire({
                    icon: 'warning',
                    title: 'Incomplete Data',
                    text: 'Please fill all Tray IDs before verifying.',
                    confirmButtonColor: '#007bff'
                });
                return;
            }
            if (errorFooter) {
                errorFooter.textContent = 'Top tray qty verified';
                errorFooter.style.color = 'green';
            }
        } else {
            if (errorFooter) {
                errorFooter.textContent = '';
            }
        }
        updateUIElements();
    });
}

  console.log('âœ… All event listeners re-attached after rebuild');
  
  // âœ… ENHANCED: Auto-focus first tray input after rebuild
  setTimeout(() => {
    autoFocusFirstTrayInput();
  }, 50);
}

// Fixed updateTrayScanSummary function
function updateTrayScanSummary() {
  const detailsDiv = document.getElementById("trayScanDetails");
  const summaryDiv = document.getElementById("trayScanSummary");
  if (!detailsDiv || !summaryDiv) return;

  // Find all qty and tray id inputs
  // 1. After Redo Button Click (inside trayIDRedoBtn click handler, after detailsDiv.innerHTML = html;)
console.log('ðŸŸ¢ [REDO] Tray Qty List:', originalDataToRestore.map(x => x.trayQty));
console.log('ðŸŸ¢ [REDO] Row count:', originalDataToRestore.length);

  const qtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
console.log('ðŸ”µ [MODAL OPEN] Tray Qty List:', Array.from(trayQtyInputs).map(x => x.value));
console.log('ðŸ”µ [MODAL OPEN] Row count:', trayQtyInputs.length);

  // If no rows yet, show 0/0
  if (qtyInputs.length === 0 || trayIdInputs.length === 0) {
    summaryDiv.textContent = `Qty to Scan: 0/0`;
    return;
  }

  let total = 0;
  let scanned = 0; // Count of filled tray IDs

  for (let i = 0; i < qtyInputs.length; i++) {
    const qty = parseInt(qtyInputs[i].value, 10) || 0;
    total += qty;
    
    // If Tray ID is filled, add its qty to scanned
    if (trayIdInputs[i] && trayIdInputs[i].value.trim()) {
      scanned += qty;
    }
  }

  // Show: scanned quantity / total quantity
  summaryDiv.textContent = `Qty to Scan: ${scanned}/${total}`;
}

// Updated validation function to not reset quantities
function validateAllTrayIds() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return false;
  
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
  let allFilled = true;
  
  trayIdInputs.forEach((input, index) => {
    if (!input.value.trim()) {
      allFilled = false;
      console.log(`Tray ID ${index + 1} is empty:`, input.value);
    } else {
      console.log(`Tray ID ${index + 1} is filled:`, input.value);
    }
  });
  
  console.log('All Tray IDs filled:', allFilled, 'Total inputs:', trayIdInputs.length);
  return allFilled && trayIdInputs.length > 0;
}

// Listen for changes in tray ID fields only (not quantities unless manually edited)
document.addEventListener("DOMContentLoaded", function () {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (detailsDiv) {
    detailsDiv.addEventListener("input", function (e) {
      // Only update when tray ID fields change, not quantity fields automatically
      if (e.target.matches('input[type="text"]')) {
        updateTrayScanSummary();
        updateUIElements();
      }
      // For quantity fields, only update if user manually changes them
      if (e.target.matches('input[type="number"]') && !e.target.readOnly) {
        updateTrayScanSummary();
      }
    });
  }
});

// âœ… ENHANCED: Get current tray data from DOM elements (real-time data)
function getCurrentDOMTrayScanData() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return [];

  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
  const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
  
  const data = [];
  for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
    data.push({
      trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
      trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
      position: i,
      draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : ''
    });
  }
  
  console.log('ðŸ“Š Current DOM data extracted:', data);
  return data;
}

// âœ… ENHANCED: Auto-focus first tray ID input
function autoFocusFirstTrayInput() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) {
    console.warn('âš ï¸ Cannot focus - details div not found');
    return;
  }
  
  const firstTrayIdInput = detailsDiv.querySelector('input[type="text"]:not([readonly])');
  if (firstTrayIdInput) {
    setTimeout(() => {
      firstTrayIdInput.focus();
      firstTrayIdInput.select();
      console.log('ðŸŽ¯ Auto-focused first tray ID input');
    }, 50);
  } else {
    console.warn('âš ï¸ Cannot focus - first tray ID input not found');
  }
}

// âœ… ENHANCED: Function to create backup of original data (call this when modal first opens)
function createBackupOriginalData() {
  if (window.originalTrayScanData && window.originalTrayScanData.length > 0 && !window.backupOriginalTrayScanData) {
    window.backupOriginalTrayScanData = JSON.parse(JSON.stringify(window.originalTrayScanData));
    console.log('ðŸ’¾ Backup created with', window.backupOriginalTrayScanData.length, 'rows');
  }
}

// âœ… ENHANCED: Function to reset all data (call this when modal closes)
function resetTrayScanData() {
  window.originalTrayScanData = null;
  window.backupOriginalTrayScanData = null;
  console.log('ðŸ—‘ï¸ All tray scan data reset');
}

</script>

  <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {

      const cancelBtn = document.getElementById("trayScanCancelBtn");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", function () {
          const modal = document.getElementById("trayScanModal");
          if (modal) modal.classList.remove("open");
        });
      }

       // DELETE BUTTON HANDLER
      document.querySelectorAll('a[title="Delete"]').forEach(function(btn) {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          const row = btn.closest('tr');
          if (!row) return;
          const trayScanLink = row.querySelector('.tray-scan-btn');
          if (!trayScanLink) return;
          const batchId = trayScanLink.getAttribute('data-batch-id');
          if (!batchId) {
            Swal.fire('Error', 'Batch ID not found!', 'error');
            return;
          }
          Swal.fire({
            title: 'Are you sure?',
            text: 'Do you really want to delete this batch?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Yes, delete it!',
            cancelButtonText: 'Cancel'
          }).then((result) => {
            if (result.isConfirmed) {
              fetch('/recovery_dp/rec_delete_batch/', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ batch_id: batchId })
              })
              .then(res => res.json())
              .then(data => {
                if (data.success) {
                  row.remove();
                  Swal.fire({
                    icon: 'success',
                    title: 'Deleted!',
                    text: 'Batch has been deleted.',
                    timer: 1200,
                    showConfirmButton: false
                  });                  
                } else {
                  Swal.fire('Error', data.error || 'Delete failed', 'error');
                }
              });
            }
          });
        });
      });

// REPLACE the entire edit button section (around lines 640-780) with this COMPLETE FIXED VERSION:

// REPLACE the entire edit button section with this INDIVIDUAL SAVE VERSION:

document.querySelectorAll('.edit-qty-btn').forEach(function(btn) {
  btn.addEventListener('click', async function(e) {
    e.preventDefault();
    const row = btn.closest('tr');
    if (!row) return;
    const qtyCell = row.querySelector('td:nth-child(12)');
    const colorCell = row.querySelector('td:nth-child(5)');
    const batchId = btn.getAttribute('data-batch-id');
    const oldQty = qtyCell.textContent.trim();
    const oldColor = colorCell.textContent.trim();

    // Prevent multiple inputs
    if (qtyCell.querySelector('input') || colorCell.querySelector('.color-arrow-up')) return;

    // Fetch plating colors from API
    let platingColors = [];
    try {
      const res = await fetch('/recovery_dp/rec_get_plating_colors/');
      const data = await res.json();
      if (data.success && Array.isArray(data.plating_colors)) {
        platingColors = data.plating_colors;
      }
    } catch (e) {}

    // Find current color index
    let colorIdx = platingColors.findIndex(c => c === oldColor);
    if (colorIdx === -1) colorIdx = 0;

    // Track what user is editing
    let isEditingColor = false;
    let isEditingQuantity = false;
    let colorChanged = false;
    let quantityChanged = false;

    // Build plating color arrows UI
    colorCell.innerHTML = `
      <div style="display:flex;align-items:center;gap:4px;">
        <button type="button" class="color-arrow-up" style="border:none;background:none;font-size:18px;">&#9650;</button>
        <input type="text" class="form-control color-input" value="${platingColors[colorIdx] || ''}" style="width:90px;text-align:center;background:#f8f8f8;" readonly />
        <button type="button" class="color-arrow-down" style="border:none;background:none;font-size:18px;">&#9660;</button>
      </div>
    `;

    qtyCell.innerHTML = `<input type="number" min="1" class="form-control qty-input" value="${oldQty}" style="width: 80px; display:inline-block;" />`;
    
    
    const qtyInput = qtyCell.querySelector('.qty-input');
    const colorInput = colorCell.querySelector('.color-input');
    const upBtn = colorCell.querySelector('.color-arrow-up');
    const downBtn = colorCell.querySelector('.color-arrow-down');

// FIND the arrow button handlers in your code and REPLACE with this:

// Arrow navigation - automatically focus color input after click
upBtn.onclick = (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (colorIdx > 0) {
    colorIdx -= 1;
    colorInput.value = platingColors[colorIdx];
    isEditingColor = true;
    colorChanged = true;
    console.log('Color changed to:', colorInput.value);
    
    // âœ… NEW: Auto-focus color input after arrow click
    setTimeout(() => {
      colorInput.focus();
    }, 10);
  }
};

downBtn.onclick = (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (colorIdx < platingColors.length - 1) {
    colorIdx += 1;
    colorInput.value = platingColors[colorIdx];
    isEditingColor = true;
    colorChanged = true;
    console.log('Color changed to:', colorInput.value);
    
    // âœ… NEW: Auto-focus color input after arrow click
    setTimeout(() => {
      colorInput.focus();
    }, 10);
  }
};

    // Quantity input events - marks quantity as being edited
    qtyInput.addEventListener('input', function() {
      isEditingQuantity = true;
      quantityChanged = true;
      console.log('Quantity changed to:', qtyInput.value);
    });

    qtyInput.addEventListener('focus', function() {
      isEditingQuantity = true;
    });

    colorInput.addEventListener('focus', function() {
      isEditingColor = true;
    });

    // INDIVIDUAL SAVE FUNCTIONS

    function saveQuantityOnly() {
      if (!quantityChanged) {
        console.log('No quantity changes to save');
        return;
      }

      const newQty = qtyInput.value.trim();
      if (!newQty || isNaN(newQty) || parseInt(newQty) <= 0) {
        Swal.fire('Error', 'Enter a valid quantity.', 'error');
        qtyInput.focus();
        return;
      }

      console.log('Saving ONLY quantity:', newQty);
      
      fetch('/recovery_dp/rec_update_batch_quantity_and_color/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          batch_id: batchId,
          total_batch_quantity: newQty,
          // Don't send plating_color - keep original
        })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          qtyCell.textContent = newQty;
          colorCell.textContent = oldColor; // Keep original color
          Swal.fire({
            icon: 'success',
            title: 'Quantity Updated!',
            text: `Quantity changed to ${newQty}`,
            timer: 1000,
            showConfirmButton: false
          }).then(() => location.reload());
        } else {
          Swal.fire('Error', data.error || 'Update failed', 'error');
          revertChanges();
        }
      })
      .catch(() => {
        Swal.fire('Error', 'Network error', 'error');
        revertChanges();
      });
    }

    function saveColorOnly() {
      if (!colorChanged) {
        console.log('No color changes to save');
        return;
      }

      const newColor = colorInput.value;
      console.log('Saving ONLY color:', newColor);
      
      fetch('/recovery_dp/rec_update_batch_quantity_and_color/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          batch_id: batchId,
          plating_color: newColor,
          // Don't send total_batch_quantity - keep original
        })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          colorCell.textContent = newColor;
          qtyCell.textContent = oldQty; // Keep original quantity
          Swal.fire({
            icon: 'success',
            title: 'Color Updated!',
            text: `Color changed to ${newColor}`,
            timer: 1000,
            showConfirmButton: false
          }).then(() => location.reload());
        } else {
          Swal.fire('Error', data.error || 'Update failed', 'error');
          revertChanges();
        }
      })
      .catch(() => {
        Swal.fire('Error', 'Network error', 'error');
        revertChanges();
      });
    }

    // INDIVIDUAL ENTER KEY HANDLERS

    // Quantity input - Enter saves ONLY quantity
    qtyInput.addEventListener('keydown', function(ev) {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        saveQuantityOnly();
      }
      if (ev.key === 'Escape') {
        revertChanges();
      }
    });

    // Color input - Enter saves ONLY color  
    colorInput.addEventListener('keydown', function(ev) {
      if (ev.key === 'ArrowUp') {
        ev.preventDefault();
        upBtn.click(); // Trigger arrow click
      } else if (ev.key === 'ArrowDown') {
        ev.preventDefault();
        downBtn.click(); // Trigger arrow click
      } else if (ev.key === 'Enter') {
        ev.preventDefault();
        saveColorOnly();
      } else if (ev.key === 'Escape') {
        revertChanges();
      }
    });

    // Revert function
    function revertChanges() {
      qtyCell.textContent = oldQty;
      colorCell.textContent = oldColor;
    }

    // Blur handlers - revert only if no changes made
    qtyInput.addEventListener('blur', function() {
      setTimeout(() => {
        const activeEl = document.activeElement;
        if (!activeEl || (!qtyCell.contains(activeEl) && !colorCell.contains(activeEl))) {
          if (!quantityChanged && !colorChanged) {
            revertChanges();
          }
        }
      }, 150);
    });

    colorInput.addEventListener('blur', function() {
      setTimeout(() => {
        const activeEl = document.activeElement;
        if (!activeEl || (!qtyCell.contains(activeEl) && !colorCell.contains(activeEl))) {
          if (!quantityChanged && !colorChanged) {
            revertChanges();
          }
        }
      }, 150);
    });

    // Initial focus on quantity input
    qtyInput.focus();
    qtyInput.select();
  });
});

      

const table = document.getElementById("order-listing");
      if (!table) {
        console.warn("Table with ID 'order-listing' not found.");
        return;
      }

      const headers = table.querySelectorAll("thead th");
      const tbody = table.querySelector("tbody");

      let sortDirection = {};

      headers.forEach((header, index) => {
        header.style.cursor = "pointer";

        header.addEventListener("click", function () {
          const rows = Array.from(tbody.querySelectorAll("tr"));
          const dir = sortDirection[index] === "asc" ? "desc" : "asc";
          sortDirection[index] = dir;

          rows.sort((a, b) => {
            const cellA = a.children[index].textContent.trim();
            const cellB = b.children[index].textContent.trim();
            const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
            const valB = isNaN(cellB) ? cellB : parseFloat(cellB);

            if (valA < valB) return dir === "asc" ? -1 : 1;
            if (valA > valB) return dir === "asc" ? 1 : -1;
            return 0;
          });

          tbody.innerHTML = "";
          rows.forEach((row) => tbody.appendChild(row));
        });
      });
    });
  </script>



 <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var textarea = tooltip.querySelector("textarea");
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the batch_id from the row (tr) data attribute or from a hidden field
            var row = trigger.closest("tr");
            var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
            var batchId = trayScanLink ? trayScanLink.getAttribute('data-batch-id') : null;
            if (!batchId) {
              Swal.fire('Error', 'Batch ID not found.', 'error');
              return;
            }
            fetch('/recovery_dp/rec_save_dp_pick_remark/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                batch_id: batchId,
                remark: remark
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire({
                  icon: 'success',
                  title: 'Remark saved!',
                  timer: 1200,
                  showConfirmButton: false
                }).then(() => {
                  // Make the textarea readonly
                  if (textarea) {
                    textarea.setAttribute("readonly", true);
                  }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }

                   // Find the chat icon <img> inside this trigger
                    const chatImg = trigger.querySelector('img[alt="Chat"]');
                    if (chatImg) {
                      chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                      chatImg.style.opacity = "1";
                    }

                  hideTooltip(); // optional if you still want to hide the tooltip
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });
    });
  </script>



  <!-- Script for Tray Scan - Modal Popup -->
<script nonce="{{ csp_nonce }}">
// ===== CROSS-BROWSER AUTO-SAVE FUNCTIONALITY =====
// ===== COMPLETE FIXED CROSS-BROWSER AUTO-SAVE FUNCTIONALITY =====
const TrayModalCrossBrowserAutoSave = {
    currentBatchId: null,
    saveTimeout: null,
    isInitialized: false,
    
    init(batchId) {
        this.currentBatchId = batchId;
        this.isInitialized = true;
        console.log(`ðŸ”„ Cross-browser auto-save initialized for batch: ${batchId}`);
        this.setupEventListeners();
    },
    
    async saveData() {
        if (!this.currentBatchId || !this.isInitialized) return;
        
        const detailsDiv = document.getElementById("trayScanDetails");
        if (!detailsDiv) return;
        
        const trayData = [];
        const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
        const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
        
        for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
            trayData.push({
                position: i,
                trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
                trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
                draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : ''
            });
        }
        
        const modalData = {};
        const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
        modalData.topTrayVerified = verifyCheckbox ? verifyCheckbox.checked : false;
        modalData.checkboxDisabled = verifyCheckbox ? verifyCheckbox.disabled : false;
        
        try {
            const response = await fetch('/recovery_dp/rec_tray_auto_save/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    batch_id: this.currentBatchId,
                    tray_data: trayData,
                    modal_data: modalData
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log(`ðŸ’¾ Cross-browser auto-save successful for batch ${this.currentBatchId}`);
                this.showAutoSaveIndicator();
            } else {
                console.warn('âš ï¸ Auto-save failed:', result.error);
            }
            
        } catch (error) {
            console.warn('âš ï¸ Auto-save network error:', error);
            // Fallback to localStorage if server is unavailable
            this.fallbackToLocalStorage(trayData, modalData);
        }
    },
    
    fallbackToLocalStorage(trayData, modalData) {
        try {
            const fallbackData = {
                timestamp: Date.now(),
                batchId: this.currentBatchId,
                trayData: trayData,
                modalData: modalData,
                isFallback: true
            };
            localStorage.setItem(`tray_scan_fallback_${this.currentBatchId}`, JSON.stringify(fallbackData));
            console.log('ðŸ“¦ Fallback to localStorage successful');
        } catch (e) {
            console.warn('âš ï¸ Fallback to localStorage failed:', e);
        }
    },
    
    showAutoSaveIndicator() {
        let indicator = document.getElementById('crossBrowserAutoSaveIndicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'crossBrowserAutoSaveIndicator';
            indicator.style.cssText = `
                position: fixed; top: 80px; right: 20px; background: #17a2b8; color: white;
                padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 99999;
                opacity: 0; transition: opacity 0.3s; font-weight: 600;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            `;
            indicator.innerHTML = '<i class="fa fa-cloud"></i> Auto-saved to server';
            document.body.appendChild(indicator);
        }
        
        indicator.style.opacity = '1';
        setTimeout(() => {
            indicator.style.opacity = '0';
        }, 2000);
    },
    
    // ðŸ”§ FIXED: Enhanced restoreData with quantity validation
    // ðŸ”§ FIXED: More nuanced restore logic that allows legitimate restoration
async restoreData() {
    if (!this.currentBatchId) return false;
    
    try {
        // First try to get data from server
        const response = await fetch(`/recovery_dp/rec_tray_auto_save/?batch_id=${encodeURIComponent(this.currentBatchId)}`, {
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        });
        
        const result = await response.json();
        
        if (result.success && result.has_data) {
            const data = result.data;
            
            // Check if data has valid tray information (tray IDs entered)
            const hasValidTrayIds = data.tray_data && data.tray_data.some(tray => 
                tray.trayId.trim() !== ''
            );
            
            // ðŸ”§ FIXED: Only do quantity validation if user has actually entered tray IDs
            if (hasValidTrayIds) {
                const currentButton = document.querySelector(`[data-batch-id="${this.currentBatchId}"]`);
                const expectedTotalQty = currentButton ? parseInt(currentButton.getAttribute('data-total-batch-quantity') || '0', 10) : 0;
                
                // Calculate total quantity from auto-saved data
                let autoSavedTotalQty = 0;
                if (data.tray_data) {
                    data.tray_data.forEach(tray => {
                        autoSavedTotalQty += parseInt(tray.trayQty || '0', 10);
                    });
                }
                
                console.log(`ðŸ” Quantity validation (Server - with tray IDs):`);
                console.log(`   Expected (from button): ${expectedTotalQty}`);
                console.log(`   Auto-saved: ${autoSavedTotalQty}`);
                console.log(`   Has tray IDs: ${hasValidTrayIds}`);
                
                // ðŸ”§ FIXED: Only clear if there's a significant quantity mismatch AND tray IDs exist
                // This prevents restoring old quantities after edits but allows normal restoration
                const quantityDifference = Math.abs(autoSavedTotalQty - expectedTotalQty);
                const isSignificantMismatch = quantityDifference > (expectedTotalQty * 0.1); // 10% difference threshold
                
                if (isSignificantMismatch && autoSavedTotalQty > 0 && expectedTotalQty > 0) {
                    console.log(`âš ï¸ Significant quantity mismatch detected (${quantityDifference} difference)`);
                    console.log(`   This likely indicates outdated data from quantity edit - clearing`);
                    
                    // Clear outdated auto-save data
                    await this.clearData();
                    return false;
                } else {
                    console.log(`âœ… Quantity difference acceptable (${quantityDifference}) - proceeding with restoration`);
                }
            } else {
                console.log(`âœ… No tray IDs in auto-save data - safe to restore basic data`);
            }
            
            // Check if data has any meaningful information to restore
            const hasAnyValidData = data.tray_data && (
                data.tray_data.some(tray => tray.trayId.trim() !== '') ||
                (data.modal_data && data.modal_data.topTrayVerified)
            );
            
            if (hasAnyValidData) {
                setTimeout(() => this.performRestore(data, 'server'), 300);
                return true;
            }
        }
        
        // Fallback to localStorage if no server data
        return this.restoreFromLocalStorage();
        
    } catch (error) {
        console.warn('âš ï¸ Failed to restore from server, trying localStorage:', error);
        return this.restoreFromLocalStorage();
    }
},

// ðŸ”§ FIXED: Same nuanced approach for localStorage
restoreFromLocalStorage() {
    try {
        const fallbackData = localStorage.getItem(`tray_scan_fallback_${this.currentBatchId}`);
        if (!fallbackData) return false;
        
        const data = JSON.parse(fallbackData);
        
        // Check if data is recent (24 hours)
        const isRecent = (Date.now() - data.timestamp) < (24 * 60 * 60 * 1000);
        if (!isRecent) {
            localStorage.removeItem(`tray_scan_fallback_${this.currentBatchId}`);
            return false;
        }
        
        // Check if data has valid tray IDs
        const hasValidTrayIds = data.trayData && data.trayData.some(tray => 
            tray.trayId.trim() !== ''
        );
        
        // ðŸ”§ FIXED: Only validate quantities if tray IDs exist
        if (hasValidTrayIds) {
            const currentButton = document.querySelector(`[data-batch-id="${this.currentBatchId}"]`);
            const expectedTotalQty = currentButton ? parseInt(currentButton.getAttribute('data-total-batch-quantity') || '0', 10) : 0;
            
            let localStorageTotalQty = 0;
            if (data.trayData) {
                data.trayData.forEach(tray => {
                    localStorageTotalQty += parseInt(tray.trayQty || '0', 10);
                });
            }
            
            console.log(`ðŸ” Quantity validation (LocalStorage - with tray IDs):`);
            console.log(`   Expected: ${expectedTotalQty}, LocalStorage: ${localStorageTotalQty}`);
            
            const quantityDifference = Math.abs(localStorageTotalQty - expectedTotalQty);
            const isSignificantMismatch = quantityDifference > (expectedTotalQty * 0.1); // 10% difference threshold
            
            if (isSignificantMismatch && localStorageTotalQty > 0 && expectedTotalQty > 0) {
                console.log(`âš ï¸ LocalStorage significant quantity mismatch - clearing outdated data`);
                localStorage.removeItem(`tray_scan_fallback_${this.currentBatchId}`);
                return false;
            } else {
                console.log(`âœ… LocalStorage quantity difference acceptable - proceeding with restoration`);
            }
        } else {
            console.log(`âœ… No tray IDs in localStorage - safe to restore basic data`);
        }
        
        // Check if data has any meaningful information to restore
        const hasAnyValidData = data.trayData && (
            data.trayData.some(tray => tray.trayId.trim() !== '') ||
            (data.modalData && data.modalData.topTrayVerified)
        );
        
        if (hasAnyValidData) {
            // Convert localStorage format to server format
            const serverFormatData = {
                tray_data: data.trayData,
                modal_data: data.modalData
            };
            setTimeout(() => this.performRestore(serverFormatData, 'localStorage'), 300);
            return true;
        }
        
        return false;
        
    } catch (e) {
        console.warn('âš ï¸ Failed to restore from localStorage:', e);
        return false;
    }
},
    
    performRestore(data, source) {
        const detailsDiv = document.getElementById("trayScanDetails");
        if (!detailsDiv) return;
        
        const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
        const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
        let restoredCount = 0;
        
        // Restore tray data
        data.tray_data.forEach((trayInfo, index) => {
            if (trayIdInputs[index] && trayInfo.trayId.trim() !== '') {
                trayIdInputs[index].value = trayInfo.trayId;
                restoredCount++;
            }
            if (trayQtyInputs[index] && trayInfo.trayQty !== '') {
                trayQtyInputs[index].value = trayInfo.trayQty;
            }
            if (trayIdInputs[index] && trayInfo.draftId) {
                trayIdInputs[index].setAttribute('data-draft-id', trayInfo.draftId);
            }
        });
        
        // Restore checkbox state
        const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
        if (verifyCheckbox && data.modal_data && !verifyCheckbox.disabled) {
            verifyCheckbox.checked = data.modal_data.topTrayVerified || false;
        }
        
        if (restoredCount > 0) {
            this.showRestorationNotification(restoredCount, source);
            setTimeout(() => {
                if (typeof updateUIElements === 'function') updateUIElements();
                if (typeof updateTrayScanSummary === 'function') updateTrayScanSummary();
            }, 100);
        }
    },
    
    showRestorationNotification(count, source) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed; top: 120px; left: 50%; transform: translateX(-50%);
            background: #28a745; color: white; padding: 15px 25px; border-radius: 8px;
            font-size: 14px; font-weight: 600; z-index: 99999;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            max-width: 90vw; text-align: center;
        `;
        
        const sourceText = source === 'server' ? 'from any browser/device' : 'from this browser';
        const icon = source === 'server' ? 'ðŸŒ' : 'ðŸ’¾';
        
        notification.innerHTML = `
            ${icon} <strong>Auto-saved data restored</strong><br>
            <small>${count} tray ID${count > 1 ? 's' : ''} restored ${sourceText}</small>
        `;
        
        document.body.appendChild(notification);
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 4000);
    },
    
    async clearData() {
        if (!this.currentBatchId) return;
        
        try {
            // Clear from server
            const response = await fetch(`/recovery_dp/rec_tray_auto_save/?batch_id=${encodeURIComponent(this.currentBatchId)}`, {
                method: 'DELETE',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
            
            const result = await response.json();
            if (result.success) {
                console.log(`ðŸ—‘ï¸ Server auto-save cleared for batch ${this.currentBatchId}`);
            }
            
        } catch (error) {
            console.warn('âš ï¸ Failed to clear server auto-save:', error);
        }
        
        // Also clear localStorage fallback
        try {
            localStorage.removeItem(`tray_scan_fallback_${this.currentBatchId}`);
            console.log(`ðŸ—‘ï¸ LocalStorage fallback cleared for batch ${this.currentBatchId}`);
        } catch (e) {
            console.warn('âš ï¸ Failed to clear localStorage fallback:', e);
        }
    },
    
    setupEventListeners() {
        const detailsDiv = document.getElementById("trayScanDetails");
        if (!detailsDiv) {
            setTimeout(() => this.setupEventListeners(), 100);
            return;
        }
        
        // Auto-save on input changes (debounced)
        detailsDiv.addEventListener('input', (e) => {
            if (e.target.matches('input[type="text"], input[type="number"]')) {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => this.saveData(), 1000); // 1 second debounce for server calls
            }
        });
        
        // Auto-save on checkbox changes (immediate)
        detailsDiv.addEventListener('change', (e) => {
            if (e.target.matches('input[type="checkbox"]')) {
                // Immediate save for checkbox changes
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => this.saveData(), 100);
            }
        });
        
        // Auto-save on blur (when user moves away from input)
        detailsDiv.addEventListener('blur', (e) => {
            if (e.target.matches('input[type="text"], input[type="number"]')) {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => this.saveData(), 200);
            }
        }, true);
        
        // Save on beforeunload (tab close/refresh)
        this.beforeUnloadHandler = () => {
            // Use sendBeacon for reliable saving on page unload
            if (navigator.sendBeacon && this.currentBatchId) {
                const detailsDiv = document.getElementById("trayScanDetails");
                if (detailsDiv) {
                    const trayData = [];
                    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                    
                    for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
                        trayData.push({
                            position: i,
                            trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
                            trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
                            draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : ''
                        });
                    }
                    
                    const modalData = {};
                    const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
                    modalData.topTrayVerified = verifyCheckbox ? verifyCheckbox.checked : false;
                    modalData.checkboxDisabled = verifyCheckbox ? verifyCheckbox.disabled : false;
                    
                    const payload = JSON.stringify({
                        batch_id: this.currentBatchId,
                        tray_data: trayData,
                        modal_data: modalData
                    });
                    
                    // Use sendBeacon for reliable saving on page unload
                    const formData = new FormData();
                    formData.append('data', payload);
                    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
                    
                    navigator.sendBeacon('/recovery_dp/rec_tray_auto_save/', formData);
                }
            }
        };
        
        window.addEventListener('beforeunload', this.beforeUnloadHandler);
    },
    
    cleanup() {
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
        if (this.beforeUnloadHandler) {
            window.removeEventListener('beforeunload', this.beforeUnloadHandler);
        }
        this.currentBatchId = null;
        this.isInitialized = false;
    }
};

// ===== UTILITY FUNCTIONS =====
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    console.log(`ðŸ” CSRF Token: ${cookieValue ? 'Found' : 'Not Found'}`);
    return cookieValue;
}

function clearTrayVerificationMessage() {
    const footer = document.getElementById('trayQtyErrorFooter');
    if (footer) {
        footer.textContent = '';
        footer.style.color = '';
    }
}

function handleNetworkError(error, context = '') {
    console.error(`âŒ Network Error in ${context}:`, error);
    
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
        Swal.fire({
            icon: 'error',
            title: 'Connection Error',
            text: 'Unable to connect to server. Please check your internet connection and try again.',
            confirmButtonColor: '#007bff'
        });
    } else if (error.status === 403) {
        Swal.fire({
            icon: 'error',
            title: 'Permission Denied',
            text: 'You do not have permission to perform this action. Please refresh the page and try again.',
            confirmButtonColor: '#007bff'
        });
    } else if (error.status === 404) {
        Swal.fire({
            icon: 'error',
            title: 'Not Found',
            text: 'The requested resource was not found. Please refresh the page.',
            confirmButtonColor: '#007bff'
        });
    } else {
        Swal.fire({
            icon: 'error',
            title: 'Network Error',
            text: `An error occurred: ${error.message || 'Unknown error'}. Please try again.`,
            confirmButtonColor: '#007bff'
        });
    }
}

function validateAllTrayIds() {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return false;
    
    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    let allFilled = true;
    
    trayIdInputs.forEach((input, index) => {
        if (!input.value.trim()) {
            allFilled = false;
            console.log(`Tray ID ${index + 1} is empty:`, input.value);
        } else {
            console.log(`Tray ID ${index + 1} is filled:`, input.value);
        }
    });
    
    console.log('All Tray IDs filled:', allFilled, 'Total inputs:', trayIdInputs.length);
    return allFilled && trayIdInputs.length > 0;
}

function updateUIElements() {
    const allTrayIdsFilled = validateAllTrayIds();
    const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
    const submitBtn = document.getElementById('trayScanSubmitBtn');
    const isCheckboxChecked = verifyCheckbox && verifyCheckbox.checked;

    if (verifyCheckbox) {
        const isAlreadyVerified = verifyCheckbox.checked && verifyCheckbox.disabled;
        if (!isAlreadyVerified) {
            if (allTrayIdsFilled) {
                verifyCheckbox.disabled = false;
                verifyCheckbox.style.opacity = '1';
                verifyCheckbox.style.cursor = 'pointer';
            } else {
                verifyCheckbox.disabled = true;
                verifyCheckbox.checked = false;
                verifyCheckbox.style.opacity = '0.5';
                verifyCheckbox.style.cursor = 'not-allowed';
            }
        }
    }

    if (submitBtn) {
        let tooltipMsg = "";
        if (!allTrayIdsFilled && !isCheckboxChecked) {
            tooltipMsg = "Fill all Tray IDs and verify the top tray quantity to enable Submit.";
        } else if (!allTrayIdsFilled) {
            tooltipMsg = "Please fill all Tray IDs to enable Submit.";
        } else if (!isCheckboxChecked) {
            tooltipMsg = "Please verify the top tray quantity to enable Submit.";
        } else {
            tooltipMsg = "";
        }

        if (allTrayIdsFilled && isCheckboxChecked) {
            submitBtn.disabled = false;
            submitBtn.style.opacity = '1';
            submitBtn.style.cursor = 'pointer';
            submitBtn.style.backgroundColor = '#28a745';
            submitBtn.removeAttribute('title');
        } else {
            submitBtn.disabled = true;
            submitBtn.style.opacity = '0.5';
            submitBtn.style.cursor = 'not-allowed';
            submitBtn.style.backgroundColor = '#6c757d';
            submitBtn.setAttribute('title', tooltipMsg);
        }
    }

    updateTrayScanSummary();
}

function handleQuantityChange(qtyInput, position) {
    const quantity = parseInt(qtyInput.value, 10) || 0;
    const row = qtyInput.closest('tr') || qtyInput.closest('div[style*="display:"]');
    
    if (quantity === 0) {
        if (row) {
            row.style.opacity = '0.5';
            row.style.backgroundColor = '#ffebee';
            row.title = 'This tray will be delinked (quantity = 0)';
        }
        console.log(`Position ${position}: Marked for delinking (qty = 0)`);
    } else {
        if (row) {
            row.style.opacity = '1';
            row.style.backgroundColor = '';
            row.title = '';
        }
        console.log(`Position ${position}: Active tray (qty = ${quantity})`);
    }
    
    updateTrayScanSummary();
    updateUIElements();
}

function updateTrayScanSummary() {
    const detailsDiv = document.getElementById("trayScanDetails");
    const summaryDiv = document.getElementById("trayScanSummary");
    if (!detailsDiv || !summaryDiv) return;

    const qtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');

    if (qtyInputs.length === 0 || trayIdInputs.length === 0) {
        summaryDiv.textContent = `Qty to Scan: 0/0`;
        return;
    }

    let totalQuantity = 0;
    let scannedQuantity = 0;

    for (let i = 0; i < qtyInputs.length; i++) {
        const qty = parseInt(qtyInputs[i].value, 10) || 0;
        
        if (qty > 0) {
            totalQuantity += qty;
            
            if (trayIdInputs[i] && trayIdInputs[i].value.trim()) {
                scannedQuantity += qty;
            }
        }
    }

    summaryDiv.textContent = `Qty to Scan: ${scannedQuantity}/${totalQuantity}`;
    
    const modalTrayQty = document.getElementById("modalTrayQty");
    if (modalTrayQty && totalQuantity > 0) {
        modalTrayQty.textContent = totalQuantity;
    }
}

// ===== MAIN MODAL LOGIC =====
document.addEventListener("DOMContentLoaded", () => {
    
// ðŸŽ¯ UPDATED FUNCTIONS WITH NO OF TRAYS AUTO-UPDATE
function updateRowAfterTrayScan(batchId, needsTopTrayScan = true, isDraft = true) {
    console.log('ðŸ”„ Updating row after tray scan completion');
    
    // Find the row with matching batch ID
    const allTrayScanBtns = document.querySelectorAll('.tray-scan-btn');
    let targetRow = null;
    let targetButton = null;

    allTrayScanBtns.forEach(btn => {
        if (btn.getAttribute('data-batch-id') === batchId) {
            targetButton = btn;
            targetRow = btn.closest('tr');
        }
    });

    if (!targetRow || !targetButton) {
        console.warn('âš ï¸ Could not find target row for batch ID:', batchId);
        return;
    }

    // 1. Update button text and data attributes
    if (needsTopTrayScan) {
        targetButton.textContent = 'Set Top Tray';
        targetButton.setAttribute('data-needs-top-tray-scan', 'true');
        console.log('âœ… Button updated to "Set Top Tray"');
    }

    // ðŸŽ¯ NEW: Update Input Qty in the main table (column 12)
    const inputQtyCell = targetRow.querySelector('td:nth-child(12)'); // Input Qty column
    if (inputQtyCell) {
        // Get the actual scanned quantity from the modal
        const modalTrayQty = document.getElementById("modalTrayQty");
        if (modalTrayQty) {
            const newInputQty = modalTrayQty.textContent.trim();
            inputQtyCell.textContent = newInputQty;
            
            // Also update the button's data attribute
            targetButton.setAttribute('data-total-batch-quantity', newInputQty);
            console.log('âœ… Input Qty updated to:', newInputQty);
        }
    }

    // ðŸŽ¯ NEW: Update No of Trays in the main table (column 11)
    const noOfTraysCell = targetRow.querySelector('td:nth-child(11)'); // No of Trays column
    if (noOfTraysCell) {
        // Calculate actual number of trays from modal data
        const detailsDiv = document.getElementById("trayScanDetails");
        let actualNoOfTrays = 0;
        
        if (detailsDiv) {
            const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
            const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
            
            // Count trays with both tray ID and non-zero quantity
            for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
                const trayId = trayIdInputs[i] ? trayIdInputs[i].value.trim() : '';
                const trayQty = trayQtyInputs[i] ? parseInt(trayQtyInputs[i].value, 10) || 0 : 0;
                
                if (trayId && trayQty > 0) {
                    actualNoOfTrays++;
                }
            }
        }
        
        // Update the cell and button data attribute
        noOfTraysCell.textContent = actualNoOfTrays;
        targetButton.setAttribute('data-no-of-trays', actualNoOfTrays.toString());
        console.log('âœ… No of Trays updated to:', actualNoOfTrays);
    }

    // 2. Update lot status to Draft
    if (isDraft) {
        const lotStatusCell = targetRow.querySelector('td:nth-child(15)'); // Lot Status column
        if (lotStatusCell) {
            lotStatusCell.innerHTML = `
                <div
                  class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                  style="
                    border: 1px solid #4997ac;
                    background-color: #d1f2f3;
                    color: #03425d;
                    font-size: 13px;
                    white-space: nowrap;
                    padding: 5px;
                    
                  "
                >
                  Draft
                </div>
            `;
            console.log('âœ… Lot status updated to "Draft"');
        }
    }

    // 3. Update process status to partial (half green, half gray)
    const processStatusCell = targetRow.querySelector('td:nth-child(13)'); // Process Status column
    if (processStatusCell) {
        processStatusCell.innerHTML = `
            <div
                title="Tray Scan - Partial"
                class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                style="
                  width: 28px;
                  height: 28px;
                  background: linear-gradient(
                    to right,
                    green 50%,
                    #bfbfbf 50%
                  );
                  color: white;
                  font-weight: bold;
                  line-height: 20px;
                  text-align: center;
                  padding-top: 1px;
                  padding-right: 1px;"
            >
                T
            </div>
        `;
        console.log('âœ… Process status updated to partial completion');
    }

    // 4. Update data attributes for future functionality
    targetButton.setAttribute('data-draft-saved', 'True');
    targetButton.setAttribute('data-moved-to-d-picker', 'False');

    // ðŸŽ¯ NEW: Update the stored modal data for correct reopening
    updateStoredModalData(batchId);

    console.log('ðŸŽ‰ Row update completed successfully with No of Trays auto-update');
}

function updateRowAfterTopTrayScan(batchId) {
    const allTrayScanBtns = document.querySelectorAll('.tray-scan-btn');
    let targetRow = null;
    let targetButton = null;

    allTrayScanBtns.forEach(btn => {
        if (btn.getAttribute('data-batch-id') === batchId) {
            targetButton = btn;
            targetRow = btn.closest('tr');
        }
    });

    if (!targetRow || !targetButton) {
        console.warn('âš ï¸ Could not find target row for batch ID:', batchId);
        return;
    }

    // Update button text back to indicate completion
    targetButton.textContent = 'Tray Scan'; 
    targetButton.setAttribute('data-needs-top-tray-scan', 'false');
    targetButton.setAttribute('data-moved-to-d-picker', 'True');

    // ðŸŽ¯ NEW: Update No of Trays in the main table (column 11)
    const noOfTraysCell = targetRow.querySelector('td:nth-child(11)'); // No of Trays column
    if (noOfTraysCell) {
        // Get the current no of trays from button data attribute (already updated in updateRowAfterTrayScan)
        const currentNoOfTrays = targetButton.getAttribute('data-no-of-trays') || '0';
        noOfTraysCell.textContent = currentNoOfTrays;
        console.log('âœ… No of Trays confirmed as:', currentNoOfTrays);
    }

    // Update lot status to "Yet To Release"
    const lotStatusCell = targetRow.querySelector('td:nth-child(15)');
    if (lotStatusCell) {
        lotStatusCell.innerHTML = `
            <div
              class="d-inline-block px-3 fw-semibold text-center rounded-pill"
              style="
                border: 1px solid #0d5d17;
                background-color: #c5f9c2;
                color: #2f801b;
                font-size: 13px;
                white-space: nowrap;
                padding: 5px;
                
              "
            >
              Yet To Release
            </div>
        `;
    }

    // Update process status to fully complete (green)
    const processStatusCell = targetRow.querySelector('td:nth-child(13)');
    if (processStatusCell) {
        processStatusCell.innerHTML = `
            <div
              title="Tray Scan - Complete"
              class="d-flex align-items-center justify-content-center rounded-circle ms-1"
              style="
                width: 28px;
                height: 28px;
                background-color: #0c8249;
                color: white;
                font-weight: bold;
              "
            >
              T
            </div>
        `;
    }

    console.log('ðŸŽ‰ Row updated after top tray scan completion with No of Trays confirmation');
}

// ðŸŽ¯ UPDATED FUNCTION: Enhanced stored modal data update with no of trays calculation

function updateStoredModalData(batchId) {
    console.log('ðŸ“‹ Updating stored modal data for batch:', batchId);
        
    // Find the tray scan button to update its data attributes
    const allTrayScanBtns = document.querySelectorAll('.tray-scan-btn');
    let targetButton = null;

    allTrayScanBtns.forEach(btn => {
        if (btn.getAttribute('data-batch-id') === batchId) {
            targetButton = btn;
        }
    });

    if (!targetButton) {
        console.warn('âš ï¸ Could not find target button for batch ID:', batchId);
        return;
    }

    // Get current modal data
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');

    // ðŸŽ¯ NEW: Get and preserve checkbox state
    const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
    const isCheckboxChecked = verifyCheckbox ? verifyCheckbox.checked : false;
    const isCheckboxDisabled = verifyCheckbox ? verifyCheckbox.disabled : false;

    console.log('ðŸ’¾ Preserving checkbox state:', {
        checked: isCheckboxChecked,
        disabled: isCheckboxDisabled
    });

    // Calculate new data
    let newTrayQtyList = [];
    let totalQty = 0;
    let nonZeroRows = [];

    for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
        const qty = parseInt(trayQtyInputs[i]?.value || 0, 10);
        const trayId = trayIdInputs[i]?.value.trim() || '';
        
        if (qty > 0 && trayId) {
            newTrayQtyList.push(qty);
            totalQty += qty;
            nonZeroRows.push({
                trayId: trayId,
                trayQty: qty,
                position: nonZeroRows.length // Reindex starting from 0
            });
        }
    }

    // Update button data attributes with new values
    targetButton.setAttribute('data-tray-qty-list', JSON.stringify(newTrayQtyList));
    targetButton.setAttribute('data-total-batch-quantity', totalQty.toString());
    targetButton.setAttribute('data-no-of-trays', nonZeroRows.length.toString());

    // ðŸŽ¯ NEW: Store checkbox state in button data attributes
    targetButton.setAttribute('data-top-tray-qty-verified', isCheckboxChecked ? 'True' : 'False');
    targetButton.setAttribute('data-checkbox-disabled', isCheckboxDisabled ? 'True' : 'False');

    console.log('âœ… Updated button data attributes:');
    console.log('   - Total Qty:', totalQty);
    console.log('   - No of Trays:', nonZeroRows.length);
    console.log('   - Tray Qty List:', newTrayQtyList);
    console.log('   - Checkbox Verified:', isCheckboxChecked);
    console.log('   - Checkbox Disabled:', isCheckboxDisabled);
}



const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
const modal = document.getElementById("trayScanModal");
const closeBtn = document.getElementById("closeTrayScanModal");
const detailsDiv = document.getElementById("trayScanDetails");
const modalModelNo = document.getElementById("modalModelNo");

// ===== ENHANCED TRAY SCAN MODAL WITH DYNAMIC ROW MANAGEMENT =====

    // ===== ENHANCED TRAY SCAN MODAL WITH DYNAMIC ROW MANAGEMENT =====

// ðŸš€ NEW: Helper functions for dynamic row management
function getCurrentTrayData() {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return [];

    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
    
    const data = [];
    for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
        data.push({
            trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
            trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
            position: i,
            draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : ''
        });
    }
    return data;
}

function rebuildTrayScanTable(currentData, newRowCount, trayCapacity, topTrayQtyVerified) {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    console.log(`ðŸ”„ Rebuilding table: ${newRowCount} rows`);

    // Build new HTML structure - 3 column layout only (no validation status column during rebuild)
    let html = `
        <div style="min-height:32px;">S.no</div>
        <div style="min-height:32px;">Tray ID</div>
        <div style="min-height:32px;">Tray Quantity</div>
    `;

    // Generate rows for the new count
    for (let i = 0; i < newRowCount; i++) {
        const isTopTray = (i === 0);
        const sNo = isTopTray ? '1 (Top Tray)' : (i + 1);
        
        // Get existing data for this position
        const existingTrayId = currentData[i] ? currentData[i].trayId : '';
        const existingTrayQty = currentData[i] ? currentData[i].trayQty : trayCapacity;
        const existingDraftId = currentData[i] ? currentData[i].draftId : '';
        
        html += `
            <div style="min-height:32px;">${sNo}</div>
            <div style="min-height:32px;">
                <input type="text" class="form-control tray-id-input" value="${existingTrayId}" data-draft-id="${existingDraftId}" data-position="${i}" style="width: 100%;" />
            </div>
            <div style="min-height:32px;">
                ${
                  isTopTray
                    ? `<div style="display: flex; align-items: center; justify-content: space-between;">
                      <input type="number" class="form-control tray-qty-input" value="${existingTrayQty}" style="width: 60px;" readonly />
                      <div style="display: flex; align-items: center; gap: 27px;">
                          <input type="checkbox" class="tray-verify-checkbox" style="width: 18px; height: 18px; cursor: pointer;" ${buttonElement ? getCheckboxStateHTML(topTrayQtyVerified, buttonElement) : (topTrayQtyVerified ? 'checked disabled' : '')} />
                          <img src="{% static 'assets/icons/edit2.png' %}" alt="Edit" class="tray-edit-btn" style="width: 18px; height: 18px; cursor: pointer;${buttonElement ? getEditButtonStyleHTML(topTrayQtyVerified, buttonElement) : (topTrayQtyVerified ? 'opacity:0.5;pointer-events:none;' : '')}" />
                      </div>
                      </div>`
                    : `<input type="number" class="form-control" value="${existingTrayQty}" style="width: 100%;" readonly />`
                }
            </div>
        `;
    }

    // Update the HTML
    detailsDiv.innerHTML = html;
    console.log('âœ… Table rebuilt successfully with checkbox state preservation');
}



function handleTopTrayZeroQuantity() {
    
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    // Get the top tray ID input
    const topTrayIdInput = detailsDiv.querySelector('input[type="text"]');
    const topTrayId = topTrayIdInput ? topTrayIdInput.value.trim() : '';

    console.log(`ðŸ“‹ Top tray ID: "${topTrayId}"`);

    if (!topTrayId) {
        // ðŸŽ¯ SCENARIO 1: No tray ID in top tray, quantity is 0
        // Remove one row and shift everything up
        handleRemoveOneRow();
    } else {
        // ðŸŽ¯ SCENARIO 2: Tray ID exists but quantity is 0
        // Use existing delink/top tray scan functionality
        console.log('âœ… Top tray has ID but zero quantity - using existing delink functionality');
    }
}

function handleRemoveOneRow() {
    console.log('ðŸ—‘ï¸ Removing one row due to top tray being empty with zero quantity');
    
    const currentData = getCurrentTrayData();
    const currentRowCount = currentData.length;

    if (currentRowCount <= 1) {
      console.log('âš ï¸ Cannot remove row - minimum 1 row required');
      return;
    }

    // Create new data array excluding the first row
    const newData = currentData.slice(1); // Remove first row
    const newRowCount = newData.length;

    console.log(`ðŸ“Š Reducing from ${currentRowCount} rows to ${newRowCount} rows`);

    // Get modal configuration
    const trayCapacity = getCurrentTrayCapacity();
    const topTrayQtyVerified = isTopTrayQtyVerified();

    // ðŸŽ¯ NEW: Get button element for checkbox state preservation
    const batchId = window.currentTrayScanBatchId;
    const buttonElement = document.querySelector(`[data-batch-id="${batchId}"]`);

    // Rebuild the table with new row count and checkbox state
    rebuildTrayScanTable(newData, newRowCount, trayCapacity, topTrayQtyVerified, buttonElement);

    // Update the modal total quantity display
    updateModalTotalQuantity(newRowCount, trayCapacity);

    // Re-attach all event listeners after rebuilding
    setTimeout(() => {
      attachEnhancedEventListeners();
    }, 100);

    console.log('âœ… Row removal completed with checkbox state preservation');
}

function getCurrentTrayCapacity() {
    return window.currentModalConfig ? window.currentModalConfig.trayCapacity : 12;
}

function isTopTrayQtyVerified() {
    return window.currentModalConfig ? window.currentModalConfig.topTrayQtyVerified : false;
}

function updateModalTotalQuantity(rowCount, trayCapacity) {
    const modalTrayQty = document.getElementById("modalTrayQty");
    if (modalTrayQty) {
        const newTotal = rowCount * trayCapacity;
        modalTrayQty.textContent = newTotal;
        console.log(`ðŸ“ˆ Updated modal total quantity to: ${newTotal}`);
    }
}
// ðŸš€ ENHANCED: Function to attach all event listeners after table rebuild
function attachEnhancedEventListeners() {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    const trayCapacity = getCurrentTrayCapacity();
    const topTrayQtyVerified = isTopTrayQtyVerified();
    
    // Attach listeners to tray ID inputs
    const trayIdInputs = detailsDiv.querySelectorAll('.tray-id-input');
    trayIdInputs.forEach(input => {
        input.addEventListener('input', updateUIElements);
        input.addEventListener('blur', updateUIElements);
    });

    // Enhanced top tray quantity input handler
    const editBtn = detailsDiv.querySelector('.tray-edit-btn');
    const qtyInput = detailsDiv.querySelector('.tray-qty-input');
    const errorFooter = document.getElementById('trayQtyErrorFooter');

    if (editBtn && qtyInput && !topTrayQtyVerified) {
        // Remove existing listeners to prevent duplicates
        const newEditBtn = editBtn.cloneNode(true);
        editBtn.parentNode.replaceChild(newEditBtn, editBtn);
        
        const newQtyInput = qtyInput.cloneNode(true);
        qtyInput.parentNode.replaceChild(newQtyInput, qtyInput);

        // âœ… ENHANCED: Store original quantity for decrease-only validation
        let originalQuantity = parseInt(newQtyInput.value, 10) || 0;

        // Add edit button listener
        newEditBtn.addEventListener('click', function (e) {
            e.preventDefault();
            // âœ… Capture original quantity at edit time
            originalQuantity = parseInt(newQtyInput.value, 10) || 0;
            console.log('âœï¸ Edit started (Enhanced) - Original quantity:', originalQuantity);
            
            newQtyInput.removeAttribute('readonly');
            newQtyInput.focus();
            newQtyInput.select();
        });

        // ðŸš€ ENHANCED: Quantity input handler with decrease-only + dynamic row management
        newQtyInput.addEventListener('input', function () {
            if (errorFooter) {
                errorFooter.textContent = 'Qty modified';
                errorFooter.style.color = '#007bff';
            } 
            
            let val = parseInt(newQtyInput.value, 10) || 0;
            
            // âœ… ENHANCED: Only allow decrease from original quantity
            if (val > originalQuantity) {
                newQtyInput.value = originalQuantity;
                if (errorFooter) {
                    errorFooter.textContent = `Quantity can only be decreased. Maximum allowed: ${originalQuantity}`;
                    errorFooter.style.color = '#d32f2f';
                }
                val = originalQuantity;
            } else if (val > trayCapacity) {
                newQtyInput.value = trayCapacity;
                if (errorFooter) errorFooter.textContent = `Tray Qty cannot exceed Tray Capacity (${trayCapacity})`;
            } else if (val < 0) {
                newQtyInput.value = 0;
                val = 0;
            }

            
            updateUIElements();
                });

        // Handle enter key and blur events
        newQtyInput.addEventListener('keydown', function (ev) {
            if (ev.key === 'Enter') {
                newQtyInput.setAttribute('readonly', 'readonly');
                newQtyInput.blur();
            }
        });

        newQtyInput.addEventListener('blur', function () {
            newQtyInput.setAttribute('readonly', 'readonly');
            if (errorFooter) errorFooter.textContent = '';
        });
    }

    const verifyCheckbox = detailsDiv.querySelector('input[type="checkbox"]');
if (verifyCheckbox) {
    verifyCheckbox.addEventListener('change', function() {
        if (verifyCheckbox.checked) {
            if (!validateAllTrayIds()) {
                verifyCheckbox.checked = false;
                if (errorFooter) {
                    errorFooter.textContent = '';
                }
                Swal.fire({
                    icon: 'warning',
                    title: 'Incomplete Data',
                    text: 'Please fill all Tray IDs before verifying.',
                    confirmButtonColor: '#007bff'
                });
                return;
            }
            if (errorFooter) {
                errorFooter.textContent = 'Top tray qty verified';
                errorFooter.style.color = 'green';
            }
        } else {
            if (errorFooter) {
                errorFooter.textContent = '';
            }
        }
        updateUIElements();
    });
}

    updateUIElements();
    console.log('âœ… Enhanced event listeners attached with decrease-only editing');
}
// ===== MODIFIED MAIN TRAY SCAN HANDLER =====

trayScanLinks.forEach((link) => {
    link.addEventListener("click", async (event) => {
        event.preventDefault();

        // Get tray scan status from the clicked link
        const trayScanStatus = link.getAttribute('data-tray-scan-status') === 'true';
        // Show/hide redo button based on tray scan status
        const redoButton = document.getElementById('trayIDRedoBtn');
        if (redoButton) {
            if (trayScanStatus === false) {
                // Show redo button when tray scan status is false
                redoButton.style.display = 'inline-block';
            } else {
                // Hide redo button when tray scan status is true
                redoButton.style.display = 'none';
            }
        }
        
        // âœ… CROSS-BROWSER AUTO-SAVE: Initialize for this batch
        window.currentTrayScanBatchId = event.target.getAttribute("data-batch-id");
        TrayModalCrossBrowserAutoSave.init(window.currentTrayScanBatchId);
        clearTrayVerificationMessage();
        const needsTopTrayScan = link.getAttribute('data-needs-top-tray-scan') === 'true';

        const row = event.target.closest("tr");
        if (!row) return;
        document.querySelectorAll("tbody tr").forEach((row) => {
            row.classList.remove("highlighted-tray-scan");
        });
        row.classList.add("highlighted-tray-scan");

        // Get dynamic data from the clicked row
        const batchId = event.target.getAttribute("data-batch-id");
        const modelNo = event.target.getAttribute("data-model-no");
        const noOfTrays = parseInt(event.target.getAttribute("data-no-of-trays")) || 0;
        const trayCapacity = parseInt(event.target.getAttribute("data-tray-capacity")) || 12; 
        const topTrayQtyVerified = event.target.getAttribute("data-top-tray-qty-verified") === "True";
        const draftSaved = event.target.getAttribute("data-draft-saved") === "True";
        const movedToDPicker = event.target.getAttribute("data-moved-to-d-picker") === "True";
        
        // NEW: Store current modal configuration for use by enhanced functions
        window.currentModalConfig = {
            batchId,
            modelNo,
            noOfTrays,
            trayCapacity,
            topTrayQtyVerified,
            draftSaved,
            movedToDPicker
        };

        // Update modal with dynamic model number
        if (modalModelNo && modelNo) {
            modalModelNo.textContent = modelNo;
        }

        // Update model image
        const modalUserImg = modal.querySelector('.modal-top-header img');
        const modelImage = link.getAttribute('data-model-image');
        if (modalUserImg) {
            if (modelImage) {
                modalUserImg.src = modelImage;
            } else {
                modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
            }
        }

        const modalTrayQty = document.getElementById("modalTrayQty");
        const totalBatchQty = event.target.getAttribute("data-total-batch-quantity");
        if (modalTrayQty && totalBatchQty) {
            modalTrayQty.textContent = totalBatchQty;
        }

        // Try to fetch DraftTrayId data first, fallback to TrayId
        let traysData = [];
        let isDraft = false;
        try {
            const draftResp = await fetch(`/recovery_dp/rec_draft_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
            const draftResult = await draftResp.json();
            if (draftResult.success && Array.isArray(draftResult.trays) && draftResult.trays.length > 0) {
                traysData = draftResult.trays;
                isDraft = true;
            } else {
                const resp = await fetch(`/recovery_dp/rec_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
                const result = await resp.json();
                if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
                    traysData = result.trays;
                    isDraft = false;
                }
            }
        } catch (e) {
            // Ignore fetch errors, fallback to default
        }

        let html = `
            <div style="min-height:32px;">S.no</div>
            <div style="min-height:32px;">Tray ID</div>
            <div style="min-height:32px;">Tray Quantity</div>
        `;

        let showButtons = true;
        let trayQtyList = [];
        try {
            trayQtyList = JSON.parse(event.target.getAttribute("data-tray-qty-list") || "[]");
        } catch (e) {
            trayQtyList = [];
        }
        let totalRows = noOfTrays;
        
        const traysByPosition = {};
        if (isDraft) {
            traysData.forEach(tray => {
                if (tray.position !== undefined) {
                    traysByPosition[tray.position] = tray;
                }
            });
            console.log('ðŸ” Draft trays mapped by position:', traysByPosition);
        }
        
        for (let i = 0; i < totalRows; i++) {
            let tray = {};
            
            if (isDraft) {
                tray = traysByPosition[i] || {};
                console.log(`Position ${i}:`, tray);
            } else {
                tray = traysData[i] || {};
            }
            
            const trayQty = tray.tray_quantity || trayQtyList[i] || trayCapacity;
            
            html += `
                <div style="min-height:32px;">${i === 0 ? '1 (Top Tray)' : (i + 1)}</div>
                <div style="min-height:32px;">
                    <input type="text" class="form-control tray-id-input" value="${tray.tray_id || ''}" data-draft-id="${tray.id || ''}" data-position="${i}" style="width: 100%;" />
                </div>
                <div style="min-height:32px;">
                    ${
                      i === 0
                        ? `<div style="display: flex; align-items: center; justify-content: space-between;">
                          <input type="number" class="form-control tray-qty-input" value="${trayQty}" style="width: 60px;" readonly />
                          <div style="display: flex; align-items: center; gap: 27px;">
                              <input type="checkbox" class="tray-verify-checkbox" style="width: 18px; height: 18px; cursor: pointer;" ${topTrayQtyVerified ? 'checked disabled' : ''} />
                              <img src="{% static 'assets/icons/edit2.png' %}" alt="Edit" class="tray-edit-btn" style="width: 18px; height: 18px; cursor: pointer;${topTrayQtyVerified ? 'opacity:0.5;pointer-events:none;' : ''}" />
                          </div>
                          </div>`
                        : `<input type="number" class="form-control" value="${trayQty}" style="width: 100%;" readonly />`
                    }
                </div>
            `;
        }
        
        showButtons = isDraft || traysData.length === 0;
        detailsDiv.innerHTML = html;
        if (detailsDiv) {
  window.originalTrayScanData = [];
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
  const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
  for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
    window.originalTrayScanData.push({
      trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
      trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
      draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : '',
      topTrayQtyVerified: i === 0 ? (detailsDiv.querySelector('.tray-verify-checkbox')?.checked || false) : false
    });
  }
}


        // ðŸš€ ENHANCED: Initialize UI validation with enhanced event listeners
        setTimeout(() => {
            attachEnhancedEventListeners();
        }, 100);

        // Auto-focus the first Tray ID input when modal opens
        const firstTrayIdInput = detailsDiv.querySelector('input[type="text"]:not([readonly])');
        if (firstTrayIdInput) {
            firstTrayIdInput.focus();
            firstTrayIdInput.select();
        }

        const isReleased = event.target.getAttribute("data-moved-to-d-picker") === "True";
        
        if (isReleased) {
            detailsDiv.querySelectorAll('input').forEach(inp => inp.setAttribute('readonly', 'readonly'));
        }
        
        const buttonSection = modal.querySelector('.tray-scan-modal-content > div[style*="justify-content: center"]');
        if (buttonSection) {
            buttonSection.style.display = isReleased ? "none" : (showButtons ? "flex" : "none");
        }

        modal.classList.add("open");

        // --- Show Top Tray Scan UI if needed ---
        if (needsTopTrayScan) {
            showTopTrayScanUIInModal(batchId); // Pass batchId if your function needs it
        } else {
            // Remove/hide the Top Tray Scan UI if present
            const existingSection = document.getElementById('topTrayScanSection');
            if (existingSection) existingSection.remove();
        }

        // âœ… CROSS-BROWSER AUTO-SAVE: Try to restore data after modal is loaded
        setTimeout(async () => {
            const wasRestored = await TrayModalCrossBrowserAutoSave.restoreData();
            if (wasRestored) {
                console.log('ðŸ“‹ Cross-browser auto-save data restored');
            }
        }, 500);

        // Tray ID validation logic
        if (!isReleased) {
            const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
            trayIdInputs.forEach((input, idx, allInputs) => {
                input.addEventListener('input', function () {
                    let prevError = input.parentNode.querySelector('.tray-id-error');
                    if (prevError) prevError.remove();
                    
                    input.style.borderColor = '';
                    input.style.backgroundColor = '';
                    
                    updateUIElements();
                });

                input.addEventListener('blur', async function () {
                    let prevError = input.parentNode.querySelector('.tray-id-error');
                    if (prevError) prevError.remove();

                    const trayId = input.value.trim();
                    if (!trayId) {
                        updateUIElements();
                        return;
                    }

                    // Check for duplicates in modal
                    let duplicateInModal = false;
                    allInputs.forEach((otherInput, otherIdx) => {
                        if (otherIdx !== idx && otherInput.value.trim() === trayId) {
                            duplicateInModal = true;
                        }
                    });
                    if (duplicateInModal) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = 'red';
                        errorDiv.style.fontSize = '12px';
                        errorDiv.textContent = 'Already scanned in a row!';
                        input.parentNode.appendChild(errorDiv);
                        input.focus();
                        input.select();
                        updateUIElements();
                        return;
                    }

                    // Backend validation
                    try {
                        const currentBatchId = window.currentTrayScanBatchId || '';
                        const resp = await fetch(`/recovery_dp/rec_tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}&batch_id=${encodeURIComponent(currentBatchId)}`);
                        const result = await resp.json();
                        
                        if (result.tray_not_in_system) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = '#d32f2f';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            
                            errorDiv.innerHTML = `
                                <div style="color: #d32f2f;">âŒ Invalid Barcode ID</div>
                                
                            `;
                            
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#d32f2f';
                            input.style.backgroundColor = '#ffebee';
                            input.focus();
                            input.select();
                            
                        } else if (result.already_scanned) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = '#d32f2f';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            
                            errorDiv.innerHTML = `<div style="color: #d32f2f;">âŒ Already Scanned</div>`;
                            
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#d32f2f';
                            input.style.backgroundColor = '#ffebee';
                            input.focus();
                            input.select();
                            
                        } else if (result.tray_type_error) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = 'red';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            
                            errorDiv.innerHTML = `
                                <div style="color: #d32f2f;">âŒ Tray Type Mismatch</div>
                                <div style="font-size: 10px; margin-top: 2px;">
                                    Batch Type: <strong>${result.batch_tray_type || 'Not Set'}</strong><br>
                                    Scanned Type: <strong>${result.scanned_tray_type || 'Not Set'}</strong>
                                </div>
                            `;
                            
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#ff5722';
                            input.style.backgroundColor = '#fff3e0';
                            input.focus();
                            input.select();
                            
                        } else if (!result.available) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = 'red';
                            errorDiv.style.fontSize = '12px';
                            errorDiv.textContent = result.error || 'Tray not available!';
                            input.parentNode.appendChild(errorDiv);
                            
                            input.style.borderColor = '#d32f2f';
                            input.style.backgroundColor = '#ffebee';
                            input.focus();
                            input.select();
                        }
                        else if (result.delink_tray) {
                          // Match "Available" style for delinked trays
                          input.style.borderColor = '#4caf50';
                          input.style.backgroundColor = '#f1f8e9'; // same as Available
                          const infoDiv = document.createElement('div');
                          infoDiv.className = 'tray-id-success';
                          infoDiv.style.color = '#2e7d32';
                          infoDiv.style.fontSize = '11px';
                          infoDiv.style.fontWeight = 'bold';
                          infoDiv.innerHTML = `âœ… Delinked - available for reuse`;
                          input.parentNode.appendChild(infoDiv);
                        
                          // Auto-disappear after 2 seconds (like Available)
                          setTimeout(() => {
                            if (infoDiv.parentNode) {
                              infoDiv.parentNode.removeChild(infoDiv);
                            }
                          }, 2000);
                                                    
                        } else if (result.available) {
                            input.style.borderColor = '#4caf50';
                            input.style.backgroundColor = '#f1f8e9';
                            
                            if (result.status === 'pre_configured') {
                                const successDiv = document.createElement('div');
                                successDiv.className = 'tray-id-success';
                                successDiv.style.color = '#2e7d32';
                                successDiv.style.fontSize = '11px';
                                successDiv.style.fontWeight = 'bold';
                                successDiv.innerHTML = `âœ… Available (${result.tray_type || 'Type not set'})`;
                                input.parentNode.appendChild(successDiv);
                                
                                setTimeout(() => {
                                    if (successDiv.parentNode) {
                                        successDiv.parentNode.removeChild(successDiv);
                                    }
                                }, 2000);
                            }
                        }
                    } catch (e) {
                        console.error('Tray validation error:', e);
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = '#ff5722';
                        errorDiv.style.fontSize = '12px';
                        errorDiv.textContent = 'Validation error - please try again';
                        input.parentNode.appendChild(errorDiv);
                    }
                    updateUIElements();
                });
                
                input.addEventListener('keydown', async function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                        setTimeout(() => {
                            if (!input.parentNode.querySelector('.tray-id-error')) {
                                const nextInput = allInputs[idx + 1];
                                if (nextInput) {
                                    nextInput.focus();
                                    nextInput.select();
                                }
                            } else {
                                input.focus();
                                input.select();
                            }
                        }, 50);
                    }
                });
            });
        }


        // âœ… CROSS-BROWSER AUTO-SAVE: Enhanced draft button with auto-save clearing
        const draftBtn = document.getElementById('trayScanDraftBtn');
        if (draftBtn) {
            draftBtn.onclick = function() {
                if (detailsDiv.querySelector('.tray-id-error')) {
                    Swal.fire('Error', 'Please fix duplicate Tray IDs before saving draft.', 'error');
                    return;
                }
                detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());
          
                const trayRows = [];
                const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
          
                for (let i = 0; i < trayIdInputs.length; i++) {
                    const tray_id = trayIdInputs[i].value;
                    const tray_quantity = trayQtyInputs[i].value;
                    const draft_id = trayIdInputs[i].getAttribute('data-draft-id') || null;
                    
                    trayRows.push({
                        tray_id,
                        tray_quantity,
                        position: i,
                        id: draft_id
                    });
                }
                const batchId = window.currentTrayScanBatchId || '';
          
                console.log('ðŸš€ Saving draft with positions:', trayRows);
          
                fetch('/recovery_dp/rec_draft_tray/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        batch_id: batchId,
                        trays: trayRows
                    })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        // âœ… CROSS-BROWSER AUTO-SAVE: Clear auto-saved data on successful draft save
                        TrayModalCrossBrowserAutoSave.clearData();
                        
                        Swal.fire({
                            icon: 'success',
                            title: 'Success!',
                            text: 'Draft saved!',
                            timer: 1200,
                            showConfirmButton: false
                        }).then(() => {
                            location.reload();
                        });
                        modal.classList.remove("open");
                        clearTrayVerificationMessage();
                    } else {
                        Swal.fire('Error', data.error || 'Failed to save draft', 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Swal.fire('Error', 'Network error occurred', 'error');
                });
            };
        }
      
        // âœ… CROSS-BROWSER AUTO-SAVE: Enhanced submit button with auto-save clearing
        const submitBtn = document.getElementById('trayScanSubmitBtn');
        if (submitBtn) {
            submitBtn.onclick = function() {
                const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
                const isCheckboxChecked = verifyCheckbox && verifyCheckbox.checked;
                
                if (!isCheckboxChecked) {
                    Swal.fire({
                        icon: 'warning',
                        title: 'Verification Required',
                        text: 'Please verify the top tray quantity before submitting.',
                        confirmButtonColor: '#007bff'
                    });
                    return;
                }
                
                if (!validateAllTrayIds()) {
                    Swal.fire({
                        icon: 'warning',
                        title: 'Incomplete Data',
                        text: 'Please fill all Tray IDs before submitting.',
                        confirmButtonColor: '#007bff'
                    });
                    return;
                }
                
                if (detailsDiv.querySelector('.tray-id-error')) {
                    Swal.fire('Error', 'Please fix all validation errors before submitting.', 'error');
                    return;
                }
                
                // FIRST: Verify top tray quantity if checkbox is checked
                if (isCheckboxChecked && !verifyCheckbox.disabled) {
                    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                    let totalQty = 0;
                    trayQtyInputs.forEach(input => {
                        totalQty += parseInt(input.value, 10) || 0;
                    });
                    
                    const batchId = window.currentTrayScanBatchId || '';
                    
                    console.log(`ðŸš€ Verifying top tray quantity before submit:`);
                    console.log(`   Batch ID: ${batchId}`);
                    console.log(`   Total Qty: ${totalQty}`);
                    
                    // Disable submit button during verification
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Verifying...';
                    
                    fetch('/recovery_dp/rec_verify_top_tray_qty/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken'),
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            batch_id: batchId,
                            verified_tray_qty: totalQty
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            console.log(`âœ… Top tray verification successful, proceeding with tray scan`);
                            
                            // Update UI to show verification success
                            verifyCheckbox.disabled = true;
                            const editBtn = detailsDiv.querySelector('.tray-edit-btn');
                            if (editBtn) {
                                editBtn.style.opacity = "0.5";
                                editBtn.style.pointerEvents = "none";
                            }
                            
                            const footer = document.getElementById('trayQtyErrorFooter');
                            if (footer) {
                                footer.textContent = 'Top tray quantity verified!';
                                footer.style.color = 'green';
                            }
                            
                            // NOW proceed with the actual tray scan submission
                            proceedWithTraySubmission();
                            
                        } else {
                            console.error(`âŒ Top tray verification failed:`, data.error);
                            
                            const footer = document.getElementById('trayQtyErrorFooter');
                            if (footer) {
                                footer.textContent = data.error || 'Failed to verify';
                                footer.style.color = 'red';
                            }
                            
                            Swal.fire({
                                icon: 'error',
                                title: 'Verification Failed',
                                text: data.error || 'Failed to verify top tray quantity. Please try again.',
                                confirmButtonColor: '#007bff'
                            });
                            
                            // Re-enable submit button
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Submit';
                        }
                    })
                    .catch(error => {
                        console.error(`âŒ Top tray verification error:`, error);
                        
                        const footer = document.getElementById('trayQtyErrorFooter');
                        if (footer) {
                            footer.textContent = 'Network error occurred';
                            footer.style.color = 'red';
                        }
                        
                        handleNetworkError(error, 'Top Tray Verification');
                        
                        // Re-enable submit button
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit';
                    });
                } else {
                    // Checkbox already verified, proceed directly
                    proceedWithTraySubmission();
                }
                
                // Function to handle the actual tray scan submission
                function proceedWithTraySubmission() {
                    detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());

                    const trayRows = [];
                    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                    
                    for (let i = 0; i < trayIdInputs.length; i++) {
                        const tray_id = trayIdInputs[i].value.trim();
                        const tray_quantity = trayQtyInputs[i].value;
                        
                        trayRows.push({
                            tray_id,
                            tray_quantity
                        });
                    }
                    
                    const batchId = window.currentTrayScanBatchId || '';

                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Processing...';

                    fetch('/recovery_dp/rec_tray_scan/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            batch_id: batchId,
                            trays: trayRows
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            // âœ… CROSS-BROWSER AUTO-SAVE: Clear auto-saved data on successful submit
                            TrayModalCrossBrowserAutoSave.clearData();
                    
                            if (data.top_tray_scan_required) {
                                console.log('ðŸ” Top tray scan required - updating UI and keeping modal open');
                    
                                // ðŸŽ¯ NEW: Update the row immediately without page refresh
                                updateRowAfterTrayScan(batchId, true, true);
                    
                              
                    
                                // Keep modal open and show top tray scan UI
                                showTopTrayScanUIInModal(batchId);
                                return;
                            }
                    
                            console.log('âœ… Normal tray scan success - closing modal');
                    
                            Swal.fire({
                                icon: 'success',
                                title: 'Tray Scan Completed!',
                                text: 'Tray scan saved successfully!',
                                timer: 1200,
                                showConfirmButton: false
                            }).then(() => {
                                const modal = document.getElementById("trayScanModal");
                                if (modal) modal.classList.remove("open");
                                clearTrayVerificationMessage();
                                location.reload();
                            });
                    
                        } else if (data.tray_not_in_system_errors) {
                            // Handle various error types as before...
                            // [Keep existing error handling code]
                        } else {
                            Swal.fire('Error', data.error || 'Failed to save tray scan', 'error');
                        }
                    })
                    
                    .catch(error => {
                        console.error('Error:', error);
                        Swal.fire('Error', 'Network error occurred', 'error');
                    })
                    .finally(() => {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit';
                    });
                }
            };
        }
                    

        // Top tray scan UI function
        function showTopTrayScanUIInModal(batchId) {
            console.log('ðŸ” Showing top tray scan UI within same modal for batch:', batchId);
            
            const modal = document.getElementById("trayScanModal");
            if (modal) {
                modal.classList.add("open");
            }
            
            const detailsDiv = document.getElementById("trayScanDetails");
            const buttonSection = document.querySelector('.tray-scan-modal-buttons');
            const errorFooter = document.getElementById('trayQtyErrorFooter');
            
            // ðŸŽ¯ NEW: Hide redo button when top tray scan UI is shown
            const redoButton = document.getElementById('trayIDRedoBtn');
            if (redoButton) {
                redoButton.style.display = 'none';
                console.log('âœ… Redo button hidden (top tray scan UI shown)');
            }

            if (detailsDiv) {
                detailsDiv.querySelectorAll('input, button, checkbox').forEach(element => {
                    element.disabled = true;
                    element.style.opacity = '0.5';
                    element.style.pointerEvents = 'none';
                });
            }
            
            if (buttonSection) {
                buttonSection.style.display = 'none';
            }
            
            if (errorFooter) {
                errorFooter.textContent = '';
                errorFooter.style.color = '';
            }
            
            const existingSection = document.getElementById('topTrayScanSection');
            if (existingSection) {
                existingSection.remove();
            }
            
            const topTrayScanHTML = `
                <div id="topTrayScanSection" style="margin-top: 20px; padding: 20px; border: 1px solid #28a745; border-radius: 8px; background: #f0fff4;">
                    <h6 style="color: #28a745; font-weight: 600; margin-bottom: 15px; text-align: center;">
                        ðŸ” Top Tray Scan Required
                    </h6>
                    <p style="text-align: center; color: #666; margin-bottom: 15px; font-size: 14px;">
                        The first tray quantity is 0. Please scan a tray ID from this batch to set as the top tray.
                    </p>
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: center; margin-bottom: 15px;">
                        <input 
                            type="text" 
                            id="topTrayIdInput" 
                            placeholder="Scan or enter top tray ID..." 
                            style="width: 250px; padding: 10px; border: 1px solid #28a745; border-radius: 4px; font-size: 14px; text-align: center;"
                        />
                        <button 
                            id="topTrayScanBtn" 
                            style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 14px;"
                            disabled
                        >
                            Set Top Tray
                        </button>
                    </div>
                    <div id="topTrayError" style="color: red; font-size: 12px; text-align: center; margin-top: 8px; min-height: 20px;"></div>
                    <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                        â„¹ï¸ Only non-delinked tray IDs from this batch are valid
                    </div>
                </div>
            `;
            
            if (detailsDiv) {
                detailsDiv.insertAdjacentHTML('afterend', topTrayScanHTML);
            }
            
            const topTrayIdInput = document.getElementById('topTrayIdInput');
            const topTrayScanBtn = document.getElementById('topTrayScanBtn');
            const topTrayError = document.getElementById('topTrayError');
            
            if (topTrayIdInput) {
                setTimeout(() => {
                    topTrayIdInput.focus();
                }, 100);
                
                topTrayIdInput.addEventListener('input', function() {
                    validateTopTrayId(topTrayIdInput.value.trim(), topTrayError, topTrayScanBtn, batchId);
                });
                
                topTrayIdInput.addEventListener('blur', function() {
                    validateTopTrayId(topTrayIdInput.value.trim(), topTrayError, topTrayScanBtn, batchId);
                });
                
                topTrayIdInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (!topTrayScanBtn.disabled) {
                            topTrayScanBtn.click();
                        }
                    }
                });
            }
            
            if (topTrayScanBtn) {
                topTrayScanBtn.onclick = function() {
                    const scannedTrayId = topTrayIdInput.value.trim();
                    
                    if (!scannedTrayId) {
                        topTrayError.textContent = 'Please enter a tray ID.';
                        topTrayError.style.color = 'red';
                        topTrayIdInput.focus();
                        return;
                    }
                    
                    topTrayError.textContent = '';
                    topTrayScanBtn.disabled = true;
                    topTrayScanBtn.textContent = 'Processing...';
                    topTrayScanBtn.style.opacity = '0.6';
                    
                    fetch('/recovery_dp/rec_top_tray_scan/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            batch_id: batchId,
                            scanned_tray_id: scannedTrayId
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                    if (data.success) {
                        // âœ… CROSS-BROWSER AUTO-SAVE: Clear auto-saved data on successful top tray scan
                        TrayModalCrossBrowserAutoSave.clearData();
                        updateRowAfterTopTrayScan(batchId);

                        // 1. Close the modal first
                        if (modal) modal.classList.remove("open");
                        clearTrayVerificationMessage();

                        // 2. Then show the success popup
                        setTimeout(() => {
                            Swal.fire({
                                icon: 'success',
                                title: 'Tray Scan Completed!',
                                text: 'Top tray set successfully!',
                                timer: 2000,
                                showConfirmButton: false
                            }).then(() => {
                                location.reload();
                            });
                        }, 300); // Small delay to ensure modal is closed before showing popup
                    } else {
                            topTrayError.style.color = 'red';
                            topTrayError.style.fontSize = '12px';
                            topTrayError.style.fontWeight = 'normal';
                            topTrayError.textContent = 'âŒ ' + (data.error || 'Failed to set top tray.');
                            topTrayIdInput.focus();
                            topTrayIdInput.select();
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        topTrayError.style.color = 'red';
                        topTrayError.style.fontSize = '12px';
                        topTrayError.style.fontWeight = 'normal';
                        topTrayError.textContent = 'âŒ Network error occurred.';
                        topTrayIdInput.focus();
                    })
                    .finally(() => {
                        if (!data || !data.success) {
                            topTrayScanBtn.disabled = false;
                            topTrayScanBtn.textContent = 'Set Top Tray';
                            topTrayScanBtn.style.opacity = '1';
                        }
                    });
                };
            }
            
            console.log('âœ… Top tray scan UI added to modal successfully');
        }



        async function validateTopTrayId(trayId, errorElement, buttonElement, batchId) {
            errorElement.textContent = '';
            errorElement.style.color = '';
            
            if (!trayId) {
                buttonElement.disabled = true;
                buttonElement.style.opacity = '0.5';
                return;
            }
            
            try {
                const response = await fetch(`/recovery_dp/rec_validate_top_tray/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        batch_id: batchId,
                        tray_id: trayId
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.valid) {
                    errorElement.style.color = 'green';
                    errorElement.textContent = 'âœ… Valid tray ID';
                    buttonElement.disabled = false;
                    buttonElement.style.opacity = '1';
                } else {
                    errorElement.style.color = 'red';
                    errorElement.textContent = 'âŒ ' + (result.error || 'Invalid tray ID');
                    buttonElement.disabled = true;
                    buttonElement.style.opacity = '0.5';
                }
                
            } catch (error) {
                console.error('Validation error:', error);
                errorElement.style.color = 'red';
                errorElement.textContent = 'âŒ Unable to validate tray ID';
                buttonElement.disabled = true;
                buttonElement.style.opacity = '0.5';
            }
        }
    });
});



console.log('âœ… Enhanced tray scan modal with dynamic row management loaded');
    
    // âœ… CROSS-BROWSER AUTO-SAVE: Enhanced close button handler
    closeBtn.addEventListener("click", () => {
        TrayModalCrossBrowserAutoSave.cleanup();
        modal.classList.remove("open");
        clearTrayVerificationMessage();
    });

    
    // âœ… CROSS-BROWSER AUTO-SAVE: Enhanced cancel button handler with user choice
    const cancelBtn = document.getElementById("trayScanCancelBtn");
    if (cancelBtn) {
        cancelBtn.addEventListener("click", async function () {
            // Check if there's any auto-saved data
            try {
                const response = await fetch(`/recovery_dp/rec_tray_auto_save/?batch_id=${encodeURIComponent(window.currentTrayScanBatchId)}`, {
                    method: 'GET',
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });
                const result = await response.json();
                

            } catch (e) {

            }
            
            TrayModalCrossBrowserAutoSave.cleanup();
            modal.classList.remove("open");
            clearTrayVerificationMessage();
        });
    }
});

console.log('ðŸŒ Cross-Browser Tray Modal Auto-Save system loaded');
</script>

    

<!-- Active row to be highlighted & Restores the highlighted row to its original position and removes the highlight bg when the tray scan modal is closed. -->
<script nonce="{{ csp_nonce }}">
// Row highlight for Tray Scan (matches highlightWF.html logic) + Move active row to top and restore on close
document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('dp-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'dp-row-action-highlight-style';
    style.innerHTML = `
      .dp-row-action-highlight {
        transition: box-shadow 1.3s;
        animation: highlightAnimation 2s ease-in-out;
      }
    `;
    document.head.appendChild(style);
  }

  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  document.querySelectorAll('.tray-scan-btn').forEach(function(link) {
    link.addEventListener('click', function(event) {
      // Remove highlight from all rows
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
      });
      // Move the clicked row to the top and highlight
      var row = event.target.closest('tr');
      if (row && row.parentNode) {
        const tbody = row.parentNode;
        // Only move if not already at top
        if (tbody.firstElementChild !== row) {
          // If a previous move exists, restore it first
          if (movedRow && placeholderRow && placeholderRow.parentNode) {
            placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
            placeholderRow.parentNode.removeChild(placeholderRow);
            movedRow.classList.remove('dp-row-action-highlight');
            movedRow = null;
            placeholderRow = null;
            originalRowIndex = null;
          }
          // Store original index and row
          originalRowIndex = Array.from(tbody.children).indexOf(row);
          movedRow = row;
          // Insert a placeholder at the original position
          placeholderRow = document.createElement('tr');
          placeholderRow.style.display = 'none';
          // Add same number of <td> as the moved row
for (let i = 0; i < row.children.length; i++) {
  placeholderRow.appendChild(document.createElement('td'));
}
          tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
          // Move row to top
          tbody.insertBefore(row, tbody.firstElementChild);
        }
        row.classList.add('dp-row-action-highlight');
      }
    });
  });

  // On modal close, restore row to original position and remove highlight for tray-scan-btn
  var closeBtn = document.getElementById('closeTrayScanModal');
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      if (movedRow && placeholderRow && placeholderRow.parentNode) {
        placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
        placeholderRow.parentNode.removeChild(placeholderRow);
        movedRow.classList.remove('dp-row-action-highlight');
        movedRow = null;
        placeholderRow = null;
        originalRowIndex = null;
      }
      // Also remove highlight from any row just in case
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
        row.classList.remove('highlighted-tray-scan');
      });
    });
  }


  // On modal close for view icon, restore row to original position and remove highlight.
  // FIX: Use the close button for the Recovery Onboard modal ("closeTrayScanModal_DayPlanning")
  var jigCloseBtn = document.getElementById('closeTrayScanModal_DayPlanning');
  if (jigCloseBtn) {
    jigCloseBtn.addEventListener('click', function() {
      if (movedRowJig && placeholderRowJig && placeholderRowJig.parentNode) {
        placeholderRowJig.parentNode.insertBefore(movedRowJig, placeholderRowJig);
        placeholderRowJig.parentNode.removeChild(placeholderRowJig);
        movedRowJig.classList.remove('dp-row-action-highlight');
        movedRowJig = null;
        placeholderRowJig = null;
        originalRowIndexJig = null;
      }
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
        row.classList.remove('highlighted-tray-scan');
      });
    });
  }
});
</script>

<!-- New script appended below without altering existing lines -->
<script nonce="{{ csp_nonce }}">
// Append new block: Clear highlight and restore row when Draft, Submit, or Cancel is clicked
document.addEventListener("DOMContentLoaded", function() {
  function clearHighlightAndRestore() {
    var closeBtn = document.getElementById('closeTrayScanModal');
    if (closeBtn) {
      closeBtn.click();
    }
    var jigCloseBtn = document.getElementById('closeTrayScanModal_DayPlanning');
    if (jigCloseBtn) {
      jigCloseBtn.click();
    }
  }
  
  var draftBtn = document.getElementById("trayScanDraftBtn");
  if (draftBtn) {
    draftBtn.addEventListener("click", function() {
      clearHighlightAndRestore();
    });
  }
  var submitBtn = document.getElementById("trayScanSubmitBtn");
  if (submitBtn) {
    submitBtn.addEventListener("click", function() {
      clearHighlightAndRestore();
    });
  }
  var cancelBtn = document.getElementById("trayScanCancelBtn");
  if (cancelBtn) {
    cancelBtn.addEventListener("click", function() {
      clearHighlightAndRestore();
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
// Updated JavaScript for hold toggle functionality
document.addEventListener("DOMContentLoaded", function () {
  let currentHoldCell = null;
  let intendedState = null;
  let currentBatchId = null;

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Toggle click handler
  document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
    btn.addEventListener('click', function (e) {
      e.preventDefault();
      currentHoldCell = btn.closest('td');
      intendedState = btn.checked;
      const row = currentHoldCell.closest('tr');
      currentBatchId = row.getAttribute('data-batch-id');
      
      document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
        intendedState ? 'Unholding Reason' : 'Holding Reason';
      document.getElementById('holdRemarkInput').value = '';
      document.getElementById('holdRemarkError').textContent = '';
      document.getElementById('holdRemarkModal').style.display = 'flex';
      document.getElementById('holdRemarkInput').focus();
    });
  });

  // Save remark and update backend
  document.getElementById('saveHoldRemarkBtn').onclick = function () {
    const remark = document.getElementById('holdRemarkInput').value.trim();
    if (!remark) {
      document.getElementById('holdRemarkError').textContent = 'Remark required!';
      return;
    }
    if (!currentHoldCell || !currentBatchId) return;
    
    const action = intendedState ? 'unhold' : 'hold';
    
    fetch('/recovery_dp/rec_save_hold_unhold_reason/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        batch_id: currentBatchId,
        remark: remark,
        action: action
      })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        const row = currentHoldCell.closest('tr');
        const toggle = currentHoldCell.querySelector('.hold-toggle-btn');
        const icon = currentHoldCell.querySelector('.hold-remark-icon');
        
        if (action === 'hold') {
          // Hold the row
          toggle.checked = false;
          row.classList.add('row-inactive');
          
          // Apply blur to all cells except the first one
          row.querySelectorAll('td').forEach((td, idx) => {
            if (idx > 0) {
              td.classList.add('row-inactive-blur');
            } else {
              td.classList.remove('row-inactive-blur');
            }
          });
          
          // Show and update the remark icon
          if (icon) {
            icon.style.display = 'inline-block';
            icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />`;
            icon.setAttribute('title', 'Holding Reason: ' + remark);          }
        } else {
          // Unhold the row
          toggle.checked = true;
          row.classList.remove('row-inactive');
          
          // Remove blur from all cells
          row.querySelectorAll('td').forEach(td => {
            td.classList.remove('row-inactive-blur');
          });
          
          // Hide the remark icon
          if (icon) {
            icon.style.display = 'none';
          }
        }
        
        document.getElementById('holdRemarkModal').style.display = 'none';
        location.reload(); // <-- Add this line to reload the page

      } else {
        document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
      }
    })
    .catch(() => {
      document.getElementById('holdRemarkError').textContent = 'Network error!';
    });
  };

  // Modal close
  document.getElementById('closeHoldRemarkModal').onclick = function () {
    document.getElementById('holdRemarkModal').style.display = 'none';
  };

  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});
</script>

<!-- /**
  * Script for sorting the order listing table
  * This script allows users to click on table headers to sort the rows based on the column data.
  */   -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const table = document.getElementById("order-listing");
  if (!table) return;
  const headers = table.querySelectorAll("thead th");
  const tbody = table.querySelector("tbody");
  let sortDirection = {};

  headers.forEach((header, index) => {
    header.style.cursor = "pointer";
    header.addEventListener("click", function () {
      const rows = Array.from(tbody.querySelectorAll("tr"));
      const dir = sortDirection[index] === "asc" ? "desc" : "asc";
      sortDirection[index] = dir;

      rows.sort((a, b) => {
        const cellA = a.children[index]?.textContent.trim() || "";
        const cellB = b.children[index]?.textContent.trim() || "";
        // Try numeric sort, fallback to string
        const numA = parseFloat(cellA.replace(/,/g, ""));
        const numB = parseFloat(cellB.replace(/,/g, ""));
        if (!isNaN(numA) && !isNaN(numB)) {
          return dir === "asc" ? numA - numB : numB - numA;
        }
        return dir === "asc"
          ? cellA.localeCompare(cellB)
          : cellB.localeCompare(cellA);
      });

      tbody.innerHTML = "";
      rows.forEach((row) => tbody.appendChild(row));
    });
  });
});
</script>


<!-- Sorting script (already present) -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const table = document.getElementById("order-listing");
  if (!table) return;
  const headers = table.querySelectorAll("thead th");
  const tbody = table.querySelector("tbody");
  let sortDirection = {};

  headers.forEach((header, index) => {
    header.style.cursor = "pointer";
    header.addEventListener("click", function () {
      const rows = Array.from(tbody.querySelectorAll("tr"));
      const dir = sortDirection[index] === "asc" ? "desc" : "asc";
      sortDirection[index] = dir;

      rows.sort((a, b) => {
        const cellA = a.children[index]?.textContent.trim() || "";
        const cellB = b.children[index]?.textContent.trim() || "";
        // Try numeric sort, fallback to string
        const numA = parseFloat(cellA.replace(/,/g, ""));
        const numB = parseFloat(cellB.replace(/,/g, ""));
        if (!isNaN(numA) && !isNaN(numB)) {
          return dir === "asc" ? numA - numB : numB - numA;
        }
        return dir === "asc"
          ? cellA.localeCompare(cellB)
          : cellB.localeCompare(cellA);
      });

      tbody.innerHTML = "";
      rows.forEach((row) => tbody.appendChild(row));
    });
  });
});
</script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  let openTooltip = null;

  document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let lotId = null; 
    let batchId = null;
    if (row) {
      lotId = row.getAttribute('data-lot-id');
      batchId = row.getAttribute('data-batch-id');
    }
    // Build the URL with lot_id and batch_id if found
    let url = "/adminportal/rec_dp_visualaid/";
    if (lotId) {
      url += encodeURIComponent(lotId) + "/";
    }
    if (batchId) {
      url += "?batch_id=" + encodeURIComponent(batchId);
    }
    window.location.href = url;
  });
});
  


  // Tooltip show/hide logic
  document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
    const tooltip = trigger.querySelector(".model-image-tooltip");

    trigger.addEventListener("mouseenter", function () {
      if (tooltip) tooltip.style.display = "block";
    });

    trigger.addEventListener("mouseleave", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.display = "none";
      }
    });

    trigger.addEventListener("click", function (e) {
      e.stopPropagation();

      if (tooltip) {
        document.querySelectorAll(".model-image-tooltip.pinned").forEach((tt) => {
          tt.classList.remove("pinned");
          tt.style.display = "none";
        });

        tooltip.classList.add("pinned");
        tooltip.style.display = "block";
        openTooltip = tooltip;
      }
    });
  });

  document.addEventListener("click", function () {
    if (openTooltip) {
      openTooltip.classList.remove("pinned");
      openTooltip.style.display = "none";
      openTooltip = null;
    }
  });

  document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
    tooltip.addEventListener("click", function (e) {
      e.stopPropagation();
    });
  });
});
</script>

<!-- Script for restrict multiple actions when any modal is open -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function isAnyModalOpen() {
    // Check for any open modal by class or style
    return (
      document.querySelector('.tray-scan-modal.open, .tray-scan-modal-DayPlanning.open, #holdRemarkModal[style*="display: flex"], #holdRemarkModal[style*="display: block"]')
    );
  }

  // Only restrict actions on the main table and page, NOT inside modals
  document.body.addEventListener('click', function(e) {
    if (isAnyModalOpen()) {
      // If the click is inside any open modal, allow it
      if (
        e.target.closest('.tray-scan-modal.open') ||
        e.target.closest('.tray-scan-modal-DayPlanning.open') ||
        e.target.closest('#holdRemarkModal[style*="display: flex"]') ||
        e.target.closest('#holdRemarkModal[style*="display: block"]')
      ) {
        return; // Allow all actions inside the modal
      }
      // Block Tray Scan, View, Edit, Delete on the main screen only
      if (
        e.target.closest('.tray-scan-btn') ||
        e.target.closest('.tray-scan-btn-Jig') ||
        e.target.closest('.edit-qty-btn') ||
        (e.target.closest('a[title="Delete"]')) ||
        (e.target.cxlosest('img[alt="Edit"]')) ||
        (e.target.closest('img[alt="Delete"]')) ||
        (e.target.closest('img[alt="View"]'))
      ) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }
    }
  }, true);

  // Prevent table scroll when any modal is open (but allow scroll inside modal)
  const tableWrapper = document.querySelector('.table-responsive');
  let lastScrollLeft = 0;
  function updateTableScrollLock() {
    if (!tableWrapper) return;
    if (isAnyModalOpen()) {
      tableWrapper.style.overflow = "hidden";
      tableWrapper.style.pointerEvents = "none";
      tableWrapper.scrollLeft = lastScrollLeft;
    } else {
      tableWrapper.style.overflow = "auto";
      tableWrapper.style.pointerEvents = "";
    }
  }
  if (tableWrapper) {
    tableWrapper.addEventListener('scroll', function () {
      if (isAnyModalOpen()) {
        tableWrapper.scrollLeft = lastScrollLeft;
      } else {
        lastScrollLeft = tableWrapper.scrollLeft;
      }
    });
  }
  // Observe modal open/close
  const observer = new MutationObserver(updateTableScrollLock);
  observer.observe(document.body, { attributes: true, childList: true, subtree: true });
  // Also check on modal open/close events
  document.body.addEventListener("click", function () {
    setTimeout(updateTableScrollLock, 100);
  }, true);
  // Prevent table scroll when any modal is open (but allow scroll inside modal)
  const tableWrapper = document.querySelector('.table-responsive');
  let lastScrollLeft = 0;
  function updateTableScrollLock() {
    if (!tableWrapper) return;
    if (isAnyModalOpen()) {
      tableWrapper.style.overflow = "hidden";
      tableWrapper.style.pointerEvents = "none";
      tableWrapper.scrollLeft = lastScrollLeft;
    } else {
      tableWrapper.style.overflow = "auto";
      tableWrapper.style.pointerEvents = "";
    }
  }
  if (tableWrapper) {
    tableWrapper.addEventListener('scroll', function () {
      if (isAnyModalOpen()) {
        tableWrapper.scrollLeft = lastScrollLeft;
      } else {
        lastScrollLeft = tableWrapper.scrollLeft;
      }
    });
  }
  // Observe modal open/close
  const observer = new MutationObserver(updateTableScrollLock);
  observer.observe(document.body, { attributes: true, childList: true, subtree: true });
  // Also check on modal open/close events
  document.body.addEventListener("click", function () {
    setTimeout(updateTableScrollLock, 100);
  }, true);
  // Initial check
  updateTableScrollLock();
});
</script>

<!-- // Parent action lock when modal is open: only allow scrolling and Eye icon (view) -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  // Utility: Returns true if any tray scan modal is open
  function isTrayScanModalOpen() {
    const modal = document.getElementById("trayScanModal");
    return modal && modal.classList.contains("open");
  }

  // Disable all parent actions except Eye/View icon
  function lockParentActions() {
    // Disable all .edit-qty-btn, [title="Delete"], .hold-toggle-btn, .tray-scan-btn, .remark-tooltip-trigger, etc.
    document.querySelectorAll(
      '.edit-qty-btn, a[title="Delete"], .hold-toggle-btn, .tray-scan-btn, .remark-tooltip-trigger'
    ).forEach(function (el) {
      // Skip Eye/View icon triggers (hold-remark-icon and view2.png)
      if (
        el.classList.contains("hold-remark-icon") ||
        (el.querySelector('img[alt="Remark"]') || el.querySelector('img[alt="View Reason"]'))
      ) {
        el.style.pointerEvents = "auto";
        el.style.opacity = "1";
        return;
      }
      el.setAttribute("data-parent-locked", "1");
      el.style.pointerEvents = "none";
      el.style.opacity = "0.5";
      el.style.cursor = "not-allowed";
      // For input[type=checkbox] (hold-toggle-btn)
      if (el.tagName === "INPUT" && el.type === "checkbox") {
        el.disabled = true;
      }
    });
    // Optionally, add a semi-transparent overlay to block accidental clicks (not blocking scroll)
    if (!document.getElementById("parent-action-lock-overlay")) {
      const overlay = document.createElement("div");
      overlay.id = "parent-action-lock-overlay";
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100vw";
      overlay.style.height = "100vh";
      overlay.style.zIndex = "9999";
      overlay.style.background = "transparent";
      overlay.style.pointerEvents = "none"; // allow scroll
      document.body.appendChild(overlay);
    }
  }

  // Restore all parent actions
  function unlockParentActions() {
    document.querySelectorAll('[data-parent-locked="1"]').forEach(function (el) {
      el.style.pointerEvents = "";
      el.style.opacity = "";
      el.style.cursor = "";
      el.removeAttribute("data-parent-locked");
      if (el.tagName === "INPUT" && el.type === "checkbox") {
        el.disabled = false;
      }
    });
    const overlay = document.getElementById("parent-action-lock-overlay");
    if (overlay) overlay.remove();
  }

  // When modal opens, lock parent actions
  const trayScanModal = document.getElementById("trayScanModal");
  if (trayScanModal) {
    // Listen for class changes (modal open/close)
    const observer = new MutationObserver(function () {
      if (isTrayScanModalOpen()) {
        lockParentActions();
      } else {
        unlockParentActions();
      }
    });
    observer.observe(trayScanModal, { attributes: true, attributeFilter: ["class"] });
  }

  // Also lock immediately if modal is already open (on reload)
  if (isTrayScanModalOpen()) lockParentActions();

  // Defensive: unlock on page unload
  window.addEventListener("beforeunload", unlockParentActions);
});
</script>

  {% endblock %} {% endblock content %}
</div>
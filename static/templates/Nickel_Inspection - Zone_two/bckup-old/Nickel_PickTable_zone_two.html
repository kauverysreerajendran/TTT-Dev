{% extends "base.html" %} {% load static %} {% block content %}
{% load stock_filters %} 

<style>
/* ========== Tablet override — paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */
@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }
.rounded-circle{
  padding: 17px !important;
}
.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn,
  #trayScanModal_DayPlanning input.form-control,#trayValidateBtn,
  #trayScanModal_DayPlanning table th, #trayScanModal_DayPlanning table td,
  #modalModelNo_DayPlanning
 {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(5)  { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 115px !important; max-width: 125px !important; }
  #order-listing th:nth-child(8)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(11) { min-width: 120px !important; max-width: 130px !important; }
  #order-listing th:nth-child(12) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(13) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(14) { min-width: 120px !important; max-width: 140px !important; }
  #order-listing th:nth-child(15) { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(16) { min-width: 130px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(18) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(19) { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(20) { min-width: 130px !important; max-width: 130px !important; }


  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
}
/* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
  border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 85px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 110px;
  max-width: 110px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 105px;
  max-width: 105px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 80px;
  max-width: 80px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 90px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 100px;
  max-width: 100px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(18) {
  min-width: 110px;
  max-width: 110px;
}

@media (min-width: 600px) and (max-width: 900px) {
  #order-listing {
    table-layout: auto !important; /* Let columns auto-fit content */
    width: 100% !important;
    min-width: unset !important;
    max-width: 100vw !important;
  }
  /* Adjust width for all headings (th) and cells (td) */
  #order-listing th,
  #order-listing td {
    min-width: 160px !important;
    max-width: 260px !important;
    width: 180px !important;
  }
  #order-listing th {
    position: relative;
    padding-right: 48px !important; /* More space for filter icon */
    white-space: normal !important;
    overflow: visible !important;
    text-overflow: ellipsis;
  }
  #order-listing th .fa-filter {
    position: absolute;
    right: 18px !important;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
    background: transparent;
    pointer-events: auto;
  }
}
/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}

/* ...existing code... */

/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 94px 175px 150px !important;
  gap: 0px !important;
  max-height: 300px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding-right: 10px;
  margin-top: 10px;
  border: 1px solid #ddd;
}

#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* For the 4-column layout (with validation status) */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 50px 1fr 100px 140px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
 
/* Styling individual grid cells, only inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #f7f7f7;
  padding: 8px 12px;
  font-size: 12px;
  border: 1px solid #ddd;
  margin: 0; /* reset any margin from <p> or others */
}
 
/* S.no column specific styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 600;
  padding: 8px 4px; /* Reduced horizontal padding for S.no */
}
 
/* For mobile responsiveness */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 80px 100px !important;
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 2px; /* Further reduced padding on mobile */
    font-size: 11px;
  }
}
 
/* For very small screens */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 30px 1fr 70px 90px !important;
  }
}
</style>

<div class="content-wrapper">

  <div class="row">
    <div class="col-12 grid-margin stretch-card">
      <div class="card">
        <div class="card-body" style="padding-bottom:12px;">
          <h5 class="text-left mt-0 mb-4" style="font-weight:700;">Nickel Wiping Pick Table Zone II</h5>
          
            <!-- Table Section -->
            <div class="table-responsive">
              <table id="order-listing" class="table">
                <thead>
                  <tr>
                    <th>
                      S.No <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Last<br>Updated
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating <br>Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polishing Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating Color
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <!--<th>
                      Category
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>-->
                    <th>
                      Polish Finish
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th style="display:none;">
                      Version <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                     <th>
                      Tray Cate- <br> Capacity
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Input Source
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      No of Trays <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Physical Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                      </th>
                    <th>
                      Accept <br> Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                      </th>
                    <th>
                      Reject Qty<i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Process Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Action <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th style="cursor: pointer;min-width: 95px;max-width: 95px;">
                      Current <br> Stage
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                   
                  </tr>
                </thead>
                <tbody>
                  <!-- Row 1 - Highlighted -->
                   {% for data in master_data %}
                  <tr class="highlighted-tray-scan" 
                      data-stock-lot-id="{{ data.lot_id }}"
                      data-model-no="{{ data.plating_stk_no }}"
                      data-available-qty="{{ data.available_qty }}" 
                      data-brass-onhold-picking="{{ data.nq_onhold_picking }}"
                      data-brass-batch-rejection="{{ data.nq_qc_rejection|yesno:'True,False' }}"
                      data-brass-qc-accptance="{{ data.nq_qc_accptance|yesno:'True,False' }}"
                      data-brass-qc-rejection="{{ data.nq_qc_rejection|yesno:'True,False' }}"
                      data-brass-qc-few-cases-accptance="{{ data.nq_qc_few_cases_accptance|yesno:'True,False' }}"
                      data-accepted-ip-stock="{{ data.accepted_Ip_stock|yesno:'True,False' }}"
                      data-rejected-ip-stock="{{ data.rejected_ip_stock|yesno:'True,False' }}"
                      data-few-cases-accepted-ip-stock="{{ data.few_cases_accepted_Ip_stock|yesno:'True,False' }}"
                      data-brass-physical-qty="{{ data.nq_physical_qty|default:0 }}"
                      data-brass-missing-qty="{{ data.nq_missing_qty|default:0 }}"
                      data-brass-qc-accepted-qty-verified="{{ data.nq_qc_accepted_qty_verified|yesno:'True,False' }}">
                      <td {% if data.nq_hold_lot %} class="row-inactive-blur"{% endif %}>
                    <span style="display:flex; align-items:center; gap:3px;">
                      {% if is_admin %}
                        <!-- Admin users: Show toggle switch -->
                        <label class="hold-toggle-switch" style="margin-bottom:0;">
                          {% if not data.nq_hold_lot %}
                            <input type="checkbox" class="hold-toggle-btn" checked />
                            <span class="hold-slider"></span>
                          {% else %}
                            <input type="checkbox" class="hold-toggle-btn" />
                            <span class="hold-slider"></span>
                          {% endif %}
                        </label>
                        <!-- Hold remark icon -->
                        <span class="hold-remark-icon" 
                              style="display:{% if data.nq_hold_lot or data.nq_release_lot or data.nq_holding_reason or data.nq_release_reason %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
                              title="{% if data.nq_holding_reason %}Holding Reason: {{ data.nq_holding_reason }}{% endif %}{% if data.nq_holding_reason and data.nq_release_reason %}&#10;{% endif %}{% if data.nq_release_reason %}Release Reason: {{ data.nq_release_reason }}{% endif %}">
                          {% if data.nq_hold_lot or data.nq_release_lot or data.nq_holding_reason or data.nq_release_reason %}
                            <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
                          {% endif %}
                        </span>
                      {% else %}
                        <!-- Non-admin: Only show view icon if there's a holding/release reason -->
                        {% if data.nq_hold_lot or data.nq_release_lot or data.nq_holding_reason or data.nq_release_reason %}
                          <span class="hold-remark-icon" 
                                style="display:inline-block; cursor:pointer;" 
                                title="{% if data.nq_holding_reason %}Holding Reason: {{ data.nq_holding_reason }}{% endif %}{% if data.nq_holding_reason and data.nq_release_reason %}&#10;{% endif %}{% if data.nq_release_reason %}Release Reason: {{ data.nq_release_reason }}{% endif %}">
                            <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
                          </span>
                        {% endif %}
                      {% endif %}
                      <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>
                    </span>
                    {% if data.send_to_nickel_brass %}
                      <i class="fa fa-times-circle" style="color: #028084; font-size:13px;" data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Audit"></i>
                      {% endif %}
                  </td>                     
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %} style="white-space:normal;word-break:break-all;">
                      {% if data.send_to_nickel_brass %}
                        {{ data.na_last_process_date_time|date:"d-M-y" }}<br>
                        <span style="display:inline-block; margin-top:4px;word-break: break-all;">
                          {{ data.na_last_process_date_time|date:"h:i A" }}
                        </span>
                      {% else %}
                        {{ data.last_process_date_time|date:"d-M-y" }}<br>
                        <span style="display:inline-block; margin-top:4px;word-break: break-all;">
                          {{ data.last_process_date_time|date:"h:i A" }}
                        </span>
                      {% endif %}
                    </td>
        <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
                        {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                        <div class="model-image-tooltip" style="position: absolute; left: 80%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s; min-width: 220px;">
                          
                          <!-- Header with Info and Close buttons -->
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <button class="info-btn" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Info
                            </button>
                            <button class="close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Close
                            </button>
                          </div>
                          
                          <!-- Image gallery section -->
                          <div style="display: flex; align-items: center; gap: 8px;">
                            <!-- Hide scroll buttons since only one image is shown -->
                            <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                              <img src="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                            </div>
                          </div>
                        </div>
                      </span>
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}</td>

                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                    <!--<td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.category }}</td>-->
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.polish_finish}}</td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %} style="display:none">{{data.version__version_name}}</td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.tray_type}}-{{data.tray_capacity}}</td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.location__location_name}}</td>
                    
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.no_of_trays}}</td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="lot-qty" style="min-width: 30px; text-align: right">{{ data.display_accepted_qty }}</span>
                      <span style="display: inline-flex; align-items: center; gap: 4px;">
                        {% if not data.nq_qc_accepted_qty_verified %}
                          <!-- Show checkbox before save -->
                          <input type="checkbox"
                            class="brass-checkbox"
                            data-lot-id="{{ data.stock_lot_id }}"
                            style="width: 15px; height: 15px"
                            {% if data.nq_qc_accepted_qty_verified %}checked disabled{% endif %} />
                          {% else %}
                          <!-- Show green tick after save -->
                          <span style="
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            width: 19px;
                            height: 19px;
                            border-radius: 50%;
                            background: #0c8249;
                            color: white;
                            font-size: 14px;
                            font-weight: bold;
                            margin-left: 2px;
                          ">
                            &#10003;
                          </span>
                        {% endif %}
                        <input type="text"
                          class="missing-qty-input"
                          value="{{ data.nq_missing_qty|default_if_none:'' }}"
                          style="width: 36px; padding: 1px 3px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;"
                          {% if data.nq_qc_accepted_qty_verified %}disabled{% endif %} />
                      </span>
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{ data.nq_physical_qty|default:0 }}
                    </td>

                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{ data.nq_qc_accepted_qty|default:0 }}    
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{ data.brass_rejection_total_qty|default:0 }}
                    </td>
                    <!-- Process Status Column -->
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="d-flex">
                        <!-- Q: Green if nq_qc_accepted_qty_verified, else gray -->
                        <div
                          title="Tray Scan"
                          class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                          style="
                            width: 25px;
                            height: 25px;
                            background-color: {% if data.nq_qc_accepted_qty_verified %}#0c8249{% else %}#bdbdbd{% endif %};
                            color: white;
                            font-weight: bold;
                            line-height: 20px;
                            text-align: center;
                            padding-top: 1px;
                            padding-right: 1px;
                          "
                        >
                          Q
                        </div>
                        <!-- QC: Green if nq_qc_rejection or nq_qc_accptance, else gray -->
                        <div
                          title="Tray Scan"
                          class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                          style="
                            width: 25px;
                            height: 25px;
                            background:
                              {% if data.nq_onhold_picking or data.nq_draft %}
                                linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% elif data.nq_qc_rejection or data.nq_qc_accptance or data.nq_qc_few_cases_accptance %}
                                #0c8249;
                              {% else %}
                                #bdbdbd;
                              {% endif %}
                            color: white;
                            font-weight: bold;
                            line-height: 20px;
                            text-align: center;
                            padding-top: 1px;
                            padding-right: 1px;
                          "
                        >
                          QC
                        </div>
                      </div>
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                      
                      {% if not data.nq_qc_accptance and not data.nq_qc_rejection and not data.nq_accepted_tray_scan_status and not data.nq_qc_few_cases_accptance and data.nq_qc_accepted_qty_verified %}                       

                      <a href="#" class="delete-batch-btn" title="Delete" data-batch-id="{{ data.batch_id }}" data-stock-lot-id="{{ data.lot_id }}">
                        <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
                      </a>
                      {% else %}

                        <span title="Delete Disabled" style="opacity: 0.5; pointer-events: none;">
                          <img src="{% static 'assets/icons/bin.png' %}" alt="Delete Disabled" style="width: 20px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5);" />
                        </span>
                      {% endif %}
                      {% if data.iqf_acceptance %}
                        <!-- IQF Acceptance - Show buttons as ACTIVE/CLICKABLE -->
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #66bb6a;"
                                data-lot-id="{{ data.stock_lot_id }}"
                          {% if not data.nq_qc_accepted_qty_verified %}disabled{% endif %}>
                          <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                style="background-color: #e57373;"
                                data-stock-lot-id="{{ data.lot_id }}"
                                data-batch-id="{{ data.batch_id }}">
                          <i class="fa fa-times-circle"></i>Reject
                        </button>
                        {% elif data.nq_onhold_picking %}
                          <!-- Brass Draft Picking -->
                          <button type="button" class="btn btn-social-icon-text btn-twitter"
                                  style="background-color: #66bb6a; opacity: 0.6; cursor: not-allowed; pointer-events: none;"
                                  data-lot-id="{{ data.stock_lot_id }}"
                                  disabled>
                            <i class="fa fa-check-circle"></i>Accept
                          </button>
                          <!-- ✅ UPDATED: Conditional button text and styling -->
                        {% if data.nq_onhold_picking %}
                          {% if data.is_delink_only %}
                            <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                    style="background-color: #e57373;"
                                    data-stock-lot-id="{{ data.lot_id }}"
                                    data-batch-id="{{ data.batch_id }}"
                                    data-is-delink-only="false">
                              <i class="fa fa-times-circle"></i>Set Delink
                            </button>
                          {% else %}
                            <!-- Normal case: Some pieces available for top tray -->
                            <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                    style="background-color: #e57373;"
                                    data-stock-lot-id="{{ data.lot_id }}"
                                    data-batch-id="{{ data.batch_id }}"
                                    data-is-delink-only="false">
                              <i class="fa fa-times-circle"></i>Set Top Tray
                            </button>
                          {% endif %}
                        {% endif %}

                      {% elif data.send_to_nickel_ip %}
                        <!-- Brass QC Acceptance (disabled) -->
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #66bb6a;"
                                data-lot-id="{{ data.stock_lot_id }}"
                          {% if not data.nq_qc_accepted_qty_verified %}disabled{% endif %}>
                          <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                style="background-color: #e57373;"
                                data-stock-lot-id="{{ data.lot_id }}"
                                data-batch-id="{{ data.batch_id }}"
                                {% if not data.nq_qc_accepted_qty_verified %}disabled{% endif %}>
                          <i class="fa fa-times-circle"></i>Reject
                        </button>

                      {% elif data.nq_onhold_picking %}
                        <!-- Brass Draft Picking -->
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #66bb6a; opacity: 0.6; cursor: not-allowed; pointer-events: none;"
                                data-lot-id="{{ data.stock_lot_id }}"
                                disabled>
                          <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                style="background-color: #e57373;"
                                data-stock-lot-id="{{ data.lot_id }}"
                                data-batch-id="{{ data.batch_id }}">
                          <i class="fa fa-times-circle"></i> Reject
                        </button>

                      {% elif data.nq_qc_rejection or data.nq_qc_few_cases_accptance %}
                        <!-- Brass QC Rejection or Few Cases Acceptance (disabled) -->
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #66bb6a; pointer-events: none; opacity: 0.6; cursor: not-allowed;"
                                disabled>
                          <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <span class="btn btn-social-icon-text btn-youtube"
                              style="background-color: #e57373; pointer-events: none; opacity: 0.8; cursor: not-allowed;">
                          <i class="fa fa-times-circle"></i>Rejected
                        </span>

                      {% else %}
                        <!-- Default state - Both buttons enabled -->
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #66bb6a"
                                data-lot-id="{{ data.lot_id }}"
                                {% if not data.nq_qc_accepted_qty_verified %}disabled{% endif %}>
                          <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                style="background-color: #e57373;"
                                data-stock-lot-id="{{ data.lot_id }}"
                                data-batch-id="{{ data.batch_id }}"
                                {% if not data.nq_qc_accepted_qty_verified %}disabled{% endif %}>
                          <i class="fa fa-times-circle"></i>Reject
                        </button>
                      {% endif %}
                      <!-- Eye icon to view submitted "Tray Scan Table" -->
                          <a href="#"
                          title="View"
                          class="text-primary tray-scan-btn-BQ-view tray-scan-btn-Jig"
                          style="text-decoration: underline"
                          data-stock-lot-id="{{ data.lot_id }}"
                          data-batch-id="{{ data.batch_id }}"
                          data-model-no="{{ data.plating_stk_no }}"
                          data-no-of-trays="{{ data.no_of_trays }}"
                          data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
                          data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
                          data-model-image="{{ data.model_images.0|default:'' }}"
                          data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
                            data-total-batch-quantity="{{ data.display_accepted_qty|default:0 }}"
                            data-brass-missing-qty="{{ data.nq_missing_qty|default:0 }}">

                          <img src="{% static 'assets/icons/view.png' %}"
                              alt="View"
                              style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;" />
                        </a>
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                      {% if data.nq_onhold_picking or data.nq_draft or data.nq_qc_accepted_qty_verified %}
                        <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 1px solid #4997ac;
                            background-color: #d1f2f3;
                            color: #03425d;
                            font-size: clamp(0.75rem, 2vw, 0.875rem);
                            white-space: nowrap;
                            padding: 5px;
                          "
                        >
                          Draft
                        </div>
                      {% elif data.nq_hold_lot %}
                       <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 1px solid #dc3545;
                            background-color: #f8d7da;
                            color: #721c24;
                            font-size: 13px;
                            white-space: nowrap;
                            padding: 5px;
                          "
                        >
                          On Hold
                        </div>

                      {% elif data.nq_qc_rejection or data.nq_qc_few_cases_accptance or data.nq_qc_accptance %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                            style="border: 1px solid #0d5d17; background-color: #c5f9c2; color: #2f801b; font-size: 13px; white-space: nowrap; padding: 5px;">
                          Yet to Release
                        </div>
                      
                      {% else %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                            style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size:13px; white-space: nowrap; padding: 5px;">
                          Yet to Start
                        </div>
                      {% endif %}
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #d1edf3; background-color: #d1edf3; color: #033b5d; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                    </td>
                    <td {% if data.nq_hold_lot %} class="row-inactive-blur" {% endif %}>

                      <!-- VoiceRec with tooltip (audio remark) -->
                          <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                            <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                            <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
                              <!-- Audio recording UI placeholder -->
                              <div style="display: flex; align-items: center; gap: 10px;">
                                <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                                  <i class="fa fa-microphone"></i>
                                </button>
                                <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                                  <div style="text-align: right; margin-top: 10px;">
                                <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                  <i class="fa fa-send"></i>
                                </button>
                              </div>
                              </div>
                            
                            </div>
                          </a>
                          <a
                              href="#"
                              title="Add Remark"
                              class="remark-tooltip-trigger"
                              data-jig-lot-id="{{ jig_detail.jig_lot_id }}"
                              style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; position: relative; cursor: pointer;"
                            >
                              <img
                                src="{% static 'assets/icons/chat_icon.png' %}"
                                alt="Chat"
                                style="width: 20px; height: 20px; {% if data.nq_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% endif %}"
                              />
                              <div
                                class="remark-tooltip"
                                style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 300px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                              >
                                <textarea
                                  placeholder="Type your remark..."
                                  style="width: 85%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                                  {% if data.nq_pick_remarks %}readonly{% endif %}
                                >{{ data.nq_pick_remarks|default_if_none:"" }}</textarea>
                                <div style="text-align: right; margin-top: -35px">
                                  {% if not data.nq_pick_remarks %}
                                  <button
                                    type="button"
                                    style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                  >
                                    <i class="fa fa-send"></i>
                                  </button>
                                  {% else %}
                                  <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                                    <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                                    Remark already saved and cannot be edited.
                                  </div>
                                  {% endif %}
                                </div>
                              </div>
                          </a>
                 
                    </td>
                   
                  </tr>
                  {% endfor%}
              
                </tbody>
              </table>


                                    <div
  id="trayScanModal_DayPlanning"
  class="tray-scan-modal-DayPlanning"
  style="display:none"
>
  <div class="tray-scan-modal-DayPlanning-content">
    <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly">&times;</span>
    
    <div class="modal-top-header" style="display: flex; align-items: center; gap: 20px; padding-bottom: 10px;">
      <div class="user-profile" style="display: flex; align-items: center; gap: 8px">
        <div id="modalModelImages_DayPlanning" style="display: flex; gap: 6px;">
            <!-- Model images will be injected here by JS -->
            <img id="modalUserImg_DayPlanning" src="{% static 'assets/images/imagePlaceholder.png' %}" alt="Model Image" style="border-radius: 50%; width: 50px; height: 50px; object-fit: cover;" />
          </div>  
        <!-- Model No and Lot Qty in same line -->
        <div style="display: flex; flex-direction: column; gap: 2px;">
          <div style="display: flex; align-items: center; gap: 15px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-weight: bold; color: #666;">Model No:</span>
              <h6 id="modalModelNo_DayPlanning" style="margin: 0; color: #028084; font-weight: bold;">(Fetch Dynamically)</h6>
            </div>

          </div>
                      <p style="margin: 0 0 0 2px;">
              Lot Qty: <span id="modalLotQty" style="font-weight:bold; color:#e67e22;"></span> /
              Missing Qty: <span id="modalMissingQty" style="font-weight:bold; color:#d32f2f;"></span> /
              Physical Qty: <span id="modalPhysicalQty" style="font-weight:bold; color:#388e3c;"></span>
            </p>
        </div>
      </div>
    </div>
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
      <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
        Nickel QC - Tray Scan 
      </h5>
      <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
        Tray Validate
      </button>
      <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
      <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="trayScanRedoBtn" style="width: 24px; height: 24px; cursor: pointer; margin-left: 8px;" title="Clear Tray IDs" />
    </div>
    <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
      <span id="trayErrorText"></span>
    </div>
    <div id="trayScanDetails_DayPlanning" class="table-grid">
      <!-- Headers and dynamic content will be injected here -->
    </div>
  </div>
</div>
              <!-- Tray Scan Details Modal (Left Popup) -->
              <div id="trayScanModal" class="tray-scan-modal">
                <div class="tray-scan-modal-content">
                  <span id="closeTrayScanModal" class="tray-scan-close"
                    >&times;</span
                  >
                  <h3>
                    Nickel QC / <span id="trayScanModalHeaderModelNo" style="font-weight:bold; color:#028084;"></span> / Rejection Window
                  </h3>
                  <p style="margin: 0 0 0 2px;">
                    Lot Qty: <span id="trayScanModalLotQty" style="font-weight:bold; color:#e67e22;"></span> /
                    Missing Qty: <span id="trayScanModalMissingQty" style="font-weight:bold; color:#d32f2f;"></span> /
                    Physical Qty: <span id="trayScanModalPhysicalQty" style="font-weight:bold; color:#388e3c;"></span>
                  </p>       
                             <div id="trayScanDetails">
                    <!-- Dynamic content will be loaded here -->
                  </div>
                </div>
              </div>
              <!-- New Popup Modal (Right Popup) -->
              <div id="newPopupModal" class="new-popup-modal">
                <div class="tray-scan-modal-content">
                  <span id="closeNewPopupModal" class="tray-scan-close"
                    >&times;</span
                  >
                  <!-- New top header container: title + user profile aligned left -->
                  <div
                    class="modal-top-header"
                    style="
                      display: flex;
                      align-items: center;
                      gap: 20px;
                      padding-bottom: 10px;
                    "
                  >
                  
                  </div>
                  <!-- Existing centered h3 title -->
                  <!-- Redo icon for clearing "tray ID" -->
                 <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                    <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                      Nickel QC - Accepted case tray scan table
                    </h5>
                    <img
                      src="{% static 'assets/icons/redo2.png' %}"
                      alt="Redo"
                      id="trayScanRedoBtn"
                      style="width: 24px; height: 24px; cursor: pointer; margin-right: 14px;"
                      title="Clear Tray IDs"
                    />
                  </div>
                  <!-- Accepted Case Tray Scan Table - Grid View with Visible Borders -->
                  <div id="trayScanDetails" class="table-grid">

                    <!-- NEW BUTTONS SECTION -->
                    <div class="tray-scan-modal-buttons" style="grid-column: 1 / -1; display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                       <button
                    style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                    Draft
                  </button>
                  <button
                    style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                    Submit
                  </button>
                  <button
                    style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
                    Cancel
                  </button>
                    </div>
                  </div>
                </div>
              </div>
              
            </div>
            
           
          
         <!-- Pagination Section -->

            <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Image Slider Modal (popup) -->
  <div id="imageSliderModal" class="image-slider-modal">
    <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
    <h3>Visual Aid</h3>
    <div class="slider" id="slider">
      <div class="slides" id="slidesContainer">
        <div class="slide active">
          <img src="{% static 'assets/images/carousel/banner_1.jpg' %}" alt="Slide 1">
        </div>
        <div class="slide">
          <img src="{% static 'assets/images/carousel/banner_2.jpg' %}" alt="Slide 2">
        </div>
        <div class="slide">
          <img src="{% static 'assets/images/carousel/banner_3.jpg' %}" alt="Slide 3">
        </div>
      </div>
      <button class="prev" id="prevBtn">&#10094;</button>
      <button class="next" id="nextBtn">&#10095;</button>
    </div>
  </div>
  <!-- Image Slider Modal -->
  <div id="imageSliderModal" class="image-slider-modal">
    <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
    <div class="slider" id="slider">
      <button class="prev" id="prevBtn">&#8592;</button>
      <div class="slides"></div>
      <button class="next" id="nextBtn">&#8594;</button>
    </div>
  </div>

  <!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
  <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
    <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
    <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
    <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
    <div style="text-align:right; margin-top:10px;">
      <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
    </div>
    <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
  </div>
</div>
</div>
       
  {% block script %}

    <script nonce="{{ csp_nonce }}">
  document.addEventListener("DOMContentLoaded", function () {
    document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        const batchId = btn.getAttribute('data-batch-id');
        const lotId = btn.getAttribute('data-stock-lot-id');
        if (!batchId || !lotId) {
          Swal.fire('Error', 'Batch ID or Lot ID not found.', 'error');
          return;
        }
        Swal.fire({
          title: 'Are you sure?',
          text: 'This will delete the batch. This action cannot be undone.',
          icon: 'warning',
          showCancelButton: true,
          confirmButtonColor: '#dc3545',
          cancelButtonColor: '#6c757d',
          confirmButtonText: 'Yes, Delete',
          cancelButtonText: 'Cancel'
        }).then((result) => {
          if (result.isConfirmed) {
            fetch('/nickle_inspection_zone_two/nq_zone_delete_batch/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                batch_id: batchId,
                lot_id: lotId
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire('Deleted!', 'Batch deleted successfully.', 'success');
                setTimeout(() => { window.location.reload(); }, 1000);
              } else {
                Swal.fire('Error', data.error || 'Failed to delete batch.', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error.', 'error');
            });
          }
        });
      });
    });
  
    // Helper for CSRF token
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
  });
  </script>

  <script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (redoBtn && validateInput && detailsDiv) {
    redoBtn.addEventListener("click", function () {
      // Hide and clear the input
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset Tray Validate button to normal state
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }

      // Reset all icons in the validation status column (read-only modal)
      // For table layout:
      const rows = detailsDiv.querySelectorAll("tbody tr");
      if (rows.length > 0) {
        rows.forEach(row => {
          const statusCell = row.querySelector("td:last-child");
          if (statusCell) {
            statusCell.innerHTML = `
              <div class="validation-status">
                <div class="status-icon fail">
                  <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                </div>
                <div class="status-icon pass">
                  <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                </div>
              </div>
            `;
          }
        });
      } else {
        // For grid layout (if used)
        detailsDiv.querySelectorAll('.tray-validation-status-header, .tray-validation-status-cell').forEach(cell => {
          cell.innerHTML = `
            Tray Validation Status
            <span style="margin-left: 10px;">
              <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
            </span>
          `;
        });
      }
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const validateBtn = document.getElementById("trayValidateBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (validateBtn && validateInput) {
    validateBtn.addEventListener("click", function () {
      validateInput.value = "";
      
      // Hide error message when starting new validation
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Change button to active state (green color)
      validateBtn.style.background = "#e8f5e8";
      validateBtn.style.borderColor = "#4caf50";
      validateBtn.style.color = "#2e7d32";
      
      // Add the 4th column to the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table with validation column
        detailsDiv.innerHTML = modal.buildTableHTML(true);
      }
      
      // Focus the hidden input so it can receive keystrokes
      validateInput.focus();
    });
  }
  
  if (redoBtn && validateInput) {
    redoBtn.addEventListener("click", function () {
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset button to normal state (original blue color)
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
      
      // Remove the 4th column from the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table without validation column
        detailsDiv.innerHTML = modal.buildTableHTML(false);
      }
      
      redoBtn.focus();
    });
  }
});
</script>

<!-- ✅ UPDATED: Tray Validation JavaScript with BrassTrayId awareness -->
<script nonce="{{ csp_nonce }}">
// ✅ UPDATED: Tray validation with BrassTrayId awareness and enhanced logging
document.addEventListener("DOMContentLoaded", function () {
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");
  const errorText = document.getElementById("trayErrorText");

  console.log("🔍 [Tray Validation] Script loaded with BrassTrayId awareness");

  function getCurrentBatchId() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.dataset.batchId) return modal.dataset.batchId;
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-batch-id]');
    return lastBtn ? lastBtn.getAttribute('data-batch-id') : '';
  }

  function getBrassQcAcceptedQtyVerifiedFromModal() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.dataset.brassQcAcceptedQtyVerified) {
      return modal.dataset.brassQcAcceptedQtyVerified === 'true';
    }
    return false;
  }

// ✅ COMPLETELY SIMPLIFIED: Only lot_id for all validation
function getValidationConfig() {
  const isVerified = getBrassQcAcceptedQtyVerifiedFromModal();
  
  // Get lot_id from modal context
  const modal = document.getElementById("trayScanModal_DayPlanning");
  const stockLotId = modal?.dataset.stockLotId || getCurrentLotId();
  
  if (isVerified) {
    console.log("✅ [Validation Config] Using AfterCheck validation (BrassTrayId data)");
    console.log(`   AfterCheck Parameters: lot_id=${stockLotId}`);
    
    return {
      endpoint: "/nickle_inspection_zone_two/nq_zone_pick_complete_tray_validate/",
      dataSource: "BrassTrayId",
      params: {
        lot_id: stockLotId
      }
    };
  } else {
    console.log("✅ [Validation Config] Using Pick validation (JigUnload_TrayId data)");
    console.log(`   Pick Parameters: lot_id=${stockLotId}`);
    
    return {
      endpoint: "/nickle_inspection_zone_two/nq_zone_pick_complete_tray_validate/",
      dataSource: "JigUnload_TrayId", 
      params: {
        lot_id: stockLotId
      }
    };
  }
}
function showError(message) {
    console.log("🚨 [Validation Error]", message);
    if (errorMessage && errorText) {
      errorText.textContent = message;
      errorMessage.style.setProperty('display', 'block', 'important');
      errorMessage.style.setProperty('visibility', 'visible', 'important');
      errorMessage.style.setProperty('opacity', '1', 'important');
      errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      setTimeout(() => {
        errorMessage.style.display = "none";
      }, 8000);
    }
  }

  function hideError() {
    if (errorMessage) {
      errorMessage.style.display = "none";
    }
  }

  if (validateInput && detailsDiv) {
// ✅ FIXED: Updated validation function in the keydown event listener
validateInput.addEventListener("keydown", function (e) {
  if (e.key === "Enter") {
    const trayId = validateInput.value.trim();
    
    if (!trayId) {
      return;
    }
    
    // ✅ Get validation configuration with lot_id only
    const validationConfig = getValidationConfig();
    
    // ✅ FIXED: Check for lot_id instead of batch_id
    if (!validationConfig.params.lot_id) {
      showError("Lot ID not found. Please refresh and try again.");
      return;
    }

    hideError();

    // Add tray_id to parameters
    const requestData = {
      ...validationConfig.params,
      tray_id: trayId
    };

    console.log(`🚀 [Single Validation Call] Making request to: ${validationConfig.endpoint}`);
    console.log(`   Data Source: ${validationConfig.dataSource}`);
    console.log(`   Parameters:`, requestData);

    fetch(validationConfig.endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie('csrftoken')
      },
      body: JSON.stringify(requestData)
    })
    .then(res => {
      console.log("📡 [Validation Response] Status:", res.status);
      return res.json();
    })
    .then(data => {
      console.log("📊 [Validation Response] Data:", data);
      
      // Enhanced response logging
      if (data.data_source) {
        console.log(`   Confirmed Data Source: ${data.data_source}`);
      }
      
      const rows = detailsDiv.querySelectorAll("tbody tr");
      let found = false;
      
      rows.forEach((row, index) => {
        const trayIdInput = row.querySelector('input[type="text"]');
        if (trayIdInput) {
          const rowTrayId = trayIdInput.value.trim();
          
          if (rowTrayId === trayId) {
            found = true;
            const statusCell = row.querySelector("td:last-child");
            if (statusCell) {
              if (data.success && data.exists) {
                statusCell.innerHTML = `
                  <div class="validation-status">
                    <div class="status-icon fail inactive">
                      <img src="/static/assets/icons/fail.png" alt="Fail" style="width:18px; height:18px;" />
                    </div>
                    <div class="status-icon pass active">
                      <img src="/static/assets/icons/pass.png" alt="Pass" style="width:18px; height:18px;" />
                    </div>
                  </div>
                `;
                row.style.backgroundColor = '#e8f5e8';
                setTimeout(() => {
                  row.style.backgroundColor = '';
                }, 2000);
                console.log(`✅ [Validation Success] Tray "${trayId}" validated successfully in ${validationConfig.dataSource}`);
              } else {
                statusCell.innerHTML = `
                  <div class="validation-status">
                    <div class="status-icon fail active">
                      <img src="/static/assets/icons/fail.png" alt="Fail" style="width:18px; height:18px;" />
                    </div>
                    <div class="status-icon pass inactive">
                      <img src="/static/assets/icons/pass.png" alt="Pass" style="width:18px; height:18px;" />
                    </div>
                  </div>
                `;
                row.style.backgroundColor = '#ffebee';
                setTimeout(() => {
                  row.style.backgroundColor = '';
                }, 2000);
                console.log(`❌ [Validation Failed] Tray "${trayId}" validation failed in ${validationConfig.dataSource}`);
              }
            }
          }
        }
      });
      
      if (!found) {
        showError(`Tray ID "${trayId}" not found in table (${validationConfig.dataSource}).`);
      }
      
      validateInput.value = "";
      validateInput.focus();
    })
    .catch(error => {
      console.error('❌ [Validation Network Error]', error);
      showError(`Network error occurred while validating the tray ID in ${validationConfig.dataSource}.`);
      validateInput.value = "";
      validateInput.focus();
    });
  }
});
  }
  
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});
</script>

<!-- ✅ FIXED: JavaScript to prevent dual endpoint calls -->
<script nonce="{{ csp_nonce }}">
// Enhanced JavaScript section for modal population with dynamic Lot Qty/Physical Qty
document.addEventListener("DOMContentLoaded", function () {
  document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
    link.addEventListener('click', async function (e) {
      e.preventDefault();

      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
      const modalLotQty = document.getElementById("modalLotQty_DayPlanning");
      const modalQtyLabel = document.getElementById("modalQtyLabel_DayPlanning");

      // Get data attributes
      const batchId = link.getAttribute('data-batch-id');
      const modelNo = link.getAttribute('data-model-no');
      const stockLotId = link.getAttribute('data-stock-lot-id');
      
      // Get the row to access additional data
      const row = link.closest('tr');
      const brassPhysicalQty = row ? row.getAttribute('data-brass-physical-qty') : "0";
      const displayAcceptedQty = link.getAttribute('data-total-batch-quantity') || "0";
      const brassMissingQty = row ? row.getAttribute('data-brass-missing-qty') : "0";
      const brassQcAcceptedQtyVerified = row ? row.getAttribute('data-brass-qc-accepted-qty-verified') === 'True' : false;

      // Enhanced detection with detailed logging
      const checkbox = row ? row.querySelector('.brass-checkbox') : null;
      const actuallyVerified = checkbox ? (checkbox.checked && checkbox.disabled) : false;

      // Use the more reliable checkbox-based detection
      const isVerified = actuallyVerified;

      // Store data in modal
      modal.dataset.batchId = batchId;
      modal.dataset.brassQcAcceptedQtyVerified = isVerified.toString();
      modal.dataset.stockLotId = stockLotId;

      // Set modal content
      if (modalModelNo && modelNo) {
        modalModelNo.textContent = modelNo;
        
      }

            // Set model image
      const modalUserImg = modal.querySelector('.user-profile img');
      const modelImage = link.getAttribute('data-model-image');
      if (modalUserImg) {
        modalUserImg.src = modelImage || "/static/assets/images/imagePlaceholder.png";
      }

      
      // Set dynamic values for Lot Qty, Missing Qty, Physical Qty
      document.getElementById('modalLotQty').textContent = displayAcceptedQty || '';
      document.getElementById('modalMissingQty').textContent = brassMissingQty || '';
      document.getElementById('modalPhysicalQty').textContent = brassPhysicalQty || '';

      // ✅ ENHANCED: Dynamic quantity display based on verification status
      if (modalLotQty && modalQtyLabel) {
        if (isVerified) {
          // Show Physical Qty when verified
          modalQtyLabel.textContent = "Physical Qty:";
          modalLotQty.textContent = brassPhysicalQty; // <-- This should be the correct value
          modalLotQty.style.color = "#28a745";
          console.log(`✅ Showing Physical Qty: ${brassPhysicalQty}`);
        } else {
          // Show Lot Qty when not verified
          modalQtyLabel.textContent = "Lot Qty:";
          modalLotQty.textContent = displayAcceptedQty;
          modalLotQty.style.color = "#e67e22";
          console.log(`✅ Showing Lot Qty: ${displayAcceptedQty}`);
        }
      }



      // Continue with existing endpoint selection logic...
      let trayListEndpoint;
      let apiParams;
      let dataSource;

      if (isVerified) {
        // AFTER CHECK: Use BrassTrayId data with Brass QC parameters
        trayListEndpoint = '/nickle_inspection_zone_two/nq_zone_pick_CompleteTable_tray_id_list/';
        dataSource = 'BrassTrayId';
        
        // Get Brass QC status from row data attributes
        apiParams = {
          lot_id: stockLotId,

        };
        
        console.log(`✅ [AFTER CHECK MODE] Using: ${trayListEndpoint}`);
        console.log(`   Data Source: ${dataSource} (Physical Qty: ${brassPhysicalQty})`);
        console.log(`   Parameters:`, apiParams);
      } else {
        // PICK MODE: Use TrayId data with IP stock parameters  
        trayListEndpoint = '/nickle_inspection_zone_two/nq_zone_pick_CompleteTable_tray_id_list/';
        dataSource = 'TrayId (IPTrayId)';

        apiParams = {
          lot_id: stockLotId,
        };
        
        console.log(`✅ [PICK MODE] Using: ${trayListEndpoint}`);
        console.log(`   Data Source: ${dataSource} (Lot Qty: ${displayAcceptedQty})`);
        console.log(`   Parameters:`, apiParams);  
      }

      // Continue with existing API call and table building logic...
      let traysData = [];
      let rejectionSummary = {};
      
      try {
        const params = new URLSearchParams(apiParams);
        const finalUrl = `${trayListEndpoint}?${params}`;
        
        console.log(`🚀 [SINGLE CALL] Making request to: ${finalUrl}`);
        
        const resp = await fetch(finalUrl);
        const result = await resp.json();
        
        if (result.success) {
          traysData = result.trays || [];
          rejectionSummary = result.rejection_summary || {};
          console.log(`✅ [SUCCESS] Fetched ${traysData.length} trays from ${dataSource}`);
        } else {
          console.error(`❌ [ERROR] API call failed:`, result);
        }
      } catch (e) {
        console.error(`❌ [NETWORK ERROR] Failed to fetch tray data:`, e);
      }

      // Build table HTML (existing function)
      function buildTableHTML(showValidationColumn = false) {
        let html = `
          <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
            <thead>
              <tr>
                <th style="width:50px;">S.no</th>
                <th>Tray ID</th>
                <th>Tray Qty</th>
                ${showValidationColumn ? '<th>Tray Validation Status</th>' : ''}
              </tr>
            </thead>
            <tbody>
        `;
      
        let rowCounter = 1;
      
        if (traysData && traysData.length > 0) {
          const acceptedTrays = traysData;
          
          console.log(`📊 [Table Building] Processing ${traysData.length} total trays, ${acceptedTrays.length} accepted`);
          
          // Find top tray
          const topTray = acceptedTrays.find(tray => {
            return tray.brass_top_tray || tray.ip_top_tray || tray.top_tray;
          });
          
          if (topTray) {
            let displayQuantity = topTray.tray_quantity;
            if (topTray.ip_top_tray_qty !== null && topTray.ip_top_tray_qty !== undefined) {
              displayQuantity = topTray.ip_top_tray_qty;
            } else if (topTray.brass_top_tray_qty !== null && topTray.brass_top_tray_qty !== undefined) {
              displayQuantity = topTray.brass_top_tray_qty;
            }
            
            console.log(`🔝 [Top Tray] Found: ${topTray.tray_id}, Qty: ${displayQuantity}`);
      
            html += `
              <tr class="top-tray-row">
                <td>1 (Top Tray)</td>
                <td>
                  <input type="text" class="form-control" value="${topTray.tray_id || ''}" readonly style="width: 100%;" />
                </td>
                <td>
                  <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
                </td>
                ${showValidationColumn ? `
                  <td>
                    <div class="validation-status">
                      <div class="status-icon fail">
                        <img src="/static/assets/icons/fail.png" alt="Fail" style="width:18px; height:18px;" />
                      </div>
                      <div class="status-icon pass">
                        <img src="/static/assets/icons/pass.png" alt="Pass" style="width:18px; height:18px;" />
                      </div>
                    </div>
                  </td>
                ` : ''}
              </tr>
            `;
            rowCounter = 2;
          }
          
          // Add regular trays
          const regularTrays = acceptedTrays.filter(tray => {
            return !(tray.brass_top_tray || tray.ip_top_tray || tray.top_tray);
          });
          
          regularTrays.sort((a, b) => {
            const trayIdA = a.tray_id || '';
            const trayIdB = b.tray_id || '';
            return trayIdA.localeCompare(trayIdB);
          });
          
          regularTrays.forEach((tray) => {
            let displayQuantity = tray.tray_quantity;
      
            html += `
              <tr>
                <td>${rowCounter}</td>
                <td>
                  <input type="text" class="form-control" value="${tray.tray_id || ''}" readonly style="width: 100%;" />
                </td>
                <td>
                  <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
                </td>
                ${showValidationColumn ? `
                  <td>
                    <div class="validation-status">
                      <div class="status-icon fail">
                        <img src="/static/assets/icons/fail.png" alt="Fail" style="width:18px; height:18px;" />
                      </div>
                      <div class="status-icon pass">
                        <img src="/static/assets/icons/pass.png" alt="Pass" style="width:18px; height:18px;" />
                      </div>
                    </div>
                  </td>
                ` : ''}
              </tr>
            `;
            rowCounter++;
          });
          
          console.log(`📊 [Table Complete] Built table with ${rowCounter - 1} rows from ${dataSource}`);
        }
        
        html += '</tbody></table>';
        return html;
      }

      // Show table 
      detailsDiv.innerHTML = buildTableHTML(false);

      // Store data for later use
      modal.buildTableHTML = buildTableHTML;
      modal.traysData = traysData;
      modal.rejectionSummary = rejectionSummary;

      // Show the modal
      modal.style.display = "block";
      modal.classList.add("open");
      
      console.log(`🎯 [MODAL OPENED] Successfully displayed ${dataSource} data`);
      console.log(`   Quantity Display: ${isVerified ? 'Physical Qty' : 'Lot Qty'} = ${isVerified ? brassPhysicalQty : displayAcceptedQty}`);
    });
  });

  // Close handler (unchanged)
  const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
  if (closeBtn) {
    closeBtn.addEventListener("click", function () {
      const modal = document.getElementById("trayScanModal_DayPlanning");
      if (modal) {
        modal.classList.remove("open");
        modal.style.display = "none";
      }
    });
  }
});


</script>




<script nonce="{{ csp_nonce }}">
// ✅ FIXED: Store state globally so it persists across table refreshes
window.holdToggleState = {
  currentHoldCell: null,
  intendedState: null,
  currentBatchId: null,
  currentLotId: null
};

function attachHoldToggleListeners() {
  console.log('Attaching hold toggle listeners...');

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Remove existing listeners and attach new ones
  document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
    // Remove any existing click listeners
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    
    // Add new event listener
    newBtn.addEventListener('click', function (e) {
      e.preventDefault();
      
      const holdCell = newBtn.closest('td');
      const row = holdCell.closest('tr');
      
      // ✅ Store state globally with all needed data
      window.holdToggleState = {
        currentHoldCell: holdCell,
        intendedState: newBtn.checked,
        currentBatchId: row.getAttribute('data-batch-id'),
        currentLotId: row.getAttribute('data-stock-lot-id'),
        // Store identifiers that can help us find the row after refresh
        rowIdentifier: row.getAttribute('data-stock-lot-id') || row.getAttribute('data-batch-id')
      };
      
      console.log('Hold toggle clicked, state:', window.holdToggleState);
      
      document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
        window.holdToggleState.intendedState ? 'Unholding Reason' : 'Holding Reason';
      document.getElementById('holdRemarkInput').value = '';
      document.getElementById('holdRemarkError').textContent = '';
      document.getElementById('holdRemarkModal').style.display = 'flex';
      document.getElementById('holdRemarkInput').focus();
    });
  });

  // ✅ Attach save button handler (only once globally)
  const saveBtn = document.getElementById('saveHoldRemarkBtn');
  if (saveBtn && !window.holdSaveHandlerAttached) {
    window.holdSaveHandlerAttached = true;
    
    saveBtn.onclick = function () {
      console.log('Save button clicked, current state:', window.holdToggleState);
      
      const remark = document.getElementById('holdRemarkInput').value.trim();
      if (!remark) {
        document.getElementById('holdRemarkError').textContent = 'Remark required!';
        return;
      }
      
      // ✅ Use stored state instead of current variables
      if (!window.holdToggleState.currentLotId) {
        document.getElementById('holdRemarkError').textContent = 'Lot ID not found!';
        return;
      }
    
      const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
      
      console.log('Sending request:', {
        lot_id: window.holdToggleState.currentLotId,
        remark: remark,
        action: action
      });
    
      fetch('/nickle_inspection_zone_two/nq_zone_save_hold_unhold_reason/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          lot_id: window.holdToggleState.currentLotId,
          remark: remark,
          action: action
        })
      })
      .then(res => res.json())
      .then(data => {
        console.log('Server response:', data);
        
        if (data.success) {
          // ✅ Close modal first
          document.getElementById('holdRemarkModal').style.display = 'none';
          
          // ✅ Update UI immediately before refresh
          const currentRow = document.querySelector(`tr[data-stock-lot-id="${window.holdToggleState.currentLotId}"]`);
          if (currentRow) {
            const toggle = currentRow.querySelector('.hold-toggle-btn');
            const icon = currentRow.querySelector('.hold-remark-icon');
            // Find the Lot Status column (15th column, 0-indexed as 14)
            const lotStatusCell = currentRow.querySelector('td:nth-child(15)');
            
            if (action === 'hold') {
              if (toggle) toggle.checked = false;
              currentRow.classList.add('row-inactive');
              currentRow.querySelectorAll('td').forEach((td, idx) => {
                if (idx > 0) {
                  td.classList.add('row-inactive-blur');
                } else {
                  td.classList.remove('row-inactive-blur');
                }
              });
              if (icon) {
                icon.style.display = 'inline-block';
                icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:18px; height:18px;" />`;
                icon.setAttribute('title', 'Holding Reason: ' + remark);
              }
              // Update Lot Status to "On Hold"
              if (lotStatusCell) {
                lotStatusCell.innerHTML = `
                  <div class="d-inline-block px-3 fw-semibold text-center rounded-pill" style="border: 1px solid #dc3545; background-color: #f8d7da; color: #721c24; font-size: 13px; white-space: nowrap; padding: 5px;">
                    On Hold
                  </div>
                `;
              }
            } else {
              if (toggle) toggle.checked = true;
              currentRow.classList.remove('row-inactive');
              currentRow.querySelectorAll('td').forEach(td => {
                td.classList.remove('row-inactive-blur');
              });
              if (icon) {
                icon.style.display = 'none';
              }
              // Revert Lot Status to "Yet to Start" (default status when not on hold)
              if (lotStatusCell) {
                lotStatusCell.innerHTML = `
                  <div class="d-inline-block px-3 fw-semibold text-center rounded-pill" style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size:13px; white-space: nowrap; padding: 5px;">
                    Yet to Start
                  </div>
                `;
              }
            }
          }
          
          // ✅ Then refresh the table data
          setTimeout(() => {
            if (typeof refreshTableData === 'function') {
              refreshTableData();
            } else {
              location.reload();
            }
          }, 500);
          
        } else {
          document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
        }
      })
      .catch((error) => {
        console.error('Request failed:', error);
        document.getElementById('holdRemarkError').textContent = 'Network error!';
      });
    };
  }

  // ✅ Attach close button handler (only once globally)
  const closeBtn = document.getElementById('closeHoldRemarkModal');
  if (closeBtn && !window.holdCloseHandlerAttached) {
    window.holdCloseHandlerAttached = true;
    closeBtn.onclick = function () {
      document.getElementById('holdRemarkModal').style.display = 'none';
      // Clear the state when modal is closed
      window.holdToggleState = {
        currentHoldCell: null,
        intendedState: null,
        currentBatchId: null,
        currentLotId: null
      };
    };
  }

  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
}

// ✅ Call on page load
document.addEventListener("DOMContentLoaded", function () {
  attachHoldToggleListeners();
});
</script>

<!-- Tray Scan Modal & New Popup Script -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", () => {
      const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
      const trayModal = document.getElementById("trayScanModal");
      const closeTrayBtn = document.getElementById("closeTrayScanModal");
      const detailsDiv = document.getElementById("trayScanDetails");
      const newPopupModal = document.getElementById("newPopupModal");
      const closeNewPopupBtn = document.getElementById("closeNewPopupModal");

      // ✅ UPDATED: Direct accepted tray modal for "Set Top Tray" button
      trayScanLinks.forEach((link) => {
        link.addEventListener("click", (event) => {
          event.preventDefault();
      
          const row = event.target.closest("tr");
          const batchId = link.getAttribute('data-batch-id');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          const isOnHold = row.getAttribute('data-brass-onhold-picking') === 'True';
          const isBatchRejection = row.getAttribute('data-brass-batch-rejection') === 'True';

          trayModal.dataset.batchId = batchId;
          trayModal.dataset.stockLotId = stockLotId;

           // Get values for the modal
        const modelNo = row.getAttribute('data-model-no') || '';
        const lotQty = row.querySelector('.lot-qty')?.textContent.trim() || '';
        const missingQty = row.getAttribute('data-brass-missing-qty') || '';
        const physicalQty = row.getAttribute('data-brass-physical-qty') || '';

      
          const modelStockNo = row.querySelector('.model-hover-trigger').childNodes[0].textContent.trim();
          const modalHeader = document.getElementById("trayScanModalHeader");
          
          
if (isBatchRejection) {
  // Always fetch accepted tray scan data to get latest is_delink_only status
  fetch(`/nickle_inspection_zone_two/nq_zone_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
    .then(res => res.json())
    .then(rescanData => {
      if (rescanData.success && rescanData.is_delink_only) {
        // Check if delink trays are available
        fetch(`/nickle_inspection_zone_two/nq_zone_get_delink_tray_data/?lot_id=${encodeURIComponent(stockLotId)}`)
          .then(res => res.json())
          .then(delinkData => {
            if (delinkData.success && delinkData.delink_trays && delinkData.delink_trays.length > 0) {
              // Open modal in delink-only mode
              showAcceptedTrayModal(rescanData, stockLotId, false, true);
            } else {
              Swal.fire('No Delink Needed', 'There are no empty trays available for delink in this lot.', 'info');
            }
          });
      } else {
        // Fallback: show normal modal (should not happen for delink-only lots)
        showAcceptedTrayModal(rescanData, stockLotId, false, false);
      }
    });
          // ✅ UPDATED: If nq_onhold_picking is True, directly show accepted tray modal
        }else if (isOnHold) {
            console.log('🎯 "Set Top Tray" clicked - showing accepted tray modal directly...');
            
            // Directly fetch and show accepted tray data (skip rejection details popup)
            fetch(`/nickle_inspection_zone_two/nq_zone_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
              .then(res => res.json())
              .then(rescanData => {
                if (rescanData.success) {
                  console.log('✅ Fetched accepted tray data:', rescanData);
                  
                  // Check if draft exists
                  const hasDraft = rescanData.has_draft;
                  
                  // Show the accepted tray modal directly
                  showAcceptedTrayModal(rescanData, stockLotId, hasDraft);
                  
                  console.log('🚀 Accepted tray modal displayed directly');
                } else {
                  console.error('❌ Failed to fetch accepted tray data:', rescanData.error);
                  // Fallback: show error message
                  alert('Error loading accepted tray data: ' + (rescanData.error || 'Unknown error'));
                }
              })
              .catch(error => {
                console.error('❌ Network error fetching accepted tray data:', error);
                // Fallback: show error message
                alert('Network error loading accepted tray data. Please try again.');
              });
          } else {
            // Show editable rejection form for normal reject button
            if (modalHeader) {
              modalHeader.innerHTML = `Nickel QC / <span id="trayScanModalHeaderModelNo" style="font-weight:bold; color:#028084;"></span> / Rejection Window`;
            }
            // Extract quantities from the row data
            const lotQtyCell = row.cells[11]; // Lot Qty column (index 11)
            const physicalQtyCell = row.cells[12]; // Physical Qty column (index 12)
            const missingQtyAttr = row.getAttribute('data-brass-missing-qty');

            const lotQty = lotQtyCell ? lotQtyCell.textContent.trim() : '0';
            const physicalQty = physicalQtyCell ? physicalQtyCell.textContent.trim() : '0'; 
            const missingQty = missingQtyAttr || '0';

            const modalModelNo = document.getElementById("trayScanModalHeaderModelNo");
            const modelNo = row.getAttribute('data-model-no') || '';
            if (modalModelNo && modelNo) {
              modalModelNo.textContent = modelNo;
            }

            console.log('📊 Setting quantities:', { lotQty, physicalQty, missingQty });

            // Set quantities in modal header spans
            setTimeout(() => {
              const lotQtySpan = document.getElementById('trayScanModalLotQty');
              const missingQtySpan = document.getElementById('trayScanModalMissingQty');
              const physicalQtySpan = document.getElementById('trayScanModalPhysicalQty');
              
              if (lotQtySpan) {
                lotQtySpan.textContent = lotQty;
                console.log('✅ Set Lot Qty:', lotQty);
              }
              
              if (missingQtySpan) {
                missingQtySpan.textContent = missingQty;
                console.log('✅ Set Missing Qty:', missingQty);
              }
              
              if (physicalQtySpan) {
                physicalQtySpan.textContent = physicalQty;
                console.log('✅ Set Physical Qty:', physicalQty);
              }
            }, 150); // Small delay to ensure modal DOM is ready

            showEditableRejectionForm(stockLotId, batchId, detailsDiv, row);
            trayModal.classList.add("open");
          }
        });
      });



      
      // Function to fetch and show normal accepted tray data
      function fetchAndShowAcceptedTrayData(lotId) {
        fetch(`/nickle_inspection_zone_two/nq_zone_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
          .then(res => res.json())
          .then(rescanData => {
            if (rescanData.success) {
              
              showAcceptedTrayModal(rescanData, lotId, false);
            }
          })

      }

// ✅ IMPROVED: Convert loadDelinkTrayData to return a Promise
function loadDelinkTrayData(lotId) {
  console.log('🔍 [loadDelinkTrayData] Called with lotId:', lotId);
  
  return new Promise((resolve, reject) => {
    const delinkSection = document.getElementById('delinkSection');
    const url = `/nickle_inspection_zone_two/nq_zone_get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`;

    fetch(url)
      .then(res => {
        console.log('🔍 [loadDelinkTrayData] Response status:', res.status);
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        console.log('🔍 [loadDelinkTrayData] Response data:', data);

        // Hide or show the delink section based on tray count
        if (delinkSection) {
          if (data.delink_trays && data.delink_trays.length === 0) {
            delinkSection.style.display = 'none';
            console.log('🔍 [loadDelinkTrayData] Hiding delink section - no trays');
          } else {
            delinkSection.style.display = '';
            console.log('🔍 [loadDelinkTrayData] Showing delink section');
          }
        }

        const tableBody = document.getElementById('delinkTableBody');
        if (!tableBody) {
          console.log('❌ [loadDelinkTrayData] delinkTableBody not found');
          resolve(data); // Still resolve, just no table to populate
          return;
        }

        if (data.success && data.delink_trays && data.delink_trays.length > 0) {
          console.log('🔍 [loadDelinkTrayData] Building table for', data.delink_trays.length, 'trays');
          
          tableBody.innerHTML = '';
            // ✅ FIXED: Use index + 1 as fallback if tray.sno is undefined
            data.delink_trays.forEach((tray, index) => {
              const row = document.createElement('tr');
              row.style.cssText = 'border-bottom: 1px solid #f1f3f4; transition: all 0.2s ease;';
              row.innerHTML = `
                <td style="padding: 4px; font-size: 11px; font-weight: 600; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #f1f3f4; vertical-align: middle;">${tray.sno || (index + 1)}</td>
                <td style="padding: 4px 6px; border-right: 1px solid #f1f3f4; background: #fafbfc; vertical-align: middle;">
                  <input type="text" 
                        class="form-control delink-tray-input" 
                        placeholder="Scan Tray ID for Delink" 
                        value=""
                        style="width: 100%; padding: 4px 6px; font-size: 11px; border: 1px solid #ddd; border-radius: 3px; background: #fff; height: 24px;" 
                        data-row="${tray.sno || (index + 1)}"
                        data-expected-qty="${tray.tray_quantity || 0}" />
                  <span class="delink-tray-error" style="color: #d32f2f; font-size: 10px; margin-left: 2px; display: none;"></span>
                </td>
              `;
              tableBody.appendChild(row);
            });
          
          console.log('✅ [loadDelinkTrayData] Table built successfully');
          
          // Add delink tray validation and setup
          if (typeof addDelinkTrayValidation === 'function') {
            addDelinkTrayValidation(lotId);
          }
          if (typeof setupDelinkRedoFunctionality === 'function') {
            setupDelinkRedoFunctionality();
          }
          
          // Wait a bit for DOM to be fully ready, then resolve
          setTimeout(() => {
            resolve(data);
          }, 100);
          
        } else {
          console.log('🔍 [loadDelinkTrayData] No delink data or empty array');
          resolve(data);
        }
        
      })
      .catch(error => {
        console.error('❌ [loadDelinkTrayData] Error:', error);
        reject(error);
      });
  });
}

function checkForDuplicateTrayId() {
  // Get all delink tray inputs
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  // Get top tray input (if you want to check against top tray as well)
  const topTrayInput = document.getElementById('topTrayIdInput');
  const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';

  // Clear previous duplicate errors and styles
  delinkInputs.forEach(input => {
    input._hasError = false;
    input.style.border = '';
    input.style.backgroundColor = '';
    const errorDiv = input.parentElement.querySelector('.delink-tray-error');
    if (errorDiv && errorDiv.textContent.includes('Duplicate')) {
      errorDiv.style.display = 'none';
      errorDiv.textContent = '';
    }
  });

  // Build a map of tray IDs to all their input elements
  const trayIdMap = {};
  delinkInputs.forEach(input => {
    const trayId = input.value.trim();
    if (!trayId) return;
    if (!trayIdMap[trayId]) trayIdMap[trayId] = [];
    trayIdMap[trayId].push(input);
  });

  // Mark all duplicates in delink table
  Object.keys(trayIdMap).forEach(trayId => {
    if (trayIdMap[trayId].length > 1) {
      trayIdMap[trayId].forEach(input => {
        input._hasError = true;
        input.style.border = '2px solid #dc3545';
        input.style.backgroundColor = '#ffebee';
        const errorDiv = input.parentElement.querySelector('.delink-tray-error');
        if (errorDiv) {
          errorDiv.textContent = `❌ Duplicate Tray ID: "${trayId}"`;
          errorDiv.style.display = 'block';
          errorDiv.style.color = '#dc3545';
        }
        // Focus and select the input for correction (only if not already focused)
        if (document.activeElement !== input) {
          input.focus();
          input.select();
        }
      });
    }
  });

  // (Optional) Check for duplicate with top tray input
  if (topTrayInput && topTrayId) {
    delinkInputs.forEach(input => {
      const trayId = input.value.trim();
      if (trayId && trayId === topTrayId) {
        input._hasError = true;
        input.style.border = '2px solid #dc3545';
        input.style.backgroundColor = '#ffebee';
        const errorDiv = input.parentElement.querySelector('.delink-tray-error');
        if (errorDiv) {
          errorDiv.textContent = `❌ Duplicate with Top Tray: "${trayId}"`;
          errorDiv.style.display = 'block';
          errorDiv.style.color = '#dc3545';
        }
        if (document.activeElement !== input) {
          input.focus();
          input.select();
        }
        // Also mark top tray as duplicate
        const topTrayError = document.getElementById('topTrayError');
        if (topTrayError) {
          topTrayError.textContent = `❌ Duplicate with Delink Tray: "${trayId}"`;
          topTrayError.style.display = 'block';
          topTrayError.style.color = '#dc3545';
          topTrayInput.style.border = '2px solid #dc3545';
          topTrayInput.style.backgroundColor = '#ffebee';
          if (document.activeElement !== topTrayInput) {
            topTrayInput.focus();
            topTrayInput.select();
          }
        }
      }
    });
  }

  // Update counter and button states
  updateDelinkScanCounter();
  validateAllInputsAndUpdateButtons();
}
// ✅ FIXED: Add validation check function for buttons
function validateAllInputsAndUpdateButtons() {
  const draftBtn = document.getElementById("acceptedTrayDraftBtn");
  const submitBtn = document.getElementById("acceptedTraySubmitBtn");
  const updateDraftBtn = document.getElementById("acceptedTrayUpdateDraftBtn");
  const finalSubmitBtn = document.getElementById("acceptedTrayFinalSubmitBtn");

  let hasErrors = false;
  let atLeastOneTrayId = false;

  // Check Top Tray ID
  const topTrayInput = document.getElementById('topTrayIdInput');
  if (topTrayInput && topTrayInput.value.trim()) {
    atLeastOneTrayId = true;
    if (topTrayInput._hasError === true) hasErrors = true;
  }

  // Check Delink Tray IDs
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  delinkInputs.forEach(input => {
    const trayId = input.value.trim();
    if (trayId) {
      atLeastOneTrayId = true;
      if (input._hasError === true || input._isValidating === true) {
        hasErrors = true;
      }
      const errorDiv = input.parentElement.querySelector('.delink-tray-error');
      if (errorDiv && errorDiv.style.display !== 'none' && errorDiv.textContent) {
        const errorText = errorDiv.textContent.toLowerCase();
        if (errorText.includes('❌') || errorText.includes('invalid') ||
            errorText.includes('error') || errorText.includes('duplicate') ||
            errorText.includes('not found')) {
          hasErrors = true;
        }
      }
    }
  });

  // Enable Draft if at least one tray ID is entered and no errors
  if (draftBtn) {
    draftBtn.disabled = !atLeastOneTrayId || hasErrors;
    draftBtn.style.opacity = draftBtn.disabled ? '0.5' : '1';
    draftBtn.style.cursor = draftBtn.disabled ? 'not-allowed' : 'pointer';
  }

  // Other buttons (Submit, Update Draft, Final Submit) use stricter logic
  const shouldDisable = hasErrors;
  if (submitBtn) {
    submitBtn.disabled = shouldDisable;
    submitBtn.style.opacity = shouldDisable ? '0.5' : '1';
    submitBtn.style.cursor = shouldDisable ? 'not-allowed' : 'pointer';
  }
  if (updateDraftBtn) {
    updateDraftBtn.disabled = shouldDisable;
    updateDraftBtn.style.opacity = shouldDisable ? '0.5' : '1';
    updateDraftBtn.style.cursor = shouldDisable ? 'not-allowed' : 'pointer';
  }
  if (finalSubmitBtn) {
    finalSubmitBtn.disabled = shouldDisable;
    finalSubmitBtn.style.opacity = shouldDisable ? '0.5' : '1';
    finalSubmitBtn.style.cursor = shouldDisable ? 'not-allowed' : 'pointer';
  }

  console.log('🔍 Button validation:', {
    hasErrors,
    atLeastOneTrayId,
    shouldDisable,
    buttonsFound: {
      draft: !!draftBtn,
      submit: !!submitBtn,
      updateDraft: !!updateDraftBtn,
      finalSubmit: !!finalSubmitBtn
    }
  });
}

function saveTopTrayScanDraft(lotId, topTrayQty, isDraft = true) {
  saveTopTrayScanFinal(lotId, topTrayQty, isDraft);
}
// ✅ UPDATED: Enhanced delink tray validation to call duplicate check
function addDelinkTrayValidation(lotId) {
  console.log('🔧 Adding delink tray validation...');
  
  document.querySelectorAll('.delink-tray-input').forEach(function(input, idx, allInputs) {
    // Remove existing event listeners
    if (input._blurHandler) input.removeEventListener('blur', input._blurHandler);
    if (input._inputHandler) input.removeEventListener('input', input._inputHandler);
    if (input._keydownHandler) input.removeEventListener('keydown', input._keydownHandler);
    
    // Track validation state for each input
    input._hasError = false;
    input._isValidating = false;
    
    // Input event for counter update
    input._inputHandler = function() {
      this._hasError = false;
      const errorDiv = this.parentElement.querySelector('.delink-tray-error');
      if (errorDiv) {
        errorDiv.style.display = 'none';
        errorDiv.textContent = '';
      }
      // Reset input styling
      this.style.border = '2px solid #e74c3c';
      this.style.backgroundColor = '';
      
      updateDelinkScanCounter();
      
      // ✅ NEW: Check for duplicates on every input change
      checkForDuplicateTrayId();
      
      // Update button states when input changes
      validateAllInputsAndUpdateButtons();
    };
    input.addEventListener('input', input._inputHandler);
    
    // Enhanced keydown handler to prevent navigation on errors
    input._keydownHandler = function(e) {
      if (e.key === 'Tab' || e.key === 'Enter') {
        if (this._hasError || this._isValidating) {
          e.preventDefault();
          e.stopPropagation();
          this.focus();
          return false;
        }
      }
    };
    input.addEventListener('keydown', input._keydownHandler);
    
    // Blur event for validation
    input._blurHandler = function() {
      const trayId = this.value.trim();
      const errorDiv = this.parentElement.querySelector('.delink-tray-error');
      
      // Clear previous state
      this._hasError = false;
      this._isValidating = false;
      if (errorDiv) {
        errorDiv.style.display = 'none';
        errorDiv.textContent = '';
      }
      this.style.border = '2px solid #e74c3c';
      this.style.backgroundColor = '';
      
      if (!trayId) {
        validateAllInputsAndUpdateButtons();
        return;
      }
      
      // ✅ FIRST: Check for duplicates (including with top tray)
      checkForDuplicateTrayId();
      
      // If duplicate found, don't proceed with server validation
      if (this._hasError) {
        validateAllInputsAndUpdateButtons();
        return;
      }
      
      // Set validating state
      this._isValidating = true;
      if (errorDiv) {
        errorDiv.textContent = '🔄 Validating...';
        errorDiv.style.color = '#007bff';
        errorDiv.style.display = 'block';
      }
      
      // Update buttons while validating
      validateAllInputsAndUpdateButtons();
      
      // Call validation endpoint
fetch(`/nickle_inspection_zone_two/nq_zone_delink_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
  .then(res => res.json())
  .then(data => {
    this._isValidating = false;

    if (data.exists) {
      // Success
      this._hasError = false;
      this.style.border = '2px solid #28a745';
      this.style.backgroundColor = '#f8fff9';
      if (errorDiv) {
        errorDiv.textContent = `✅ ${data.status_message}`;
        errorDiv.style.color = '#28a745';
        errorDiv.style.display = 'block';

        // Auto-hide success message after 3 seconds
        setTimeout(() => {
          if (errorDiv) errorDiv.style.display = 'none';
        }, 3000);
      }
    } else {
      // Error
      this._hasError = true;
      this.style.border = '2px solid #dc3545';
      this.style.backgroundColor = '#ffebee';
      if (errorDiv) {
        errorDiv.textContent = `❌ ${data.error || 'Tray ID not found'}`;
        errorDiv.style.color = '#dc3545';
        errorDiv.style.display = 'block';
      }
      // Focus and select the input for correction
      this.focus();
      this.select();
    }

    updateDelinkScanCounter();
    validateAllInputsAndUpdateButtons();
  })
  .catch(error => {
    this._isValidating = false;
    this._hasError = true;
    this.style.border = '2px solid #dc3545';
    this.style.backgroundColor = '#ffebee';
    if (errorDiv) {
      errorDiv.textContent = '❌ Validation error';
      errorDiv.style.color = '#dc3545';
      errorDiv.style.display = 'block';
    }
    // Focus and select the input for correction
    this.focus();
    this.select();

    validateAllInputsAndUpdateButtons();
  });
    };
    input.addEventListener('blur', input._blurHandler);
  });
  
  // Initial button state check
  setTimeout(() => {
    validateAllInputsAndUpdateButtons();
  }, 100);
}



// ✅ NEW: Update delink scan counter
function updateDelinkScanCounter() {
  const counter = document.getElementById('delinkScanCounter');
  if (!counter) return;
  
  const totalQuantity = parseInt(counter.getAttribute('data-total-quantity')) || 0;
  let scannedQuantity = 0;
  
  // Calculate total scanned quantity
  document.querySelectorAll('.delink-tray-input').forEach(input => {
    const trayId = input.value.trim();
    if (trayId && !input._hasError) {
      const originalCapacity = parseInt(input.getAttribute('data-original-capacity')) || 0;
      scannedQuantity += originalCapacity;
    }
  });
  
  // Update counter display
  counter.textContent = `${scannedQuantity}/${totalQuantity}`;
  
  // Color coding
  if (scannedQuantity === totalQuantity && totalQuantity > 0) {
    counter.style.backgroundColor = '#d4edda';
    counter.style.color = '#155724';
  } else if (scannedQuantity > 0) {
    counter.style.backgroundColor = '#fff3cd';
    counter.style.color = '#856404';
  } else {
    counter.style.backgroundColor = '#f8d7da';
    counter.style.color = '#721c24';
  }
}


// ✅ UPDATED: Enhanced showAcceptedTrayModal function with reliable draft loading
function showAcceptedTrayModal(rescanData, lotId, isDraft, delinkOnlyMode = false) {
  console.log('🔍 [showAcceptedTrayModal] === STARTING ===');
  console.log('🔍 Input rescanData:', rescanData);
  console.log('🔍 Input lotId:', lotId);
  console.log('🔍 Input isDraft:', isDraft);

  let modelNo = rescanData.model_no;
  let topTrayQty = rescanData.top_tray_qty;
  let draftTrayId = rescanData.draft_tray_id || '';

  const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
  let platingStkNo = '';
  if (currentRow) {
    platingStkNo = currentRow.getAttribute('data-model-no') || '';
    console.log('✅ Got plating_stk_no from row:', platingStkNo);
  } else {
    platingStkNo = rescanData.model_no || 'N/A';
    console.log('⚠️ Fallback to backend model_no:', platingStkNo);
  }
  
  // ✅ NEW: Check for existing top tray draft to determine mode
  let actualIsDraft = isDraft;
  let draftData = null;
  
  // ✅ FIXED: Check for existing draft before showing modal
  fetch(`/nickle_inspection_zone_two/nq_zone_get_top_tray_scan_draft/?lot_id=${lotId}`)
    .then(res => res.json())
    .then(data => {
      if (data.success && data.has_draft) {
        actualIsDraft = true;
        draftData = data.draft_data;
        draftTrayId = draftData.tray_id || '';
        console.log('📄 Found existing top tray draft:', draftData);
      }
      
      // Build modal HTML based on actual draft status and delink-only mode
      buildAndShowModal(actualIsDraft, draftData, delinkOnlyMode);
    })
    .catch(error => {
      console.error('❌ Error checking for draft:', error);
      // Fallback to original logic
      buildAndShowModal(actualIsDraft, null, delinkOnlyMode);
    });
  
  function buildAndShowModal(isDraftMode, existingDraftData, isDelinkOnly = false) {
    let draftIndicator = isDraftMode ? ' (Draft Mode)' : '';
    let draftAlert = isDraftMode && existingDraftData ? `

    ` : '';

    // ✅ NEW: Special alert for delink-only mode
    let delinkOnlyAlert = isDelinkOnly ? `
      <div class="alert alert-warning" style="margin: 10px 0; padding: 8px 12px; font-size: 14px; background: linear-gradient(135deg, #fff3cd, #ffeaa7); border: 2px solid #ffc107; color: #856404;">
        <i class="fa fa-exclamation-triangle"></i> <strong>Delink Only Mode!</strong> Only empty trays need to be scanned for this lot.
      </div>
    ` : '';

    let html = `
      ${draftAlert}
      ${delinkOnlyAlert}
      <!-- ✅ UPDATED: Premium header styling from attachment 1 -->
      <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 8px 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid ${isDraftMode ? '#f39c12' : '#028084'}; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
        <h4 class="mb-0" style="font-size: 18px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px; white-space: nowrap; overflow: hidden;">
          <i class="fa fa-layer-group" style="color: ${isDraftMode ? '#f39c12' : '#028084'}; font-size: 12px;"></i>
          Nickel QC / <span style="color: #028084;">${platingStkNo}</span>
          ${isDelinkOnly ? '' : ''}
        </h4>
        
        <button id="closeAcceptedTrayModal" style="background: none; border: none; font-size: 20px; color: #6c757d; cursor: pointer; padding: 4px; line-height: 1; border-radius: 50%; transition: all 0.3s ease;" title="Close">
          <i class="fa fa-times"></i>
        </button>
      </div>

      <!-- ✅ UPDATED: Premium Delink Section styling from attachment 1 -->
      <div id="delinkSection" style="display: none;">
        <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 6px 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 6px; border-left: 3px solid #028084; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
          <h5 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px;">
            Delink Trays
          </h5>

          <div style="display: flex; align-items: center; gap: 10px;">
            <img id="delinkTrayRedoBtn"
                 src="{% static 'assets/icons/redo2.png' %}"
                 alt="Redo"
                 style="width: 20px; height: 20px; cursor: pointer; background: none; border: none; box-shadow: none; padding: 0;"
                 title="Clear Delink Tray IDs" />
          </div>
        </div>

        <!-- ✅ UPDATED: Premium table styling from attachment 1 -->
        <div class="table-responsive" style="max-height: 175px !important; border: 1px solid #dee2e6; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); background: #fff; scrollbar-width: none; -ms-overflow-style: none; display: grid; grid-template-columns: 1fr; overflow-y: auto; overscroll-behavior: contain; margin-bottom: 12px;">
          <table class="table table-bordered text-center mb-0" style="font-size: 11px; border-collapse: collapse; border-color: #028084;">
            <thead style="background: linear-gradient(135deg, #028084 0%, #0056b3 100%); position: relative;">
              <tr style="border: 1px solid #282f3a;">
                <th style="background-color: #028084 !important; padding: 8px 6px; font-size: 10px; font-weight: 700; border: 1px solid #282f3a; width: 50px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                  S.No
                </th>
                <th style="background-color: #028084 !important; padding: 8px 10px; font-size: 10px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                  De-Link Tray ID
                </th>
              </tr>
            </thead>
            <tbody id="delinkTableBody" style="background: #fff;">
              <tr>
                <td colspan="2" style="padding: 20px;">
                  <i class="fa fa-spinner fa-spin"></i> Loading delink data...
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
        
      <!-- ✅ UPDATED: Premium Top Tray Scan Section styling from attachment 1 -->
      <div id="topTrayScanSection" style="display: ${isDelinkOnly ? 'none' : 'block'};">
        <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 6px 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 6px; border-left: 3px solid #028084; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
          <h5 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px;">
            Accepted - Top Tray Scan${draftIndicator}
          </h5>
          
          <div style="display: flex; align-items: center; gap: 10px;">
            <img id="topTrayRedoBtn"
                 src="{% static 'assets/icons/redo2.png' %}"
                 alt="Redo"
                 style="width: 20px; height: 20px; cursor: pointer; background: none; border: none; box-shadow: none; padding: 0;"
                 title="Clear Top Tray ID" />
          </div>
        </div>

        <!-- ✅ UPDATED: Premium input section styling from attachment 1 -->
        <div style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: #ffffff; box-shadow: 0 1px 4px rgba(0,0,0,0.05);">
          <div style="display: flex; align-items: end; gap: 15px; width: 100%;">
            <div style="flex: 1; min-width: 0;">
              <label style="font-weight: 700; margin-bottom: 6px; display: block; color: #495057; font-size: 15px; display: flex; align-items: center; gap: 4px;">
                Scan top tray ID:
              </label>
              <input type="text" 
                     id="topTrayIdInput" 
                     placeholder="Scan Tray ID..." 
                     value="${draftTrayId}"
                     style="width: 100%; max-width: 280px; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: all 0.3s ease; background: #fff; ${draftTrayId ? 'background-color: #d4edda; border-color: #28a745;' : ''}" 
                     class="top-tray-id-input" />
              <div id="topTrayError" style="color: #dc3545; font-size: 11px; margin-top: 4px; display: none; font-weight: 500;"></div>
            </div>
            
            <div style="text-align: center;">
              <label style="font-weight: 700; margin-bottom: 6px; display: block; color: #495057; font-size: 15px;">Tray Qty:</label>
              <input type="number" 
                     value="${topTrayQty}" 
                     readonly 
                     style="width: 70px; padding: 8px 6px; text-align: center; border: 2px solid #ddd; border-radius: 6px; font-weight: 700; font-size: 14px;" />
            </div>
          </div>
        </div>
      </div>
        
      <!-- ✅ UPDATED: Premium button design from attachment 1 -->
      <div style="display: flex; justify-content: center; gap: 10px; margin-top: 30px;">
        ${isDelinkOnly ? `
          <!-- Delink-only mode buttons -->
          <button id="delinkOnlyDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
          <button id="delinkOnlySubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
        ` : (isDraftMode ? `
          <!-- Draft mode buttons -->
          <button id="acceptedTrayUpdateDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
          <button id="acceptedTrayFinalSubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
        ` : `
          <!-- Normal mode buttons -->
          <button id="acceptedTrayDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
          <button id="acceptedTraySubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
        `)}
        <button id="acceptedTrayCancelBtn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 30px;">Cancel</button>
      </div>

      <div id="acceptedTrayMsg" style="margin-top: 10px; text-align: center; font-weight: bold;"></div>
    `;
    
    // Close the tray scan modal first
    const trayModal = document.getElementById("trayScanModal");
    if (trayModal) {
      trayModal.classList.remove("open");
      trayModal.style.display = "none";
    }
    
    // Update the newPopupModal content
    const newPopupModal = document.getElementById("newPopupModal");
    const modalContent = newPopupModal.querySelector(".tray-scan-modal-content");
    if (modalContent) {
      modalContent.innerHTML = html;
      newPopupModal.classList.add("open");
    }

    // ✅ IMPROVED: Use reliable draft loading system instead of setTimeout
    loadDelinkAndDraftData(lotId, rescanData, isDraftMode, existingDraftData);
    
    // Add close button event listener
    setTimeout(() => {
      const closeBtn = document.getElementById("closeAcceptedTrayModal");
      if (closeBtn) {
        closeBtn.addEventListener("click", function () {
          const modal = document.getElementById("newPopupModal");
          if (modal) {
            modal.classList.remove("open");
            modal.style.display = "none";
          }
          window.location.reload(); // Reload to reset state
        });
      }
    }, 50);
    
    // ✅ NEW: Add event listeners with delink-only mode support
    if (isDelinkOnly) {
      addDelinkOnlyEventListeners(lotId, topTrayQty);
    } else {
      addTopTrayEventListeners(lotId, isDraftMode, topTrayQty);
    }

        setTimeout(() => {
      const topTrayInput = document.getElementById('topTrayIdInput');
      if (topTrayInput) {
        topTrayInput.focus();
        topTrayInput.select();
      }
    }, 150);

        setTimeout(() => {
      const firstDelinkInput = document.querySelector('.delink-tray-input');
      if (firstDelinkInput) {
        firstDelinkInput.focus();
        firstDelinkInput.select();
      }
    }, 150);
    
    // Show initial message
    if (isDelinkOnly) {
      // No message for delink-only mode
    } else if (isDraftMode && existingDraftData) {
      // Will show message after draft loads
    } else if (draftTrayId && !isPlaceholderTrayId(draftTrayId)) {
      showAcceptedTrayMessage('✅ Data loaded', '#28a745');
    }
  }
}

// ✅ NEW: Improved combined delink and draft loading function
function loadDelinkAndDraftData(lotId, rescanData, isDraftMode, existingDraftData) {
  console.log('🔄 [loadDelinkAndDraftData] Starting combined loading for lot:', lotId);
  console.log('🔍 [loadDelinkAndDraftData] isDraftMode:', isDraftMode);
  console.log('🔍 [loadDelinkAndDraftData] existingDraftData:', existingDraftData);
  
  // Step 1: Load delink data first (Promise-based)
  loadDelinkTrayData(lotId)
    .then(() => {
      console.log('✅ [loadDelinkAndDraftData] Delink data loaded, now loading draft...');
      
      // Step 2: Load draft data after delink is ready
      if (rescanData.has_draft || (isDraftMode && existingDraftData)) {
        // Use existing draft data if available, otherwise use rescanData
        const draftDataToLoad = existingDraftData || rescanData;
        
        // Multiple attempts with increasing delays to ensure DOM is ready
        attemptDraftLoad(draftDataToLoad, 0);
      } else {
        console.log('⏭️ [loadDelinkAndDraftData] No draft data to load');
        
        // Still try to call the legacy function for backward compatibility
        if (typeof loadTopTrayScanDraft === 'function') {
          loadTopTrayScanDraft(lotId);
        }
      }
    })
    .catch(error => {
      console.error('❌ [loadDelinkAndDraftData] Error loading delink data:', error);
      
      // Still try to load draft even if delink fails
      if (rescanData.has_draft || (isDraftMode && existingDraftData)) {
        const draftDataToLoad = existingDraftData || rescanData;
        attemptDraftLoad(draftDataToLoad, 0);
      }
    });
}

// ✅ NEW: Reliable draft loading with multiple attempts
function attemptDraftLoad(draftData, attemptNumber) {
  const maxAttempts = 5;
  const delays = [100, 300, 600, 1000, 2000]; // Progressive delays
  
  if (attemptNumber >= maxAttempts) {
    console.log('❌ [attemptDraftLoad] Max attempts reached, draft loading failed');
    return;
  }
  
  console.log(`🔄 [attemptDraftLoad] Attempt ${attemptNumber + 1}/${maxAttempts}`);
  
  setTimeout(() => {
    let success = false;
    
    // Try different draft loading methods based on data structure
    if (draftData.delink_trays || draftData.draft_tray_id) {
      // New format: direct draft data
      success = loadDraftDataDirectly(draftData);
    } else if (draftData.tray_id || draftData.delink_trays) {
      // Alternative format: existing draft data structure
      success = populateTopTrayDraftData(draftData);
    }
    
    if (!success && attemptNumber < maxAttempts - 1) {
      console.log(`⏭️ [attemptDraftLoad] Attempt ${attemptNumber + 1} failed, retrying...`);
      attemptDraftLoad(draftData, attemptNumber + 1);
    } else if (success) {
      console.log('✅ [attemptDraftLoad] Draft loaded successfully!');
      showAcceptedTrayMessage('✅ Draft data loaded', '#28a745');
    }
  }, delays[attemptNumber]);
}

// ✅ IMPROVED: Enhanced loadDraftDataDirectly with better error handling
function loadDraftDataDirectly(rescanData) {
  console.log('🔄 [loadDraftDataDirectly] STARTING DIRECT LOAD...');
  console.log('🔍 [loadDraftDataDirectly] rescanData:', rescanData);
  
  let success = false;
  
  try {
    // 1. Load top tray
    const topTrayInput = document.getElementById('topTrayIdInput');
    const draftTrayId = rescanData.draft_tray_id || rescanData.tray_id || '';
    
    if (topTrayInput && draftTrayId && !isPlaceholderTrayId(draftTrayId)) {
      const oldTopValue = topTrayInput.value;
      topTrayInput.value = draftTrayId;
      
      // Apply draft styling
      topTrayInput.style.backgroundColor = '#d4edda';
      topTrayInput.style.borderColor = '#28a745';
      topTrayInput.style.color = '#155724';
      topTrayInput.style.fontWeight = '600';
      
      console.log(`✅ [loadDraftDataDirectly] Top tray: "${oldTopValue}" → "${topTrayInput.value}"`);
      success = true;
    }
    
    // 2. Load delink trays
    const delinkInputs = document.querySelectorAll('.delink-tray-input');
    console.log(`🔍 [loadDraftDataDirectly] Found ${delinkInputs.length} delink inputs`);
    
    if (delinkInputs.length === 0) {
      console.log('⚠️ [loadDraftDataDirectly] No delink inputs found - may be normal');
      return success; // Return current success status
    }
    
    // Load delink trays if available
    const delinkTrays = rescanData.delink_trays || [];
    if (Array.isArray(delinkTrays) && delinkTrays.length > 0) {
      console.log(`🔍 [loadDraftDataDirectly] Loading ${delinkTrays.length} delink trays...`);
      
      let delinkLoaded = false;
      
      delinkTrays.forEach((tray, arrayIndex) => {
        const position = tray.position !== undefined ? tray.position : arrayIndex;
        const trayId = tray.tray_id || '';
        const trayQty = tray.tray_qty || tray.original_capacity || 0;
        
        if (position >= 0 && position < delinkInputs.length && trayId) {
          const targetInput = delinkInputs[position];
          const oldValue = targetInput.value;
          
          // Set the value
          targetInput.value = trayId;
          targetInput.setAttribute('data-expected-qty', trayQty);
          
          // Add visual styling
          targetInput.style.backgroundColor = '#d4edda';
          targetInput.style.borderColor = '#28a745';
          targetInput.style.color = '#155724';
          targetInput.style.fontWeight = '600';
          
          console.log(`✅ [loadDraftDataDirectly] Input[${position}]: "${oldValue}" → "${targetInput.value}"`);
          
          // Trigger events
          targetInput.dispatchEvent(new Event('input', { bubbles: true }));
          targetInput.dispatchEvent(new Event('change', { bubbles: true }));
          
          delinkLoaded = true;
        }
      });
      
      if (delinkLoaded) {
        success = true;
        
        // Update counter if function exists
        if (typeof updateDelinkScanCounter === 'function') {
          updateDelinkScanCounter();
        }
      }
    }
    
  } catch (error) {
    console.error('❌ [loadDraftDataDirectly] Error during draft loading:', error);
    return false;
  }
  
  return success;
}
// ✅ Helper function to check for placeholder tray IDs
function isPlaceholderTrayId(trayId) {
  if (!trayId) return false;
  const placeholderPatterns = [
    'PLACEHOLDER',
    'TEMP_',
    'DRAFT_',
    'PENDING_'
  ];
  return placeholderPatterns.some(pattern => trayId.includes(pattern));
}

// ✅ NEW: Event listeners for delink-only mode
function addDelinkOnlyEventListeners(lotId, topTrayQty) {
  // Draft Delink button
  const draftBtn = document.getElementById("delinkOnlyDraftBtn");
  if (draftBtn) {
    draftBtn.addEventListener("click", function () {
      if (this.disabled) {
        showAcceptedTrayMessage('Please fix validation errors before proceeding', '#dc3545');
        return;
      }
      saveDelinkOnlyData(lotId, true); // true = draft
    });
  }
  
  // Submit Delink button
  const submitBtn = document.getElementById("delinkOnlySubmitBtn");
  if (submitBtn) {
    submitBtn.addEventListener("click", function () {
      if (this.disabled) {
        showAcceptedTrayMessage('Please fix validation errors before proceeding', '#dc3545');
        return;
      }
      saveDelinkOnlyData(lotId, false); // false = final submit
    });
  }

  // Cancel button
  const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
  if (cancelBtn) {
    cancelBtn.addEventListener("click", function () {
      document.getElementById("newPopupModal").classList.remove("open");
      setTimeout(() => {
        window.location.reload();
      }, 300);
    });
  }
}

// ✅ NEW: Function to save delink-only data
function saveDelinkOnlyData(lotId, isDraft) {
  const delinkTrays = [];
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  
  delinkInputs.forEach((input, index) => {
    const delinkTrayId = input.value.trim();
    const originalCapacity = parseInt(input.getAttribute('data-original-capacity')) || 0;
    // Always push, even if tray ID is empty
    delinkTrays.push({
      tray_id: delinkTrayId, // may be empty string
      original_capacity: originalCapacity,
      position: index // 0-based, matches UI order
    });
  });

  if (delinkTrays.length === 0) {
    showAcceptedTrayMessage('Please scan at least one delink tray ID', '#dc3545');
    return;
  }
  
  const payload = {
    lot_id: lotId,
    tray_id: '', // No top tray in delink-only mode
    tray_qty: 0, // No top tray quantity
    draft_save: isDraft,
    delink_trays: delinkTrays,
    delink_only_mode: true // Flag to indicate delink-only mode
  };
  
  console.log('🚀 [saveDelinkOnlyData] Sending delink-only payload:', payload);
  
  // Show loading message
  if (!isDraft) {
    showAcceptedTrayMessage('💾 Submitting delink trays...', '#007bff');
  } else {
    showAcceptedTrayMessage('💾 Saving delink trays as draft...', '#007bff');
  }
  
  fetch('/nickle_inspection_zone_two/nq_zone_save_single_top_tray_scan/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify(payload)
  })
  .then(res => res.json())
  .then(data => {
    console.log('📦 [saveDelinkOnlyData] Server response:', data);
    
    if (data.success) {
      let message = data.message || 'Delink trays processed successfully';
      if (data.delink_count > 0) {
        message += ` (${data.delink_count} tray(s) delinked)`;
      }
      
      showAcceptedTrayMessage(message, '#28a745');
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    } else {
      showAcceptedTrayMessage(data.error || 'Save failed', '#dc3545');
    }
  })
  .catch(error => {
    console.error('❌ [saveDelinkOnlyData] Network error:', error);
    showAcceptedTrayMessage('Network error occurred', '#dc3545');
  });
}

// ✅ UPDATED: Enhanced addTopTrayEventListeners to work with draft system
function addTopTrayEventListeners(lotId, isDraft, topTrayQty) {
  const topTrayInput = document.getElementById('topTrayIdInput');
  const topTrayError = document.getElementById('topTrayError');
  const redoBtn = document.getElementById('topTrayRedoBtn');
  
  // Input validation on blur (existing logic)
  if (topTrayInput) {
    // Remove existing event listeners
    if (topTrayInput._blurHandler) topTrayInput.removeEventListener('blur', topTrayInput._blurHandler);
    if (topTrayInput._inputHandler) topTrayInput.removeEventListener('input', topTrayInput._inputHandler);
    
    // Input event for real-time validation
    topTrayInput._inputHandler = function() {
      // Always clear error state and message on input
      this._hasError = false;
      this.style.border = '';
      this.style.backgroundColor = '';
      if (topTrayError) {
        topTrayError.textContent = '';
        topTrayError.style.display = 'none';
      }
    
      // Check for duplicate with delink tray inputs
      const trayId = this.value.trim();
      let isDuplicate = false;
      document.querySelectorAll('.delink-tray-input').forEach(input => {
        if (input.value.trim() && input.value.trim() === trayId) {
          isDuplicate = true;
        }
      });
    
      if (isDuplicate) {
        this._hasError = true;
        this.style.border = '2px solid #dc3545';
        this.style.backgroundColor = '#ffebee';
        if (topTrayError) {
          topTrayError.textContent = `❌ Duplicate with Delink Tray: "${trayId}"`;
          topTrayError.style.display = 'block';
          topTrayError.style.color = '#dc3545';
        }
      } else {
        // No duplicate, clear error
        this._hasError = false;
        this.style.border = '';
        this.style.backgroundColor = '';
        if (topTrayError) {
          topTrayError.textContent = '';
          topTrayError.style.display = 'none';
        }
      }
    
      validateAllInputsAndUpdateButtons();
    };
    topTrayInput.addEventListener('input', topTrayInput._inputHandler);
    
    topTrayInput._blurHandler = function() {
      const trayId = this.value.trim();
      if (!trayId) {
        hideError();
        validateAllInputsAndUpdateButtons();
        return;
      }
      
      checkForDuplicateTrayId();
      
      // If duplicate found with delink, don't proceed with server validation
      const topTrayError = document.getElementById('topTrayError');
      if (topTrayError && topTrayError.textContent.includes('Duplicate')) {
        validateAllInputsAndUpdateButtons();
        return;
      }
      
      validateTopTrayIdForDisplay(trayId, lotId);
    };
    topTrayInput.addEventListener('blur', topTrayInput._blurHandler);
  }
  
  // ✅ ENHANCED: Redo button to clear draft styling
  if (redoBtn) {
    redoBtn.addEventListener('click', function() {
      console.log('🔄 Top tray redo clicked - clearing all states...');
      
      if (topTrayInput) {
        // Clear the input value
        topTrayInput.value = '';
        
        // ✅ CRITICAL: Reset all visual styling including draft styling
        topTrayInput.style.border = '';
        topTrayInput.style.backgroundColor = '';
        topTrayInput.style.borderColor = '';
        
        // Remove draft indicators
        const draftIndicators = topTrayInput.parentElement.querySelectorAll('[title="Draft Data"]');
        draftIndicators.forEach(indicator => indicator.remove());
        
        // Clear any error states
        topTrayInput._hasError = false;
        topTrayInput._isValidating = false;
        
        console.log('✅ Top tray input cleared and draft styling reset');
      }
      
      // Clear error message
      if (topTrayError) {
        topTrayError.style.display = 'none';
        topTrayError.textContent = '';
      }
      
      // Run duplicate check to clear any delink duplicate errors
      checkForDuplicateTrayId();
      
      // Update button states
      validateAllInputsAndUpdateButtons();
      
      // Focus the input after clearing
      if (topTrayInput) {
        setTimeout(() => {
          topTrayInput.focus();
        }, 50);
      }
      
      console.log('🎯 Top tray redo completed successfully');
    });
  }
  
  // ✅ UPDATED: Button event listeners with draft support
  addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty);
  

  function validateTopTrayIdForDisplay(trayId, lotId) {
    showError('Validating...', '#007bff');
  
    // ✅ FIXED: Use the correct endpoint and handle the response properly
    fetch(`/nickle_inspection_zone_two/nq_zone_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(data => {
      console.log('🔍 [validateTopTrayIdForDisplay] Response:', data);
      
      if (data.exists) {
        // ✅ SUCCESS: Tray is valid
        hideError();
        
        // Style input as valid
        if (topTrayInput) {
          topTrayInput.style.border = '2px solid #28a745';
          topTrayInput.style.backgroundColor = '#f8fff8';
        }
        
        // Show success message briefly
        showError('✅ Valid tray ID', '#28a745');
        setTimeout(() => {
          hideError();
        }, 2000);
        
      } else {
        // ❌ ERROR: Handle different error types with proper styling
        let errorMessage = '';
        
        if (data.already_rejected) {
          if (data.rejected_in_input_screening) {
            errorMessage = `❌ This tray is rejected in Input Screening`;
          } else if (data.rejected_in_brass_qc) {
            errorMessage = `❌ This tray is rejected in Brass QC`;
          } else {
            errorMessage = `❌ This tray is already rejected`;
          }
        } else if (data.not_in_same_lot) {
          errorMessage = `❌ Tray ID "${trayId}" is not in the same lot`;
        } else {
          errorMessage = `❌ Tray ID "${trayId}" does not exist`;
        }
        
        // ✅ ENHANCED: Show error with better styling
        showEnhancedError(errorMessage, '#dc3545');
        
        // Style input as invalid
        if (topTrayInput) {
          topTrayInput.style.border = '2px solid #dc3545';
          topTrayInput.style.backgroundColor = '#ffebee';
        }
      }
      
      // ✅ CRITICAL: Update button states after validation
      validateAllInputsAndUpdateButtons();
    })
    .catch(error => {
      console.error('❌ [validateTopTrayIdForDisplay] Error:', error);
      showEnhancedError('❌ Validation failed. Please try again.', '#dc3545');
      
      // Style input as invalid
      if (topTrayInput) {
        topTrayInput.style.border = '2px solid #dc3545';
        topTrayInput.style.backgroundColor = '#ffebee';
      }
      
      // Update button states
      validateAllInputsAndUpdateButtons();
    });
  }
  
  // ✅ NEW: Enhanced error display function with better styling
  function showEnhancedError(message, color) {
    if (topTrayError) {
      topTrayError.textContent = message;
      topTrayError.style.color = color;
      topTrayError.style.display = 'block';
      
      // ✅ ENHANCED: Add better styling for error messages
      topTrayError.style.fontWeight = 'bold';
      topTrayError.style.fontSize = '13px';
      topTrayError.style.padding = '6px 10px';
      topTrayError.style.backgroundColor = '#ffebee';
      topTrayError.style.border = '1px solid #dc3545';
      topTrayError.style.borderRadius = '4px';
      topTrayError.style.marginTop = '8px';
      topTrayError.style.textAlign = 'left';
      
      // ✅ Add icon based on error type
      if (message.includes('Input Screening')) {
        topTrayError.style.borderLeftColor = '#ff9800';
        topTrayError.style.borderLeftWidth = '4px';
        topTrayError.style.backgroundColor = '#fff3e0';
        topTrayError.style.color = '#e65100';
      } else if (message.includes('Brass QC')) {
        topTrayError.style.borderLeftColor = '#f44336';
        topTrayError.style.borderLeftWidth = '4px';
        topTrayError.style.backgroundColor = '#ffebee';
        topTrayError.style.color = '#c62828';
      } else {
        topTrayError.style.borderLeftColor = '#dc3545';
        topTrayError.style.borderLeftWidth = '4px';
      }
    }
  }
  
  function showError(message, color) {
    if (topTrayError) {
      topTrayError.textContent = message;
      topTrayError.style.color = color;
      topTrayError.style.display = 'block';
      
      // ✅ Basic styling for non-error messages
      if (color === '#007bff') {
        // Validating message
        topTrayError.style.fontWeight = 'normal';
        topTrayError.style.fontSize = '12px';
        topTrayError.style.padding = '4px 8px';
        topTrayError.style.backgroundColor = '#e3f2fd';
        topTrayError.style.border = '1px solid #2196f3';
        topTrayError.style.borderRadius = '4px';
        topTrayError.style.marginTop = '4px';
      } else if (color === '#28a745') {
        // Success message
        topTrayError.style.fontWeight = 'bold';
        topTrayError.style.fontSize = '12px';
        topTrayError.style.padding = '4px 8px';
        topTrayError.style.backgroundColor = '#e8f5e9';
        topTrayError.style.border = '1px solid #4caf50';
        topTrayError.style.borderRadius = '4px';
        topTrayError.style.marginTop = '4px';
      }
    }
  }
  

  function hideError() {
    if (topTrayError) {
      topTrayError.style.display = 'none';
      topTrayError.textContent = '';
    }
  }
  
  setTimeout(() => {
    validateAllInputsAndUpdateButtons();
  }, 100);
}

// ✅ UPDATED: Enhanced redo functionality to clear duplicates
function setupDelinkRedoFunctionality() {
  // Remove existing event listener if any
  const existingBtn = document.getElementById('delinkTrayRedoBtn');
  if (existingBtn) {
    existingBtn.replaceWith(existingBtn.cloneNode(true));
  }
  
  // Add event listener for delink redo button
  const delinkRedoBtn = document.getElementById('delinkTrayRedoBtn');
  if (delinkRedoBtn) {
    delinkRedoBtn.addEventListener('click', function() {
      // Clear all delink tray inputs
      document.querySelectorAll('.delink-tray-input').forEach(input => {
        input.value = '';
        input.style.border = '2px solid #e74c3c';
        input.style.backgroundColor = '';
        input._hasError = false;
        input._isValidating = false;
        
        const errorDiv = input.parentElement.querySelector('.delink-tray-error');
        if (errorDiv) {
          errorDiv.style.display = 'none';
          errorDiv.textContent = '';
        }
      });
      
      // ✅ NEW: Check for duplicates after clearing (this will also clear any top tray duplicate errors)
      checkForDuplicateTrayId();
      
      // Update counter
      updateDelinkScanCounter();
      
      // Update button states
      validateAllInputsAndUpdateButtons();
      
      // Focus first input
      const firstInput = document.querySelector('.delink-tray-input');
      if (firstInput) {
        firstInput.focus();
      }
    });
  } 
}

// ✅ FIXED: Updated button listeners with proper submit functionality
function addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty) {
  if (isDraft) {
    // Update Draft button
    const updateDraftBtn = document.getElementById("acceptedTrayUpdateDraftBtn");
    const finalSubmitBtn = document.getElementById("acceptedTrayFinalSubmitBtn");
    
    if (updateDraftBtn) {
      updateDraftBtn.addEventListener("click", function () {
        if (this.disabled) {
          showAcceptedTrayMessage('Please fix validation errors before proceeding', '#dc3545');
          return;
        }
        saveTopTrayScanDraft(lotId, topTrayQty, true); // true = update draft
      });
    }
    
    if (finalSubmitBtn) {
      finalSubmitBtn.addEventListener("click", function () {
        if (this.disabled) {
          showAcceptedTrayMessage('Please fix validation errors before proceeding', '#dc3545');
          return;
        }
        // ✅ FIXED: Use the correct submit function
        saveTopTrayScanFinal(lotId, topTrayQty, false); // false = final submit
      });
    }
  } else {
    // Draft and Submit buttons for new scans
    const draftBtn = document.getElementById("acceptedTrayDraftBtn");
    const submitBtn = document.getElementById("acceptedTraySubmitBtn");
    
    if (draftBtn) {
      draftBtn.addEventListener("click", function () {
        if (this.disabled) {
          showAcceptedTrayMessage('Please fix validation errors before proceeding', '#dc3545');
          return;
        }
        saveTopTrayScanDraft(lotId, topTrayQty, true); // true = save as draft
      });
    }
    
    if (submitBtn) {
      submitBtn.addEventListener("click", function () {
        if (this.disabled) {
          showAcceptedTrayMessage('Please fix validation errors before proceeding', '#dc3545');
          return;
        }
        // ✅ FIXED: Use the correct submit function
        saveTopTrayScanFinal(lotId, topTrayQty, false); // false = final submit
      });
    }
  }

  // Cancel button (same for both modes)
  const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
  if (cancelBtn) {
    cancelBtn.addEventListener("click", function () {
      document.getElementById("newPopupModal").classList.remove("open");
      setTimeout(() => {
        window.location.reload();
      }, 300);
    });
  }
}

function saveTopTrayScanFinal(lotId, topTrayQty, isDraft = false) {
  const topTrayInput = document.getElementById('topTrayIdInput');
  const trayId = topTrayInput ? topTrayInput.value.trim() : '';

  // Collect delink tray data from the delink section
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  const delinkTrays = [];
  let allDelinkFilled = true;

  delinkInputs.forEach((input, index) => {
    const delinkTrayId = input.value.trim();
    const originalCapacity = parseInt(input.getAttribute('data-original-capacity')) || 0;
    delinkTrays.push({
      tray_id: delinkTrayId,
      original_capacity: originalCapacity,
      position: index
    });
    // Check if any delink tray is empty
    if (!delinkTrayId) {
      allDelinkFilled = false;
    }
  });

  // --- Restrict Submit: All required fields must be filled ---

if (!isDraft) {
  // Require all delink tray IDs to be filled if any delink trays exist
  if (delinkInputs.length > 0 && !allDelinkFilled) {
    showAcceptedTrayMessage('Please fill all Delink Tray IDs before submitting.', '#dc3545');
    return;
  }
  // Always require top tray ID to be filled (unless in delink-only mode)
  if (!trayId) {
    showAcceptedTrayMessage('Please scan Top Tray ID before submitting.', '#dc3545');
    return;
  }
}

  // Validation: at least one tray ID (top tray or any delink tray) must be entered for draft
  const hasDelinkTrays = delinkTrays.some(tray => tray.tray_id);
  if (!trayId && !hasDelinkTrays) {
    showAcceptedTrayMessage('Please scan at least one tray ID (either Top Tray or Delink)', '#dc3545');
    return;
  }

  const payload = {
    lot_id: lotId,
    tray_id: trayId,
    tray_qty: topTrayQty,
    draft_save: isDraft, // false for final submission
    delink_trays: delinkTrays
  };

  console.log('🚀 [saveTopTrayScanFinal] Sending final submission payload:', payload);

  // Show loading message
  if (!isDraft) {
    showAcceptedTrayMessage('💾 Submitting top tray scan...', '#007bff');
  } else {
    showAcceptedTrayMessage('💾 Saving as draft...', '#007bff');
  }

  fetch('/nickle_inspection_zone_two/nq_zone_save_single_top_tray_scan/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify(payload)
  })
  .then(res => res.json())
  .then(data => {
    console.log('📦 [saveTopTrayScanFinal] Server response:', data);

    if (data.success) {
      let message = data.message;
      if (data.delink_count > 0) {
        message += ` (${data.delink_count} tray(s) delinked)`;
      }

      // Clear draft after successful final submission
      if (!isDraft) {
        clearTopTrayScanDraft(lotId);
      }

      showAcceptedTrayMessage(message, '#28a745');
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    } else {
      showAcceptedTrayMessage(data.error || 'Save failed', '#dc3545');
    }
  })
  .catch(error => {
    console.error('❌ [saveTopTrayScanFinal] Network error:', error);
    showAcceptedTrayMessage('Network error occurred', '#dc3545');
  });
}

// Helper to clear draft after final submit
function clearTopTrayScanDraft(lotId) {
  fetch('/nickle_inspection_zone_two/nq_zone_clear_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: lotId
    })
  })
  .then(res => res.json())
  .then(data => {
    console.log('🗑️ Draft cleared after final submission:', data.success);
  })
  .catch(error => {
    console.log('❌ Error clearing draft:', error);
  });
}


// ✅ NEW: Enhanced success message for draft saves
function showTopTrayDraftSuccess(message, delinkCount = 0) {
  const msgDiv = document.getElementById("acceptedTrayMsg");
  if (msgDiv) {
    let fullMessage = message;
    if (delinkCount > 0) {
      fullMessage += ` (${delinkCount} delink tray(s) included)`;
    }
    
    msgDiv.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #e7d7f7, #f3e9ff);
        border: 2px solid #6f42c1;
        color: #4a1a7a;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 600;
        text-align: center;
        margin: 10px 0;
        box-shadow: 0 2px 8px rgba(111, 66, 193, 0.2);
        animation: fadeInScale 0.5s ease;
      ">
        <i class="fa fa-file-text" style="margin-right: 8px; color: #6f42c1;"></i>
        ${fullMessage}
        <div style="font-size: 12px; margin-top: 4px; opacity: 0.8;">
          📄 Draft saved! Page will refresh...
        </div>
      </div>
    `;
  }
}

// ✅ NEW: Function to load top tray scan draft data
// Call this after modal HTML is rendered and inputs are present
function loadTopTrayScanDraft(lotId) {
  fetch(`/nickle_inspection_zone_two/nq_zone_get_top_tray_scan_draft/?lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(data => {
      if (data.success && data.has_draft && data.draft_data) {
        const draft = data.draft_data;
        // Fill top tray ID
        const topTrayInput = document.getElementById('topTrayIdInput');
        if (topTrayInput && draft.tray_id) {
          topTrayInput.value = draft.tray_id;
          topTrayInput.style.borderColor = '#6f42c1';
          topTrayInput.style.backgroundColor = '#faf8ff';
        }
        // Fill tray qty if needed
        const trayQtyInput = document.querySelector('input[type="number"][readonly]');
        if (trayQtyInput && draft.tray_qty) {
          trayQtyInput.value = draft.tray_qty;
        }
        // Fill delink tray ids if present
        if (draft.delink_trays && Array.isArray(draft.delink_trays)) {
          const delinkInputs = document.querySelectorAll('.delink-tray-input');
          draft.delink_trays.forEach((tray, idx) => {
            if (delinkInputs[idx]) {
              delinkInputs[idx].value = tray.tray_id;
              delinkInputs[idx].style.borderColor = '#6f42c1';
              delinkInputs[idx].style.backgroundColor = '#faf8ff';
            }
          });
        }
      }
    });
}



// ✅ NEW: Function to populate draft data in the modal
function populateTopTrayDraftData(draftData) {
  console.log('📝 Populating top tray scan draft data:', draftData);
  
  // Fill top tray ID
  const topTrayInput = document.getElementById('topTrayIdInput');
  if (topTrayInput && draftData.tray_id) {
    topTrayInput.value = draftData.tray_id;
    // Style as draft data
    topTrayInput.style.borderColor = '#6f42c1';
    topTrayInput.style.backgroundColor = '#faf8ff';

  }
  
  // Fill delink tray data if exists
  if (draftData.delink_trays && draftData.delink_trays.length > 0) {
    setTimeout(() => {
      populateDelinkDraftData(draftData.delink_trays);
    }, 300);
  }
  
  // Show draft indicator message
  
  // Change buttons to update mode
  updateButtonsForDraftMode();
}

// ✅ NEW: Function to populate delink draft data
function populateDelinkDraftData(delinkTrays) {
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  delinkInputs.forEach((input, index) => {
    if (index < delinkTrays.length) {
      const delinkTray = delinkTrays[index];
      if (delinkTray.tray_id) {
        input.value = delinkTray.tray_id;
        input.style.borderColor = '#6f42c1';
        input.style.backgroundColor = '#faf8ff';
      }
      // Optionally set capacity or other info if needed
      input.setAttribute('data-original-capacity', delinkTray.original_capacity || 0);
    }
  });
  updateDelinkScanCounter();
}

// ✅ NEW: Function to show draft indicator
function showTopTrayDraftIndicator(message) {
  const msgDiv = document.getElementById("acceptedTrayMsg");
  if (msgDiv) {
    msgDiv.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #e7d7f7, #f3e9ff);
        border: 2px solid #6f42c1;
        color: #4a1a7a;
        padding: 10px 15px;
        border-radius: 6px;
        margin: 10px 0;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        animation: slideInDown 0.5s ease;
      ">
        <i class="fa fa-file-text" style="color: #6f42c1; font-size: 16px;"></i>
        <span style="font-weight: 600;">${message}</span>

      </div>
    `;
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      msgDiv.innerHTML = "";
    }, 5000);
  }
}

// ✅ NEW: Function to update buttons for draft mode
function updateButtonsForDraftMode() {
  // Update button text to indicate draft mode
  const draftBtn = document.getElementById("acceptedTrayDraftBtn");
  const submitBtn = document.getElementById("acceptedTraySubmitBtn");
  
  if (draftBtn) {
    draftBtn.textContent = "Draft";
    draftBtn.style.background = "#6f42c1";
  }
  
  if (submitBtn) {
    submitBtn.textContent = "Submit";
  }
}


function showAcceptedTrayMessage(message, color) {
  const msgDiv = document.getElementById("acceptedTrayMsg");
  if (msgDiv) {
    msgDiv.textContent = message;
    msgDiv.style.color = color;
  }
}

      // Add event listeners for normal mode
      function addNormalModeEventListeners(lotId) {
        // Draft button
        const draftBtn = document.getElementById("acceptedTrayDraftBtn");
        if (draftBtn) {
          draftBtn.addEventListener("click", function () {
            saveTrayData(lotId, true, "Draft saved successfully!");
          });
        }

        // Submit button
        const submitBtn = document.getElementById("acceptedTraySubmitBtn");
        if (submitBtn) {
          submitBtn.addEventListener("click", function () {
            saveTrayData(lotId, false, "Accepted tray scan saved!");
          });
        }

        // Cancel button
        const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
        if (cancelBtn) {
          cancelBtn.addEventListener("click", function () {
            newPopupModal.classList.remove("open");
            window.location.reload();
          });
        }
      }

      // Add event listeners for draft mode
      function addDraftModeEventListeners(lotId) {
        // Update Draft button
        const updateDraftBtn = document.getElementById("acceptedTrayUpdateDraftBtn");
        if (updateDraftBtn) {
          updateDraftBtn.addEventListener("click", function () {
            saveTrayData(lotId, true, "Draft updated successfully!");
          });
        }
        
        // Final Submit button
        const finalSubmitBtn = document.getElementById("acceptedTrayFinalSubmitBtn");
        if (finalSubmitBtn) {
          finalSubmitBtn.addEventListener("click", function () {
            saveTrayData(lotId, false, "Final submission successful!");
          });
        }
        
        // Cancel button
        const cancelBtn = document.getElementById("acceptedTrayCancelDraftBtn");
        if (cancelBtn) {
          cancelBtn.addEventListener("click", function () {
            newPopupModal.classList.remove("open");
          });
        }
      }

// Also update the accepted tray validation section:
function addTrayIdValidation(lotId) {
  document.querySelectorAll('.accepted-tray-id-input').forEach(function(input, idx, allInputs) {
    input.addEventListener('blur', function() {
      const trayId = input.value.trim();
      const errorSpan = input.parentElement.querySelector('.tray-id-error');
      errorSpan.textContent = '';
      errorSpan.style.display = 'none';
      if (!trayId) return;

      // Check for duplicate tray ID in other rows
      let duplicateRow = null;
      allInputs.forEach(function(otherInput, otherIdx) {
        if (otherIdx !== idx && otherInput.value.trim() === trayId) {
          duplicateRow = otherInput.dataset.row;
        }
      });
      if (duplicateRow) {
        errorSpan.textContent = `Duplicate Tray ID: "${trayId}" already in row ${duplicateRow}.`;
        errorSpan.style.display = 'inline';
        return;
      }

      // ✅ FIXED: Use the nq_zone_reject_check_tray_id endpoint for consistent validation
      fetch(`/nickle_inspection_zone_two/nq_zone_reject_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(data => {
          if (!data.exists) {
            let errorMessage = `Tray ID "${trayId}" is not existing (Row ${input.dataset.row}).`;
            if (data.error) {
              if (data.error === 'Different lot') {
                errorMessage = `Tray ID "${trayId}" is not in the same lot (Row ${input.dataset.row}).`;
              } else if (data.error === 'Already rejected in Brass QC') {
                errorMessage = `Tray ID "${trayId}" is already rejected (Row ${input.dataset.row}).`;
              }
            }
            errorSpan.innerHTML = errorMessage;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            errorSpan.style.backgroundColor = '#f8d7da';
            errorSpan.style.padding = '4px 8px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.fontSize = '11px';
          
            // Highlight and focus the input
            input.style.border = '2px solid #dc3545';
            input.style.backgroundColor = '#ffebee';
            input._hasError = true;
            input.focus();
            input.select();
          }
        })
        .catch(error => {
          console.error('Error validating tray ID:', error);
          errorSpan.textContent = `Error validating Tray ID "${trayId}" (Row ${input.dataset.row}).`;
          errorSpan.style.display = 'inline';
        });
    });
  });
}

      // Helper function to save tray data
      function saveTrayData(lotId, isDraft, successMessage) {
        const rows = [];
        document.querySelectorAll('#newPopupModal .table-grid input[type="text"]').forEach((input, idx) => {
          const tray_id = input.value;
          const qtyInput = input.parentElement.nextElementSibling.querySelector('input[type="number"]');
          const tray_qty = qtyInput ? qtyInput.value : '';
          rows.push({ tray_id, tray_qty });
        });

        fetch('/nickle_inspection_zone_two/nq_zone_save_accepted_tray_scan/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({ lot_id: lotId, rows: rows, draft_save: isDraft })
        })
        .then(res => res.json())
        .then(data => {
          const msgP = document.getElementById("acceptedTrayMsg");
          if (data.success) {
            if (msgP) {
              msgP.style.color = "#388e3c";
              msgP.textContent = successMessage;
            }
            // Reload the page after a short delay for user feedback
            setTimeout(function() {
              window.location.reload();
            }, 800);
          } else {
            if (msgP) {
              msgP.style.color = "#d32f2f";
              msgP.textContent = data.error || "Failed to save";
            }
          }
        })
        .catch(error => {
          console.error('Error saving data:', error);
          const msgP = document.getElementById("acceptedTrayMsg");
          if (msgP) {
            msgP.style.color = "#d32f2f";
            msgP.textContent = "Error saving data. Please try again.";
          }
        });
      }

// Update the showEditableRejectionForm function with enhanced styling
function showEditableRejectionForm(stockLotId, batchId, detailsDiv, row) {
  // Get tray capacity from the row or fetch it
  const trayCapacityElement = row.querySelector('[data-tray-capacity]');
  const trayCapacity = trayCapacityElement ? parseInt(trayCapacityElement.getAttribute('data-tray-capacity')) : 12;
  
  const trayModal = document.getElementById("trayScanModal");
  if (trayModal) {
    trayModal.dataset.batchId = batchId;
    trayModal.dataset.stockLotId = stockLotId;
    console.log('✅ Set modal context - stockLotId:', stockLotId, 'batchId:', batchId);
  }

  // ✅ NEW: Extract quantities from the row data
  const lotQtyCell = row.cells[11]; // Lot Qty column (adjust index if needed)
  const physicalQtyCell = row.cells[12]; // Physical Qty column
  const missingQtyAttr = row.getAttribute('data-brass-missing-qty');
  
  const lotQty = lotQtyCell ? lotQtyCell.textContent.trim() : '0';
  const physicalQty = physicalQtyCell ? physicalQtyCell.textContent.trim() : '0';
  const missingQty = missingQtyAttr || '0';

  console.log('📊 Extracted quantities:', {
    lotQty,
    physicalQty, 
    missingQty,
    stockLotId
  });

  // ✅ NEW: Populate the modal header quantities AFTER modal content is set
  setTimeout(() => {
    const lotQtySpan = document.getElementById('trayScanModalLotQty');
    const missingQtySpan = document.getElementById('trayScanModalMissingQty');
    const physicalQtySpan = document.getElementById('trayScanModalPhysicalQty');
    
    if (lotQtySpan) {
      lotQtySpan.textContent = lotQty;
      console.log('✅ Set Lot Qty:', lotQty);
    }
    
    if (missingQtySpan) {
      missingQtySpan.textContent = missingQty;
      console.log('✅ Set Missing Qty:', missingQty);
    }
    
    if (physicalQtySpan) {
      physicalQtySpan.textContent = physicalQty;
      console.log('✅ Set Physical Qty:', physicalQty);
    }
  }, 100); // Small delay to ensure modal content is rendered


  // Set the inner HTML with enhanced styling
  detailsDiv.innerHTML = `
    <!-- ✅ ENHANCED: Better header section with improved visual consistency -->
    <div class="d-flex justify-content-between align-items-center mb-3" style="padding: 5px !important; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 10px; border-left: 4px solid #028084; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <h4 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 8px;">
        Rejection Reason List
      </h4>
      
      <div class="form-check d-flex align-items-center" style="margin: 0; padding: 3px 12px; background: #fff; border-radius: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
        <input class="form-check-input" type="checkbox" id="batchRejection"
               style="width: 13px; height: 13px; margin-left: 0px !important; margin-right: 8px; accent-color: #028084;" />
        <label class="form-check-label" for="batchRejection" style="font-size: 14px; font-weight: 600; color: #495057; margin: 0; cursor: pointer;">Lot Rejection</label>
      </div>
    </div>
   
    <!-- ✅ ENHANCED: Premium table design with better styling -->
    <div id="rejection-reasons-section" class="table-responsive"
         style="max-height: 320px !important; border: 1px solid #dee2e6; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); background: #fff; scrollbar-width: none; -ms-overflow-style: none; display: grid; grid-template-columns: 1fr; overflow-y: auto; overscroll-behavior: contain;">
      <table class="table table-bordered text-center mb-0" style="font-size: 13px; border-collapse: initial !important; border-color: black !important; border-spacing: 0; grid-column: 1 / -1;">
        <thead style="background: linear-gradient(135deg, #028084 0%, #0056b3 100%); position: relative;">
          <tr style="border: 1px solid #282f3a;">
            <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; width: 50px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
              <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                S.No
              </div>
            </th>
            <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); width: 65px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
              <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                Reason ID
              </div>
            </th>
            <th style="background-color: #028084 !important; padding: 12px 12px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
              <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                Rejection Reason
              </div>
            </th>
            <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); width: 75px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
              <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                Quantity
              </div>
            </th>
          </tr>
          <!-- ✅ ADD: Subtle shadow line under header -->
          <tr style="height: 2px; background: linear-gradient(90deg, transparent 0%, rgba(0,0,0,0.1) 50%, transparent 100%);"><td colspan="4" style="padding: 0; border: 1px solid #282f3a;"></td></tr>
        </thead>
        <tbody id="rejection-table-body" style="background: #fff;">
          {% for reason in nq_rejection_reasons %}
          <tr data-batch-id="${batchId}" data-stock-lot-id="${stockLotId}" style="border-bottom: 1px solid #f1f3f4; transition: all 0.2s ease;">
            <td style="padding: 8px 6px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #f1f3f4;">{{ forloop.counter }}</td>
            <td style="color: {{ reason.row_color }}; padding: 5px; font-size: 11px; font-weight: 700; border-right: 1px solid #f1f3f4; background: #fafbfc;">{{ reason.rejection_reason_id }}</td>
            <td style="color: {{ reason.row_color }}; padding: 5px; font-size: 12px; text-align: left; font-weight: 500; border-right: 1px solid #f1f3f4;">{{ reason.rejection_reason }}</td>
            <td style="padding: 6px; border-right: 1px solid #f1f3f4; background: #fafbfc;">
              <input type="number"
                     min="0"
                     class="form-control rejection-qty-input"
                     name="quantity_{{ forloop.counter }}"
                     style="width: 65px; height: 25px !important; padding: 6px !important; font-size: 12px; text-align: center; border: 2px solid #e1e5e9; border-radius: 6px; font-weight: 600; transition: all 0.3s ease;"
                     data-reason-id="{{ reason.rejection_reason_id }}" />
            </td>
          </tr>
          {% endfor %}
          <!-- ✅ ENHANCED: Total row with better styling -->
          <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-top: 3px solid #028084;">
            <td colspan="3" style="text-align: right; font-weight: 700; padding: 12px 16px; font-size: 14px; color: #495057; border-right: 1px solid #dee2e6;">
              <i class="fa fa-calculator" style="margin-right: 6px; color: #028084;"></i>
              Total Qty
            </td>
            <td id="rejection-total-qty" style="font-weight: 700; padding: 12px 16px; font-size: 16px; color: #28a745; background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); text-align: center;">0</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- ✅ ENHANCED: Better styled Rejection Tray ID Table (Initially Hidden) -->
    <div id="rejection-tray-section" style="margin-top: 20px; display: none;">
      <h5 style="margin-bottom: 15px; color: #2c3e50; text-align: right; font-weight: 600; font-size: 16px;">
        <i class="fa fa-cube" style="margin-right: 8px; color: #28a745;"></i>
        Rejection Tray ID
      </h5>
      <div class="table-responsive" style="border: 1px solid #dee2e6; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); background: #fff;">
        <table class="table table-bordered text-center mb-0" style="font-size: 13px; border-collapse: initial !important; border-color: black !important; border-spacing: 0;">
          <thead style="background: linear-gradient(135deg, #28a745 0%, #20a741 100%); position: relative;">
            <tr style="border: 1px solid #282f3a;">
              <th style="background-color: #28a745 !important; padding: 12px 8px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">S.No</th>
              <th style="background-color: #28a745 !important; padding: 12px 8px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">Tray ID</th>
              <th style="background-color: #28a745 !important; padding: 12px 8px; font-size: 12px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">Tray Qty</th>
            </tr>
          </thead>
          <tbody id="rejection-tray-table-body" style="background: #fff;">
            <!-- Dynamic rows will be added here -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- ✅ ENHANCED: Better integrated remarks section -->
    <div id="lotRejectionRemarksSection" style="display: none; margin-top: 16px; padding: 16px; border: 2px solid #28a745; border-radius: 10px; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); box-shadow: 0 4px 8px rgba(40, 167, 69, 0.1);">
      <div style="margin-bottom: 12px;">
        <label style="font-weight: 700; color: #28a745; margin-bottom: 6px; display: block; font-size: 14px; display: flex; align-items: center; gap: 6px;">
          <i class="fa fa-check-circle" style="font-size: 16px;"></i>
          Lot Rejection Remarks (Required)
        </label>
        <textarea
          id="lotRejectionRemarksInput"
          placeholder="Please provide detailed reason for lot rejection..."
          style="width: 100%; height: 70px; padding: 12px 16px; border: 2px solid #28a745; border-radius: 8px; font-size: 13px; resize: vertical; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fff; transition: all 0.3s ease;"
          maxlength="500"></textarea>
        <div style="text-align: right; margin-top: 5px; font-size: 12px; color: #6c757d;">
          <span id="remarksCharCount">0</span>/500 characters
        </div>
      </div>
      <div style="font-size: 12px; color: #155724; background-color: #d4edda; padding: 5px; border-radius: 6px; border-left: 4px solid #28a745; display: flex; align-items: center; gap: 8px;">
        <i class="fa fa-info-circle" style="font-size: 14px;"></i>
        <span><strong>Note:</strong> Lot rejection remarks are mandatory when rejecting the entire lot.</span>
      </div>
    </div>

    <div id="batchRejectionMsg" style="margin: 5px 0; color: #d32f2f; font-weight: 600; font-size: 13px; text-align: center; min-height: 20px;"></div>
   
    <!-- Simple button design -->
    <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
      <button id="draftButton" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
        Draft
      </button>
      <button id="proceedButton" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
        Proceed
      </button>
      <button id="cancelButton" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
        Cancel
      </button>
    </div>
  `;

  // Add all the existing event listeners for the editable form
  addEditableFormEventListeners(row, batchId, stockLotId, trayCapacity);
  
  // ✅ NEW: Add event listener for Lot Rejection checkbox
  const batchRejectionCheckbox = document.getElementById('batchRejection');
  const rejectionReasonsSection = document.getElementById('rejection-reasons-section');
  const lotRejectionRemarksSection = document.getElementById('lotRejectionRemarksSection');
  
  if (batchRejectionCheckbox) {
    batchRejectionCheckbox.addEventListener('change', function() {
      if (this.checked) {
        // When Lot Rejection is checked: Hide rejection reasons table, show only remarks section
        rejectionReasonsSection.style.display = 'none';
        lotRejectionRemarksSection.style.display = 'block';
        
        // Clear all rejection reason quantities when switching to lot rejection
        const qtyInputs = document.querySelectorAll('.rejection-qty-input');
        qtyInputs.forEach(input => {
          input.value = '';
        });
        
        // Update total quantity to 0
        const totalQtyElement = document.getElementById('rejection-total-qty');
        if (totalQtyElement) {
          totalQtyElement.textContent = '0';
        }
      } else {
        // When Lot Rejection is unchecked: Show rejection reasons table, hide remarks section
        rejectionReasonsSection.style.display = 'grid';
        lotRejectionRemarksSection.style.display = 'none';
        
        // Clear lot rejection remarks when switching back
        const lotRemarksInput = document.getElementById('lotRejectionRemarksInput');
        if (lotRemarksInput) {
          lotRemarksInput.value = '';
        }
      }
    });
  }
  
  // ✅ NEW: Load draft data after form is initialized
  loadDraftData(stockLotId);
}

// ✅ FIXED: Enhanced function to load draft data with proper mode handling
function loadDraftData(stockLotId) {
  console.log('🔄 Loading draft data for lot:', stockLotId);
  
  // ✅ NEW: Get all draft types for this lot
  fetch(`/nickle_inspection_zone_two/nq_zone_get_all_drafts/?lot_id=${stockLotId}`)
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        console.log('📄 Found drafts:', data);
        
        // ✅ PRIORITY: Load Lot Rejection draft first if it exists
        if (data.batch_rejection_draft) {
          console.log('📝 Loading lot rejection draft');
          loadBatchRejectionDraft(data.batch_rejection_draft.draft_data);
          return;
        }
        
        // ✅ SECONDARY: Load tray rejection draft if no Lot Rejection draft
        if (data.tray_rejection_draft) {
          console.log('📝 Loading tray rejection draft');
          loadTrayRejectionDraft(data.tray_rejection_draft.draft_data);
          return;
        }
        
        console.log('📄 No draft data found');
      }
    })
    .catch(error => {
      console.error('❌ Error loading draft data:', error);
    });
}


// ✅ FIXED: Enhanced Lot Rejection draft loading
function loadBatchRejectionDraft(draftData) {
  console.log('📝 Loading lot rejection draft data');
  
  // ✅ STEP 1: Check the Lot Rejection checkbox FIRST
  const batchRejectionCheckbox = document.getElementById("batchRejection");
  if (batchRejectionCheckbox) {
    batchRejectionCheckbox.checked = true;
    // ✅ CRITICAL: Trigger change event to show remarks section
    batchRejectionCheckbox.dispatchEvent(new Event('change'));
  }
  
  // ✅ STEP 2: Wait for remarks section to appear, then fill it
  setTimeout(() => {
    const lotRejectionRemarksInput = document.getElementById('lotRejectionRemarksInput');
    if (lotRejectionRemarksInput && draftData.lot_rejected_comment) {
      lotRejectionRemarksInput.value = draftData.lot_rejected_comment;
      lotRejectionRemarksInput.style.borderColor = '#6f42c1';
      lotRejectionRemarksInput.style.backgroundColor = '#faf8ff';
    }
    
    // Update total quantity display
    const totalQtyElement = document.getElementById('rejection-total-qty');
    if (totalQtyElement && draftData.total_qty) {
      totalQtyElement.textContent = draftData.total_qty;
      totalQtyElement.style.color = '#6f42c1';
      totalQtyElement.style.fontWeight = 'bold';
    }
    
    // Show draft indicator
    showDraftIndicator('Lot rejection draft loaded successfully', 'Batch Draft');
  }, 300);
}

// ✅ FIXED: Enhanced tray rejection draft loading
function loadTrayRejectionDraft(draftData) {
  console.log('📝 Loading tray rejection draft data');
  
  // ✅ STEP 1: ENSURE Lot Rejection checkbox is UNCHECKED
  const batchRejectionCheckbox = document.getElementById("batchRejection");
  if (batchRejectionCheckbox) {
    batchRejectionCheckbox.checked = false;
    // ✅ CRITICAL: Trigger change event to hide remarks section
    batchRejectionCheckbox.dispatchEvent(new Event('change'));
  }
  
  // ✅ STEP 2: Wait for UI to update, then load tray data
  setTimeout(() => {
    const trayRejections = draftData.tray_rejections || [];
    
    // Group rejections by reason_id
    const reasonQuantities = {};
    trayRejections.forEach(rejection => {
      if (!reasonQuantities[rejection.reason_id]) {
        reasonQuantities[rejection.reason_id] = 0;
      }
      reasonQuantities[rejection.reason_id] += parseInt(rejection.qty) || 0;
    });
    
    // Fill in the quantity inputs with visual feedback
    Object.keys(reasonQuantities).forEach(reasonId => {
      const qtyInput = document.querySelector(`input[data-reason-id="${reasonId}"]`);
      if (qtyInput) {
        qtyInput.value = reasonQuantities[reasonId];
        qtyInput.style.borderColor = '#6f42c1';
        qtyInput.style.backgroundColor = '#faf8ff';
        qtyInput.dispatchEvent(new Event('input'));
      }
    });
    
    // Show draft indicator
    showDraftIndicator('Tray rejection draft loaded successfully', 'Tray Draft');
    
    // Load tray IDs if they exist
    setTimeout(() => {
      loadDraftTrayIds(trayRejections);
    }, 500);
  }, 300);
}

// ✅ NEW: Enhanced checkbox event handler to clear remarks when unchecking
function addEnhancedCheckboxHandler() {
  const batchRejectionCheckbox = document.getElementById("batchRejection");
  const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");
  
  if (batchRejectionCheckbox && lotRejectionRemarksSection) {
    // Remove existing listeners
    const newCheckbox = batchRejectionCheckbox.cloneNode(true);
    batchRejectionCheckbox.parentNode.replaceChild(newCheckbox, batchRejectionCheckbox);
    
    // Add enhanced event listener
    newCheckbox.addEventListener("change", function () {
      const rejectionTableBody = document.getElementById("rejection-table-body");
      const traySection = document.getElementById("rejection-tray-section");
      const inputs = rejectionTableBody ? rejectionTableBody.querySelectorAll("input") : [];
      const trayInputs = document.querySelectorAll("#rejection-tray-table-body input");
      
      if (this.checked) {
        // ✅ SHOW remarks section
        lotRejectionRemarksSection.style.display = "block";
        setTimeout(() => {
          lotRejectionRemarksSection.style.transition = "all 0.3s ease";
          lotRejectionRemarksSection.style.opacity = "1";
          lotRejectionRemarksSection.style.transform = "translateY(0)";
        }, 50);
        
        // Disable all inputs and clear values
        inputs.forEach(input => {
          input.disabled = true;
          input.value = "";
        });
        trayInputs.forEach(input => {
          input.disabled = true;
          input.value = "";
        });
        
        document.getElementById('rejection-total-qty').textContent = "0";
        
        // Hide tray section completely
        if (traySection) {
          traySection.style.display = 'none';
        }
        
      } else {
        // ✅ HIDE remarks section AND CLEAR REMARKS
        lotRejectionRemarksSection.style.transition = "all 0.3s ease";
        lotRejectionRemarksSection.style.opacity = "0";
        lotRejectionRemarksSection.style.transform = "translateY(-10px)";
        setTimeout(() => {
          lotRejectionRemarksSection.style.display = "none";
          
          // ✅ CRITICAL: Clear the remarks input when hiding
          const lotRejectionRemarksInput = document.getElementById("lotRejectionRemarksInput");
          if (lotRejectionRemarksInput) {
            lotRejectionRemarksInput.value = "";
            lotRejectionRemarksInput.style.borderColor = "";
            lotRejectionRemarksInput.style.backgroundColor = "";
          }
        }, 300);
        
        // Enable inputs
        inputs.forEach(input => {
          input.disabled = false;
        });
      }
    });
  }
}
// Function to load draft tray IDs
function loadDraftTrayIds(trayRejections) {
  const trayTableBody = document.getElementById('rejection-tray-table-body');
  if (!trayTableBody) {
    // Table not ready, retry after a short delay
    setTimeout(() => loadDraftTrayIds(trayRejections), 100);
    return;
  }
  
  const trayRows = trayTableBody.querySelectorAll('tr');
  if (trayRows.length === 0) {
    // Table not populated yet, retry
    setTimeout(() => loadDraftTrayIds(trayRejections), 100);
    return;
  }
  
  let rejectionIndex = 0;
  
  trayRows.forEach((row, index) => {
    if (rejectionIndex < trayRejections.length) {
      const rejection = trayRejections[rejectionIndex];
      
      // Set reason_id
      const reasonSelect = row.querySelector('select[name="reason_id"]');
      if (reasonSelect && rejection.reason_id) {
        reasonSelect.value = rejection.reason_id;
      }
      
      // Set qty
      const qtyInput = row.querySelector('input[name="qty"]');
      if (qtyInput && rejection.qty) {
        qtyInput.value = rejection.qty;
      }
      
      // Set tray_id
      const trayInput = row.querySelector('input[name="tray_id"]');
      if (trayInput && rejection.tray_id) {
        trayInput.value = rejection.tray_id;
      }
      
      rejectionIndex++;
    }
  });
}

// Function to show draft indicator
function showDraftIndicator(message) {
  const msgDiv = document.getElementById("batchRejectionMsg");
  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.innerHTML = `<i class="fa fa-info-circle"></i> ${message}`;
    
    // Hide the message after 3 seconds
    setTimeout(() => {
      msgDiv.textContent = "";
    }, 3000);
  }
}

      // Updated addEditableFormEventListeners function
      function addEditableFormEventListeners(row, batchId, stockLotId, trayCapacity) {
        const availableQty = parseInt(row.getAttribute('data-available-qty'), 10) || 0;

// ✅ CORRECTED: Get tray capacity from MODAL CONTEXT (correct lot_id)
function updateRejectionTrayTable(totalQty) {
  const trayTableBody = document.getElementById('rejection-tray-table-body');
  const traySection = document.getElementById('rejection-tray-section');
  
  if (!trayTableBody || !traySection) return;

  // Clear existing rows
  trayTableBody.innerHTML = '';

  if (totalQty > 0) {
    // Show the tray section when there's quantity
    traySection.style.display = 'block';
    
    // ✅ CORRECT METHOD: Get lot_id from modal context (not random row)
    const trayModal = document.getElementById("trayScanModal");
    let stockLotId = null;
    let currentRow = null;
    
    if (trayModal && trayModal.dataset.stockLotId) {
      stockLotId = trayModal.dataset.stockLotId;
      console.log('✅ Got CORRECT lot_id from modal:', stockLotId);
      
      // Now find the CORRECT row using this lot_id
      currentRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
      if (currentRow) {
        console.log('✅ Found CORRECT row for lot_id:', stockLotId);
      }
    }
    
    // ✅ Fallback: if modal doesn't have lot_id, try to find highlighted row
    if (!currentRow) {
      currentRow = document.querySelector('tr.highlighted-tray-scan');
      if (currentRow) {
        stockLotId = currentRow.getAttribute('data-stock-lot-id');
        console.log('✅ Fallback: got lot_id from highlighted row:', stockLotId);
      }
    }
    
    if (!currentRow) {
      console.error('❌ Could not find correct row for modal context');
      return;
    }
    
    // ✅ Method 1: Get from "Tray Cate-Capacity" column (column 8)
    let trayCapacity = null;
    const trayCapacityCell = currentRow.cells[8]; // "Tray Cate-Capacity" column
    if (trayCapacityCell) {
      const trayCapacityText = trayCapacityCell.textContent.trim();
      console.log('🔍 Tray capacity cell text:', trayCapacityText);
      
      // Extract capacity from "Normal-16" format
      if (trayCapacityText.includes('-')) {
        const parts = trayCapacityText.split('-');
        if (parts.length >= 2) {
          trayCapacity = parseInt(parts[1]);
          console.log('✅ Extracted tray capacity from CORRECT row:', trayCapacity);
        }
      }
    }
    
    // ✅ Method 2: Fallback - check data attributes
    if (!trayCapacity || isNaN(trayCapacity)) {
      const trayScanBtn = currentRow.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
      if (trayScanBtn) {
        const capacityAttr = trayScanBtn.getAttribute('data-tray-capacity');
        if (capacityAttr) {
          trayCapacity = parseInt(capacityAttr);
          console.log('✅ Got tray capacity from data attribute:', trayCapacity);
        }
      }
    }
    
    // ✅ Final validation
    if (!trayCapacity || isNaN(trayCapacity) || trayCapacity <= 0) {
      console.error('❌ Could not determine tray capacity, using fallback');
      trayCapacity = 12; // Only if absolutely no other option
    }
    
    console.log('🎯 FINAL tray capacity for lot_id', stockLotId, ':', trayCapacity);
    
    // ✅ CORRECTED CALCULATION: Remainder FIRST, then full trays
    const remainder = totalQty % trayCapacity;
    const fullTrays = Math.floor(totalQty / trayCapacity);
    
    console.log(`📊 Calculation for lot_id ${stockLotId}: ${totalQty} ÷ ${trayCapacity} = ${fullTrays} full trays + ${remainder} remainder`);
    
    // ✅ Build quantities array with REMAINDER FIRST
    const trayQuantities = [];
    
    // Add remainder tray FIRST (if exists)
    if (remainder > 0) {
      trayQuantities.push(remainder);
    }
    
    // Add full capacity trays
    for (let i = 0; i < fullTrays; i++) {
      trayQuantities.push(trayCapacity);
    }
    
    console.log('✅ CORRECTED tray quantities:', trayQuantities);
    console.log(`📝 Example: qty=${totalQty}, capacity=${trayCapacity} → [${trayQuantities.join(', ')}] (remainder first!)`);

    // ✅ Create rows with CORRECTED quantities
    trayQuantities.forEach((trayQty, index) => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${index + 1}</td>
        <td>
          <input type="text" 
                 class="form-control tray-id-input rejection-tray-id-input" 
                 placeholder="Scan Tray ID" 
                 style="width: 120px;" 
                 data-tray-index="${index + 1}" 
                 data-tray-qty="${trayQty}"
                 data-tray-capacity="${trayCapacity}"
                 data-rejection-qty="${totalQty}" />
          <div class="tray-id-error rejection-tray-error" style="color: #d32f2f; font-size: 11px; display: none; margin-top: 2px; padding: 2px 4px; background: #ffebee; border-radius: 3px;"></div>
        </td>
        <td>${trayQty}</td>
      `;
      trayTableBody.appendChild(row);
    });

    // ✅ Re-attach validation after creating new inputs
    addSimpleTableTrayValidation();
    
  } else {
    // Hide the tray section when there's no quantity
    traySection.style.display = 'none';
  }
}

// ✅ COMPLETELY FIXED: Direct tray-to-quantity mapping (no redistribution)
// ✅ COMPLETELY FIXED: handleTrayWiseRejection function with proper distribution logic
function handleTrayWiseRejection() {
  const msgDiv = document.getElementById("batchRejectionMsg");
  const trayModal = document.getElementById("trayScanModal");
  const batchId = trayModal.dataset.batchId;
  const lotId = trayModal.dataset.stockLotId;
  const rows = document.querySelectorAll("#rejection-table-body tr");
  const trayRows = document.querySelectorAll("#rejection-tray-table-body tr");
  
  let tray_rejections = [];
  
  // Enhanced validation logic
  const totalRejectionQty = parseInt(document.getElementById('rejection-total-qty').textContent) || 0;
  
  if (totalRejectionQty <= 0) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Please enter rejection quantities first.";
    }
    document.getElementById("proceedButton").disabled = false;
    return;
  }
  
  if (totalRejectionQty > 0 && trayRows.length === 0) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Please enter tray IDs for the rejected quantities.";
    }
    document.getElementById("proceedButton").disabled = false;
    return;
  }

  // ✅ STEP 1: Collect all rejection reasons with quantities
  const rejectionReasons = [];
  rows.forEach(row => {
    const qtyInput = row.querySelector('input.rejection-qty-input');
    if (qtyInput) {
      const reason_id = row.querySelectorAll("td")[1].textContent.trim();
      const qty = parseInt(qtyInput.value.trim()) || 0;
      
      if (qty > 0) {
        rejectionReasons.push({
          reason_id: reason_id,
          quantity: qty
        });
      }
    }
  });

  // ✅ STEP 2: Collect available trays with their capacities and validate them
  const availableTrays = [];
  let hasInvalidTrayId = false;
  let invalidTrayIdMessage = '';
  let hasQuantityWithoutTrayId = false;
  let missingTrayIdMessage = '';
  
  trayRows.forEach((row, index) => {
    const trayInput = row.querySelector('input.tray-id-input') || row.querySelector('input.rejection-tray-id-input');
    const trayQtyCell = row.cells[2];
    const trayCapacity = parseInt(trayQtyCell.textContent) || 0;
    
    if (trayCapacity > 0) {
      const trayId = trayInput ? trayInput.value.trim() : '';
      
      if (!trayId) {
        hasQuantityWithoutTrayId = true;
        missingTrayIdMessage = `Tray ID is required for row ${index + 1} (Capacity: ${trayCapacity}).`;
      } else {
        const errorDiv = trayInput.parentElement.querySelector('.tray-id-error') || 
                         trayInput.parentElement.querySelector('.rejection-tray-error');
        
        // Check validation status
        let isInvalid = false;
        const inputHasError = trayInput._hasError === true;
        const isValidating = trayInput._isValidating === true;
        const hasRedBorder = trayInput.style.border && trayInput.style.border.includes('dc3545');
        const hasGreenBorder = trayInput.style.border && trayInput.style.border.includes('28a745');
        
        let hasErrorMessage = false;
        let hasSuccessMessage = false;
        
        if (errorDiv && errorDiv.style.display !== 'none' && errorDiv.textContent) {
          const errorText = errorDiv.textContent.toLowerCase();
          hasErrorMessage = errorText.includes('❌') || 
                           errorText.includes('invalid') || 
                           errorText.includes('error') ||
                           errorText.includes('duplicate');
          hasSuccessMessage = errorText.includes('✅') || 
                             errorText.includes('available') || 
                             errorText.includes('new tray');
        }
        
        if (inputHasError && !hasSuccessMessage) {
          isInvalid = true;
        } else if (hasRedBorder && !hasGreenBorder && !hasSuccessMessage) {
          isInvalid = true;
        } else if (hasErrorMessage && !hasSuccessMessage) {
          isInvalid = true;
        } else if (isValidating) {
          if (msgDiv) {
            msgDiv.style.color = "#007bff";
            msgDiv.textContent = `Please wait, validating tray "${trayId}" in row ${index + 1}...`;
          }
          document.getElementById("proceedButton").disabled = false;
          return;
        }
        
        if (isInvalid) {
          hasInvalidTrayId = true;
          invalidTrayIdMessage = `Invalid Tray ID "${trayId}" in row ${index + 1}.`;
        } else {
          // ✅ Add tray to available list with remaining capacity tracking
          availableTrays.push({
            tray_id: trayId,
            capacity: trayCapacity,
            remaining_capacity: trayCapacity, // Track remaining capacity for distribution
            row_index: index + 1
          });
        }
      }
    }
  });
  
  // Show validation errors
  if (hasQuantityWithoutTrayId) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = missingTrayIdMessage;
    }
    document.getElementById("proceedButton").disabled = false;
    return;
  }
  
  if (hasInvalidTrayId) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = invalidTrayIdMessage;
    }
    document.getElementById("proceedButton").disabled = false;
    return;
  }

  // ✅ STEP 3: Check if total available capacity is sufficient
  const totalAvailableCapacity = availableTrays.reduce((sum, tray) => sum + tray.capacity, 0);
  if (totalRejectionQty > totalAvailableCapacity) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = `Total rejection quantity (${totalRejectionQty}) exceeds total tray capacity (${totalAvailableCapacity}).`;
    }
    document.getElementById("proceedButton").disabled = false;
    return;
  }

  // ✅ STEP 4: Distribute rejection reasons across available trays
  console.log('🚀 Starting rejection distribution...');
  console.log('📊 Rejection reasons:', rejectionReasons);
  console.log('📦 Available trays:', availableTrays);

  for (const rejection of rejectionReasons) {
    let remainingQtyToDistribute = rejection.quantity;
    
    console.log(`📝 Distributing ${remainingQtyToDistribute} units of reason ${rejection.reason_id}`);
    
    // ✅ NEW LOGIC: Distribute this rejection reason across available trays
    for (const tray of availableTrays) {
      if (remainingQtyToDistribute <= 0) break;
      
      if (tray.remaining_capacity > 0) {
        const qtyForThisTray = Math.min(remainingQtyToDistribute, tray.remaining_capacity);
        
        // Create rejection record for this portion
        tray_rejections.push({
          reason_id: rejection.reason_id,
          qty: qtyForThisTray,
          tray_id: tray.tray_id
        });
        
        // Update remaining capacities
        remainingQtyToDistribute -= qtyForThisTray;
        tray.remaining_capacity -= qtyForThisTray;
        
        console.log(`✅ Assigned ${qtyForThisTray} of reason ${rejection.reason_id} to tray ${tray.tray_id}`);
        console.log(`   Tray ${tray.tray_id} remaining capacity: ${tray.remaining_capacity}`);
      }
    }
    
    // ✅ Check if we couldn't distribute all quantity for this reason
    if (remainingQtyToDistribute > 0) {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = `Insufficient tray capacity for rejection reason ${rejection.reason_id}. Missing ${remainingQtyToDistribute} units.`;
      }
      document.getElementById("proceedButton").disabled = false;
      return;
    }
  }
  
  if (!tray_rejections.length) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Enter at least one tray qty and tray id.";
    }
    document.getElementById("proceedButton").disabled = false;
    return;
  }
  
  console.log('🚀 Final tray rejections to send:', tray_rejections);
  
  // ✅ STEP 5: Send the rejection data to backend
  fetch('/nickle_inspection_zone_two/nq_zone_tray_rejection/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: lotId,
      batch_id: batchId,
      tray_rejections: tray_rejections
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      // Disable fields on success
      rows.forEach(row => {
        const qtyInput = row.querySelector('input.rejection-qty-input');
        if (qtyInput) qtyInput.disabled = true;
      });
      
      trayRows.forEach(row => {
        const trayInput = row.querySelector('input.tray-id-input') || row.querySelector('input.rejection-tray-id-input');
        if (trayInput) trayInput.disabled = true;
      });
      
      window.trayRejectionSaved = true;
      
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = `Tray rejection saved! (${tray_rejections.length} records created)`;
      }
      
// ✅ ENHANCED: Auto-trigger accepted tray modal with conditional logic
// ✅ ENHANCED: Auto-trigger accepted tray modal with conditional logic for delink-only
setTimeout(() => {
  console.log('🎯 Auto-triggering accepted tray modal after rejection save...');
  
  // ✅ NEW: Calculate total rejection quantity and available quantity
  const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
  const availableQty = currentRow ? parseInt(currentRow.getAttribute('data-available-qty')) || 0 : 0;
  
  // Calculate total rejection quantity from all rejection reasons
  let totalRejectionQty = 0;
  const rejectionInputs = document.querySelectorAll('.rejection-qty-input');
  rejectionInputs.forEach(input => {
    const qty = parseInt(input.value) || 0;
    if (qty > 0) {
      totalRejectionQty += qty;
    }
  });
  
  console.log(`📊 Quantity Analysis: Available=${availableQty}, Rejected=${totalRejectionQty}`);
  
  fetch(`/nickle_inspection_zone_two/nq_zone_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(rescanData => {
      if (rescanData.success) {
        console.log('✅ Fetched accepted tray data:', rescanData);
        
        // ✅ NEW: Handle delink-only case (when all pieces rejected)
        if (rescanData.is_delink_only) {
          console.log('🎯 DELINK-ONLY case detected: All pieces rejected');
          
          // Check for delink availability
          return fetch(`/nickle_inspection_zone_two/nq_zone_get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`)
            .then(delinkRes => delinkRes.json())
            .then(delinkData => {
              const hasDelinkTrays = delinkData.success && delinkData.delink_trays && delinkData.delink_trays.length > 0;
              
              console.log(`🔍 Delink Analysis for ALL REJECTED: Has delink trays = ${hasDelinkTrays}`);
              
              if (hasDelinkTrays) {
                // Show modal with ONLY delink table (no top tray section)
                console.log('🎯 All rejected + delink available - showing delink-only modal');
                showAcceptedTrayModal(rescanData, lotId, false, true); // true = delink only mode
              } else {
                // No delink needed - just reload
                console.log('🎯 All rejected + no delink - reloading page');
                trayModal.classList.remove("open");
                setTimeout(() => {
                  window.location.reload();
                }, 500);
              }
            });
        }
        
        // ✅ EXISTING: Normal logic for partial rejections
        // ✅ NEW: Check for delink availability for partial rejections
        return fetch(`/nickle_inspection_zone_two/nq_zone_get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`)
          .then(delinkRes => delinkRes.json())
          .then(delinkData => {
            const hasDelinkTrays = delinkData.success && delinkData.delink_trays && delinkData.delink_trays.length > 0;
            
            console.log(`🔍 Delink Analysis: Has delink trays = ${hasDelinkTrays}`);
            
            // ✅ CONDITIONAL LOGIC:
            if (availableQty === totalRejectionQty) {
              if (hasDelinkTrays) {
                // Case 1: Equal quantities + delink available = Show modal with ONLY delink table
                console.log('🎯 Case 1: Equal qty + delink available - showing modal with delink only');
                showAcceptedTrayModal(rescanData, lotId, rescanData.has_draft, true); // true = delink only mode
              } else {
                // Case 2: Equal quantities + no delink = Don't show modal
                console.log('🎯 Case 2: Equal qty + no delink - not showing modal');
                trayModal.classList.remove("open");
                setTimeout(() => {
                  window.location.reload();
                }, 500);
              }
            } else if (availableQty > totalRejectionQty) {
              // Case 3: Available > Rejected = Show full modal (normal behavior)
              console.log('🎯 Case 3: Available > Rejected - showing full modal');
              const hasDraft = rescanData.has_draft;
              showAcceptedTrayModal(rescanData, lotId, hasDraft, false); // false = full modal
            } else {
              // Case 4: Available < Rejected (shouldn't happen, but handle gracefully)
              console.log('🎯 Case 4: Available < Rejected - showing full modal as fallback');
              const hasDraft = rescanData.has_draft;
              showAcceptedTrayModal(rescanData, lotId, hasDraft, false);
            }
            
            console.log('🚀 Accepted tray modal logic completed');
          });
      } else {
        console.error('❌ Failed to fetch accepted tray data:', rescanData.error);
        trayModal.classList.remove("open");
        setTimeout(() => {
          window.location.reload();
        }, 500);
      }
    })
    .catch(error => {
      console.error('❌ Network error fetching accepted tray data:', error);
      trayModal.classList.remove("open");
      setTimeout(() => {
        window.location.reload();
      }, 500);
    });
}, 1000);
      
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save tray rejection";
      }
      document.getElementById("proceedButton").disabled = false;
    }
  })
  .catch((error) => {
    console.error('Request failed:', error);
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error";
    }
    document.getElementById("proceedButton").disabled = false;
  });
}
// ✅ UPDATED: Enhanced tray validation with proper new tray handling
function addSimpleTableTrayValidation() {
  console.log('🔧 Adding simple table tray validation...');
  
  // ✅ Use both class names to ensure we catch all inputs
  const trayInputs = document.querySelectorAll('#rejection-tray-table-body .tray-id-input, #rejection-tray-table-body .rejection-tray-id-input');
  
  trayInputs.forEach(function(input, idx) {
    // Remove existing event listeners
    if (input._blurHandler) input.removeEventListener('blur', input._blurHandler);
    if (input._inputHandler) input.removeEventListener('input', input._inputHandler);
    if (input._keydownHandler) input.removeEventListener('keydown', input._keydownHandler);
    
    // Track validation state
    input._hasError = false;
    input._isValidating = false;
    
    // ✅ Use correct error div selector
    const getErrorDiv = () => {
      return input.parentElement.querySelector('.tray-id-error') || 
             input.parentElement.querySelector('.rejection-tray-error');
    };
    
    // Input event for clearing errors
    input._inputHandler = function() {
      this._hasError = false;
      const errorDiv = getErrorDiv();
      if (errorDiv) {
        errorDiv.style.display = 'none';
        errorDiv.textContent = '';
      }
      // Reset input styling
      this.style.border = '';
      this.style.backgroundColor = '';
    };
    input.addEventListener('input', input._inputHandler);
    
    // Keydown handler for Enter key
    input._keydownHandler = function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        
        if (this._hasError || this._isValidating || !this.value.trim()) {
          return;
        }
        
        const nextInput = trayInputs[idx + 1];
        if (nextInput) {
          nextInput.focus();
        }
      }
    };
    input.addEventListener('keydown', input._keydownHandler);
    
    // ✅ UPDATED: Enhanced blur handler with proper new tray detection
    input._blurHandler = function() {
      const trayId = this.value.trim();
      const errorDiv = getErrorDiv();
      
      // Clear previous state
      this._hasError = false;
      this._isValidating = false;
      if (errorDiv) {
        errorDiv.textContent = '';
        errorDiv.style.display = 'none';
      }
      this.style.border = '';
      this.style.backgroundColor = '';
      
      if (!trayId) return;
      
      // ✅ DUPLICATE CHECK: Check for duplicates within the table
      let isDuplicate = false;
      trayInputs.forEach(function(otherInput) {
        if (otherInput !== input && otherInput.value.trim() === trayId) {
          isDuplicate = true;
        }
      });
      
      if (isDuplicate) {
        this._hasError = true;
        this.style.border = '2px solid #dc3545';
        this.style.backgroundColor = '#ffebee';
        if (errorDiv) {
          errorDiv.textContent = '❌ Duplicate Tray ID';
          errorDiv.style.display = 'block';
          errorDiv.style.color = '#721c24';
          errorDiv.style.backgroundColor = '#f8d7da';
        }
        
        setTimeout(() => {
          this.value = '';
          this._hasError = false;
          if (errorDiv) errorDiv.style.display = 'none';
          this.style.border = '';
          this.style.backgroundColor = '';
          this.focus();
        }, 2000);
        return;
      }
      
      // Set validating state
      this._isValidating = true;
      if (errorDiv) {
        errorDiv.textContent = 'Validating...';
        errorDiv.style.display = 'block';
        errorDiv.style.color = '#007bff';
        errorDiv.style.backgroundColor = '#e3f2fd';
      }
      
      // ✅ PROGRESSIVE VALIDATION: Get context for THIS specific tray
      const modal = document.getElementById("trayScanModal");
      const currentLotId = modal?.dataset?.stockLotId;

      if (!currentLotId) {
        input._hasError = true;
        if (errorDiv) {
          errorDiv.textContent = '❌ Lot ID not found';
          errorDiv.style.display = 'block';
          errorDiv.style.color = '#721c24';
          errorDiv.style.backgroundColor = '#f8d7da';
        }
        if (callback) callback(false);
        return;
      }
      const individualTrayQty = parseInt(this.getAttribute('data-tray-qty')) || 0;
      
      // ✅ Get progressive session allocations (only up to current row)
      const progressiveSessionAllocations = collectSimpleTableSessionAllocations(this);
      
      const rejectionContext = {
        tray_id: trayId,
        lot_id: currentLotId,
        rejection_qty: individualTrayQty,
        current_session_allocations: JSON.stringify(progressiveSessionAllocations)
      };
      
      console.log(`🔍 [Progressive Validation Row ${idx + 1}] Context:`, rejectionContext);
      console.log(`🔍 [Progressive Validation Row ${idx + 1}] This tray qty: ${individualTrayQty}`);
      console.log(`🔍 [Progressive Validation Row ${idx + 1}] Previous allocations:`, progressiveSessionAllocations);
      
      const queryParams = new URLSearchParams(rejectionContext).toString();
      
      // Call validation endpoint
      fetch(`/nickle_inspection_zone_two/nq_zone_reject_check_tray_id_simple/?${queryParams}`)
        .then(res => res.json())
        .then(data => {
          this._isValidating = false;
      
          console.log(`🔍 [Progressive Validation Row ${idx + 1}] Response:`, data);
      
          if (errorDiv) {
            if (data.exists && data.valid_for_rejection) {
              // ✅ SUCCESS - Including new trays
              this._hasError = false;
      
              let successMessage = `✅ ${data.status_message || 'Available'}`;
      
              // Add rearrangement details if available
              if (data.validation_type === 'existing_sufficient_space' && data.rearrangement_plan) {
                successMessage += ` (Plan: [${data.rearrangement_plan.join(', ')}])`;
              }
      
              errorDiv.textContent = successMessage;
              errorDiv.style.display = 'block';
              errorDiv.style.color = '#155724';
              errorDiv.style.backgroundColor = '#d4edda';
      
              // ✅ FIXED: Style input as valid (green border for both existing and new trays)
              this.style.border = '2px solid #28a745';
              this.style.backgroundColor = '#f8fff8';
      
              // Auto-hide success message
              setTimeout(() => {
                if (errorDiv) errorDiv.style.display = 'none';
              }, 4000);
      
            } else {
              // ❌ ERROR
              this._hasError = true;
      
              let errorMessage = `❌ ${data.status_message || 'Invalid tray ID'}`;
      
              // Add specific error context
              if (data.validation_type === 'existing_no_space') {
                errorMessage += ' (Need NEW tray)';
              } else if (data.validation_type === 'existing_insufficient') {
                errorMessage += ` (Have ${data.total_current}, need ${individualTrayQty})`;
              }
      
              errorDiv.textContent = errorMessage;
              errorDiv.style.display = 'block';
              errorDiv.style.color = '#721c24';
              errorDiv.style.backgroundColor = '#f8d7da';
      
              // Style input as invalid
              this.style.border = '2px solid #dc3545';
              this.style.backgroundColor = '#ffebee';
      
              // Do NOT auto-clear, keep error and focus/select input for correction
              this.focus();
              this.select();
            }
          }
        })
        .catch(error => {
          this._isValidating = false;
          this._hasError = true;
          console.error(`Progressive tray validation error for row ${idx + 1}:`, error);
      
          if (errorDiv) {
            errorDiv.textContent = '❌ Connection Error';
            errorDiv.style.display = 'block';
            errorDiv.style.color = '#721c24';
            errorDiv.style.backgroundColor = '#f8d7da';
      
            // Do NOT auto-clear, keep error and focus/select input for correction
            this.focus();
            this.select();
          }
        });
      };
    input.addEventListener('blur', input._blurHandler);
  });
}

// ✅ COMPLETE: Progressive session collection for multiple rejection rows
function collectSimpleTableSessionAllocations(excludeInput) {
  const allocations = [];
  
  console.log('📊 [Progressive Collection] Starting...');
  
  // ✅ STEP 1: Get the current input's row index to determine which rejections came before
  const trayInputs = Array.from(document.querySelectorAll('#rejection-tray-table-body .tray-id-input, #rejection-tray-table-body .rejection-tray-id-input'));
  const currentInputIndex = trayInputs.indexOf(excludeInput);
  
  console.log(`📊 [Progressive Collection] Current input index: ${currentInputIndex} of ${trayInputs.length}`);
  
  // ✅ STEP 2: Collect ALL rejection quantities from the rejection reasons table
  const rejectionQuantities = [];
  document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
    const qty = parseInt(qtyInput.value) || 0;
    const reasonId = qtyInput.getAttribute('data-reason-id');
    const row = qtyInput.closest('tr');
    
    if (qty > 0 && row) {
      const reasonCell = row.cells[2];
      const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
      
      // Skip SHORTAGE - it doesn't consume existing trays
      if (reasonText === 'SHORTAGE') {
        console.log(`📊 [Progressive Collection] Skipping SHORTAGE reason ${reasonId}`);
        return;
      }
      
      rejectionQuantities.push({
        reason_id: reasonId,
        reason_text: reasonText,
        qty: qty
      });
      
      console.log(`📊 [Progressive Collection] Found rejection: reason=${reasonText}, qty=${qty}`);
    }
  });
  
  // ✅ STEP 3: Map tray inputs to their corresponding rejection quantities
  let trayIndexCounter = 0;
  for (const rejection of rejectionQuantities) {
    const rejectionQty = rejection.qty;
    
    // Calculate how many trays this rejection needs
    const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                       document.querySelector('[data-stock-lot-id]') ||
                       document.querySelector('tbody tr');
    let trayCapacity = 12; // Default
    if (currentRow) {
      const trayCapacityText = currentRow.cells[7]?.textContent || '';
      if (trayCapacityText.includes('-')) {
        trayCapacity = parseInt(trayCapacityText.split('-')[1]) || 12;
      }
    }
    
    const numTraysNeeded = Math.ceil(rejectionQty / trayCapacity);
    
    // ✅ STEP 4: Check if these trays are BEFORE the current input being validated
    const collectedTrayIds = [];
    for (let i = 0; i < numTraysNeeded && trayIndexCounter < currentInputIndex; i++) {
      if (trayIndexCounter < trayInputs.length) {
        const trayInput = trayInputs[trayIndexCounter];
        const trayId = trayInput.value.trim();
        
        if (trayId) {
          collectedTrayIds.push(trayId);
          console.log(`📊 [Progressive Collection] Added tray ${trayId} for rejection ${rejection.reason_text}`);
        }
      }
      trayIndexCounter++;
    }
    
    // ✅ STEP 5: Only add to allocations if this rejection is COMPLETELY before current input
    if (collectedTrayIds.length === numTraysNeeded) {
      allocations.push({
        reason_id: rejection.reason_id,
        reason_text: rejection.reason_text,
        qty: rejectionQty,
        tray_ids: collectedTrayIds
      });
      console.log(`📊 [Progressive Collection] COMPLETED rejection: ${rejection.reason_text}, qty=${rejectionQty}, trays=${collectedTrayIds}`);
    } else {
      console.log(`📊 [Progressive Collection] INCOMPLETE rejection: ${rejection.reason_text}, need ${numTraysNeeded} trays, have ${collectedTrayIds.length}`);
      // This rejection is partially or completely AFTER current input, so don't include it
      break; // Stop processing further rejections
    }
  }
  
  console.log('📊 [Progressive Collection] FINAL allocations:', allocations);
  return allocations;
}

// ✅ Helper function to get current lot ID
function getCurrentLotId() {
  const modal = document.getElementById("trayScanModal");
  if (modal && modal.dataset.stockLotId) return modal.dataset.stockLotId;
  const lastBtn = document.querySelector('.tray-scan-btn[data-stock-lot-id]');
  return lastBtn ? lastBtn.getAttribute('data-stock-lot-id') : '';
}


        // Quantity input change listener with tray table update
        document.querySelectorAll('.rejection-qty-input').forEach(function(input, idx, allInputs) {
          input.addEventListener('input', function() {
            // Remove all previous qty errors
            document.querySelectorAll('.qty-error').forEach(function(span) { span.remove(); });
          
            // Restrict this input to not exceed availableQty
            let enteredValue = parseInt(this.value) || 0;
            if (enteredValue > availableQty) {
              this.value = availableQty;
              enteredValue = availableQty;
            }
          
            let total = 0;
            let errorRow = null;
            let errorInput = null;
          
            // Calculate running total and find the first row that exceeds
            allInputs.forEach(function(qtyInput, i) {
              const val = parseInt(qtyInput.value) || 0;
              total += val;
              if (!errorRow && total > availableQty) {
                errorRow = i + 1;
                errorInput = qtyInput;
              }
            });
          
            document.getElementById('rejection-total-qty').textContent = total;
          
            // Update rejection tray table based on total quantity
            updateRejectionTrayTable(total);
          
            // Show error below the input if exceeded
            if (errorInput) {
              let errorSpan = document.createElement('span');
              errorSpan.className = 'qty-error';
              errorSpan.style.color = '#d32f2f';
              errorSpan.style.fontSize = '12px';
              errorSpan.style.display = 'block';
              errorSpan.style.marginTop = '2px';
              errorSpan.textContent = `Row ${errorRow}: Quantity exceeds available (${availableQty}).`;
              errorInput.parentElement.appendChild(errorSpan);
            }
          });
        });


        // Batch
        //  rejection checkbox event listener
        const batchRejectionCheckbox = document.getElementById("batchRejection");
        const rejectionTableBody = document.getElementById("rejection-table-body");
        const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");
        const traySection = document.getElementById("rejection-tray-section");
        
        if (batchRejectionCheckbox && rejectionTableBody) {
          batchRejectionCheckbox.addEventListener("change", function () {
            const inputs = rejectionTableBody.querySelectorAll("input");
            const trayInputs = document.querySelectorAll("#rejection-tray-table-body input");
            
            if (this.checked) {
              // Show remarks section
              if (lotRejectionRemarksSection) {
                lotRejectionRemarksSection.style.display = "block";
                setTimeout(() => {
                  lotRejectionRemarksSection.style.transition = "all 0.3s ease";
                  lotRejectionRemarksSection.style.opacity = "1";
                  lotRejectionRemarksSection.style.transform = "translateY(0)";
                }, 50);
              }
              
              // Disable all inputs and clear values
              inputs.forEach(input => {
                input.disabled = true;
                input.value = "";
              });
              trayInputs.forEach(input => {
                input.disabled = true;
                input.value = "";
              });
              
              document.getElementById('rejection-total-qty').textContent = "0";
              
              // Hide tray section completely
              if (traySection) {
                traySection.style.display = 'none';
              }
              
            } else {
              // Hide remarks section
              if (lotRejectionRemarksSection) {
                lotRejectionRemarksSection.style.transition = "all 0.3s ease";
                lotRejectionRemarksSection.style.opacity = "0";
                lotRejectionRemarksSection.style.transform = "translateY(-10px)";
                setTimeout(() => {
                  lotRejectionRemarksSection.style.display = "none";
                }, 300);
              }
              
              // Enable inputs
              inputs.forEach(input => {
                input.disabled = false;
              });
            }
          });
        }

        // Character count functionality for remarks
        const lotRejectionRemarksInput = document.getElementById("lotRejectionRemarksInput");
        const remarksCharCount = document.getElementById("remarksCharCount");
        
        if (lotRejectionRemarksInput && remarksCharCount) {
          function updateCharCount() {
            const currentLength = lotRejectionRemarksInput.value.length;
            remarksCharCount.textContent = currentLength;
            
            if (currentLength > 450) {
              remarksCharCount.style.color = "#dc3545";
            } else if (currentLength > 350) {
              remarksCharCount.style.color = "#ffc107";
            } else {
              remarksCharCount.style.color = "#6c757d";
            }
          }
          
          lotRejectionRemarksInput.addEventListener("input", updateCharCount);
          updateCharCount();
        }

        // Draft button event listener
// Updated Draft button event listener with mode switching logic
const draftButton = document.getElementById("draftButton");
if (draftButton) {
  draftButton.addEventListener("click", () => {
    if (draftButton.disabled) return;
    draftButton.disabled = true;
    
    const msgDiv = document.getElementById("batchRejectionMsg");
    const batchRejectionCheckbox = document.getElementById("batchRejection");
    
    if (msgDiv) msgDiv.textContent = "";

    // ✅ NEW: Clear any existing drafts when switching modes
    clearExistingDraftsBeforeSave(stockLotId, batchRejectionCheckbox.checked);

    if (batchRejectionCheckbox && batchRejectionCheckbox.checked) {
      // Handle Lot Rejection draft
      handleBatchRejectionDraft(batchId, stockLotId, msgDiv, draftButton);
    } else {
      // Handle tray-wise rejection draft
      handleTrayWiseRejectionDraft(batchId, stockLotId, msgDiv, draftButton);
    }
  });
}

// ✅ NEW: Function to clear existing drafts when switching modes
function clearExistingDraftsBeforeSave(stockLotId, isBatchRejection) {
  const draftTypeToDelete = isBatchRejection ? 'tray_rejection' : 'batch_rejection';
  
  // Clear the opposite draft type
  fetch('/nickle_inspection_zone_two/nq_zone_clear_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      draft_type: draftTypeToDelete
    })
  })
  .then(res => res.json())
  .then(data => {
    console.log(`Cleared ${draftTypeToDelete} draft:`, data.success);
  })
  .catch(error => {
    console.log('Error clearing draft:', error);
  });
}
// Updated function to handle Lot Rejection draft with page refresh
function handleBatchRejectionDraft(batchId, stockLotId, msgDiv, draftButton) {
  const lotRejectionRemarksInput = document.getElementById('lotRejectionRemarksInput');
  const lotRejectionRemarks = lotRejectionRemarksInput ? lotRejectionRemarksInput.value.trim() : '';
  
  if (!lotRejectionRemarks) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = 'Lot rejection remarks are required for Lot Rejection draft.';
    }
    draftButton.disabled = false;
    return;
  }
  
  const totalQty = document.getElementById('rejection-total-qty').textContent || "0";
  
  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.textContent = 'Saving Lot Rejection as draft...';
  }
  
  fetch('/nickle_inspection_zone_two/nq_zone_batch_rejection_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      batch_id: batchId,
      lot_id: stockLotId,
      total_qty: totalQty,
      lot_rejected_comment: lotRejectionRemarks,
      is_draft: true
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Lot Rejection draft saved successfully!";
      }
      
      // ✅ UPDATED: Refresh the entire page after 1.5 seconds
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save Lot Rejection draft";
      }
      draftButton.disabled = false;
    }
  })
  .catch(() => {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error while saving draft";
    }
    draftButton.disabled = false;
  });
}

// Updated function to handle tray-wise rejection draft with page refresh
function handleTrayWiseRejectionDraft(batchId, stockLotId, msgDiv, draftButton) {
  const rows = document.querySelectorAll("#rejection-table-body tr");
  
  let tray_rejections = [];
  let rejectionReasons = [];
  
  // Collect rejection reasons and quantities
  rows.forEach(row => {
    const qtyInput = row.querySelector('input.rejection-qty-input');
    if (qtyInput) {
      const reason_id = row.querySelectorAll("td")[1].textContent.trim();
      const qty = parseInt(qtyInput.value.trim()) || 0;
      
      if (qty > 0) {
        rejectionReasons.push({
          reason_id: reason_id,
          quantity: qty
        });
      }
    }
  });
  
  if (rejectionReasons.length === 0) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Please enter at least one rejection quantity.";
    }
    draftButton.disabled = false;
    return;
  }
  
  // Calculate total rejection quantity
  const totalRejectionQty = rejectionReasons.reduce((sum, r) => sum + r.quantity, 0);
  
  // Get tray capacity (same logic as updateRejectionTrayTable)
  let trayCapacity = 12; // Default fallback
  const currentRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
  if (currentRow) {
    const trayCapacityCell = currentRow.cells[8]; // "Tray Cate-Capacity" column
    if (trayCapacityCell) {
      const trayCapacityText = trayCapacityCell.textContent.trim();
      if (trayCapacityText.includes('-')) {
        const parts = trayCapacityText.split('-');
        if (parts.length >= 2) {
          trayCapacity = parseInt(parts[1]) || 12;
        }
      }
    }
  }
  
  // Calculate tray distribution (same as updateRejectionTrayTable)
  const remainder = totalRejectionQty % trayCapacity;
  const fullTrays = Math.floor(totalRejectionQty / trayCapacity);
  const trayQuantities = [];
  
  // Add remainder tray FIRST (if exists)
  if (remainder > 0) {
    trayQuantities.push(remainder);
  }
  
  // Add full capacity trays
  for (let i = 0; i < fullTrays; i++) {
    trayQuantities.push(trayCapacity);
  }
  
  // Get existing tray IDs if tray table exists
  const existingTrayRows = document.querySelectorAll("#rejection-tray-table-body tr");
  const trayToQuantityMap = [];
  
  if (existingTrayRows.length > 0) {
    // Use existing tray rows if they exist
    existingTrayRows.forEach((row, index) => {
      const trayInput = row.querySelector('input.tray-id-input') || row.querySelector('input.rejection-tray-id-input');
      const trayQtyCell = row.cells[2];
      const expectedQty = parseInt(trayQtyCell.textContent) || 0;
      
      if (expectedQty > 0) {
        const trayId = trayInput ? trayInput.value.trim() : '';
        trayToQuantityMap.push({
          tray_id: trayId,
          quantity: expectedQty,
          row_index: index + 1
        });
      }
    });
  } else {
    // Create tray distribution from calculated quantities
    trayQuantities.forEach((qty, index) => {
      trayToQuantityMap.push({
        tray_id: '', // Empty for draft
        quantity: qty,
        row_index: index + 1
      });
    });
  }
  
  // Map rejection reasons to trays - fill trays sequentially
  const trayRejectionsMap = {};
  trayToQuantityMap.forEach(tray => {
    trayRejectionsMap[tray.row_index] = {
      tray_id: tray.tray_id,
      remaining_capacity: tray.quantity,
      rejections: []
    };
  });
  
  // Distribute rejection reasons to trays
  let currentTrayIndex = 1;
  for (const rejection of rejectionReasons) {
    let remainingQty = rejection.quantity;
    
    while (remainingQty > 0 && currentTrayIndex <= trayToQuantityMap.length) {
      const currentTray = trayRejectionsMap[currentTrayIndex];
      
      if (currentTray.remaining_capacity > 0) {
        const qtyForThisTray = Math.min(remainingQty, currentTray.remaining_capacity);
        
        currentTray.rejections.push({
          reason_id: rejection.reason_id,
          qty: qtyForThisTray
        });
        
        currentTray.remaining_capacity -= qtyForThisTray;
        remainingQty -= qtyForThisTray;
      } else {
        // Move to next tray
        currentTrayIndex++;
      }
    }
  }
  
  // Convert to the expected format
  Object.values(trayRejectionsMap).forEach(tray => {
    tray.rejections.forEach(rejection => {
      tray_rejections.push({
        reason_id: rejection.reason_id,
        qty: rejection.qty,
        tray_id: tray.tray_id
      });
    });
  });
  
  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.textContent = 'Saving tray rejection as draft...';
  }
  
  fetch('/nickle_inspection_zone_two/nq_zone_tray_rejection_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      batch_id: batchId,
      tray_rejections: tray_rejections,
      is_draft: true
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Tray rejection draft saved successfully!";
      }
      
      // ✅ UPDATED: Refresh the entire page after 1.5 seconds
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save tray rejection draft";
      }
      draftButton.disabled = false;
    }
  })
  .catch(() => {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error while saving draft";
    }
    draftButton.disabled = false;
  });
}

// ✅ REMOVED: refreshModalData function is no longer needed since we're refreshing the page

// New function to refresh modal data
function refreshModalData(stockLotId, batchId) {
  // Close current modal
  const trayModal = document.getElementById("trayScanModal");
  if (trayModal) {
    trayModal.classList.remove("open");
  }
  
  // Find the row and trigger click again to reload modal with draft data
  const targetRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
  if (targetRow) {
    const rejectBtn = targetRow.querySelector('.tray-scan-btn');
    if (rejectBtn) {
      setTimeout(() => {
        rejectBtn.click();
      }, 300);
    }
  }
}


        // Proceed button event listener

// Updated Proceed button event listener with integrated delink functionality
const proceedButton = document.getElementById("proceedButton");
if (proceedButton) {
  proceedButton.addEventListener("click", () => {
    if (proceedButton.disabled) return;
    proceedButton.disabled = true;
    
    const batchRejectionCheckbox = document.getElementById("batchRejection");
    const msgDiv = document.getElementById("batchRejectionMsg");
    if (msgDiv) msgDiv.textContent = "";

    if (batchRejectionCheckbox && batchRejectionCheckbox.checked) {
      // ✅ ENHANCED: Lot Rejection with Delink Integration
      const lotRejectionRemarksInput = document.getElementById('lotRejectionRemarksInput');
      const lotRejectionRemarks = lotRejectionRemarksInput ? lotRejectionRemarksInput.value.trim() : '';
      
      if (!lotRejectionRemarks) {
        if (msgDiv) {
          msgDiv.style.color = "#d32f2f";
          msgDiv.textContent = 'Lot rejection remarks are required for Lot Rejection.';
        }
        proceedButton.disabled = false;
        return;
      }

      const batchId = trayModal.dataset.batchId;
      const lotId = trayModal.dataset.stockLotId;
      const totalQty = document.getElementById('rejection-total-qty').textContent || "0";
      
      if (!batchId || !lotId) {
        if (msgDiv) {
          msgDiv.style.color = "#d32f2f";
          msgDiv.textContent = "Batch ID or Lot ID not found.";
        }
        proceedButton.disabled = false;
        return;
      }

      // ✅ NEW: Check for missing quantity in batch rejection
      const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
      const missingQtyInput = currentRow ? currentRow.querySelector('.missing-qty-input') : null;
      const missingQty = missingQtyInput ? parseInt(missingQtyInput.value) || 0 : 0;

      console.log(`🔍 [Batch Rejection] Checking missing qty: ${missingQty} for lot: ${lotId}`);

      if (missingQty > 0) {
        // ✅ Show delink modal for batch rejection
        console.log('🔗 Showing delink modal for batch rejection with missing qty:', missingQty);
        
        // Close the current rejection modal
        const trayModal = document.getElementById("trayScanModal");
        if (trayModal) {
          trayModal.classList.remove("open");
          trayModal.style.display = "none";
        }
        
        // Show delink modal with batch rejection context
        showBatchRejectionDelinkModal(lotId, batchId, missingQty, lotRejectionRemarks, totalQty);
        
      } else {
        // ✅ No missing quantity - proceed with normal batch rejection
        console.log('✅ No missing quantity - proceeding with normal batch rejection');
        performBatchRejection(batchId, lotId, totalQty, lotRejectionRemarks);
      }
      
    } else {
      // Tray-wise rejection logic (unchanged)
      handleTrayWiseRejection();
    }
  });
}

// ✅ NEW: Function to show delink modal specifically for batch rejection
function showBatchRejectionDelinkModal(lotId, batchId, missingQty, lotRejectionRemarks, totalQty) {
  console.log('🔗 Showing batch rejection delink modal for lot:', lotId, 'missing qty:', missingQty);
  
  const modal = document.getElementById('delinkModal');
  if (!modal) {
    console.error('❌ Delink modal not found!');
    // Fallback to normal batch rejection
    performBatchRejection(batchId, lotId, totalQty, lotRejectionRemarks);
    return;
  }
  
  const missingQtySpan = document.getElementById('delinkMissingQty');
  const loadingDiv = document.getElementById('delinkLoadingDiv');
  const contentDiv = document.getElementById('delinkContentDiv');
  const errorDiv = document.getElementById('delinkErrorDiv');
  const confirmBtn = document.getElementById('confirmDelinkBtn');
  
  // Reset modal state
  if (missingQtySpan) missingQtySpan.textContent = missingQty;
  if (loadingDiv) loadingDiv.style.display = 'block';
  if (contentDiv) contentDiv.style.display = 'none';
  if (errorDiv) errorDiv.style.display = 'none';
  if (confirmBtn) {
    confirmBtn.style.display = 'none';
    confirmBtn.disabled = true;
  }
  
  // Update modal title for batch rejection context - compact version
  const modalTitle = modal.querySelector('h2');
  if (modalTitle) {
    modalTitle.innerHTML = `
      <span style="font-size: 20px; font-weight: 600;">Set Top Tray</span>
    `;
    modalTitle.style.margin = '0 0 12px 0';
    modalTitle.style.padding = '8px 0';
  }
  
  // Show modal
  modal.style.display = 'block';
  console.log('👁️ Batch rejection delink modal should be visible now');
  
  // ✅ CRITICAL: Store batch rejection context and override existing handlers
  modal.dataset.lotId = lotId;
  modal.dataset.batchId = batchId;
  modal.dataset.missingQty = missingQty;
  modal.dataset.lotRejectionRemarks = lotRejectionRemarks;
  modal.dataset.totalQty = totalQty;
  modal.dataset.isBatchRejection = 'true'; // Flag to indicate this is batch rejection
  
  // ✅ OVERRIDE: Replace confirm button with batch rejection specific handler
  if (confirmBtn) {
    // Clone button to remove all existing event listeners
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    // Add batch rejection specific handler
    newConfirmBtn.addEventListener('click', function() {
      console.log('✅ BATCH REJECTION: Confirm button clicked');
      
      // Collect tray IDs
      const delinkTrayInputs = document.querySelectorAll('.delink-tray-input');
      const topTrayInput = document.getElementById('topTrayIdInput');
      
      const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);
      const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';
      const topTrayQtyElement = document.querySelector('#topTrayTableBody td:last-child');
      const topTrayQty = topTrayQtyElement ? topTrayQtyElement.textContent.trim() : '';
      
      console.log('📦 BATCH REJECTION: Collected data:', { 
        lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty 
      });
      
      // Close modal
      modal.style.display = 'none';
      
      // Show batch rejection confirmation with custom button text
      if (typeof Swal !== 'undefined') {
        Swal.fire({
          title: 'Confirm LOT Rejection',
          text: `This will REJECT the entire batch. Are you sure?`,
          icon: 'warning',
          showCancelButton: true,
          confirmButtonColor: '#dc3545',
          cancelButtonColor: '#6c757d',
          confirmButtonText: 'Yes, Reject',
          cancelButtonText: 'Cancel',
          reverseButtons: true
        }).then((result) => {
          if (result.isConfirmed) {
            console.log('🚀 BATCH REJECTION: User confirmed, calling performBatchRejectionWithDelink');
            performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty);
          }
        });
      } else {
        if (confirm('Confirm LOT Rejection with Delink\n\nThis will delink ' + missingQty + ' pieces and REJECT the entire batch. Are you sure?')) {
          console.log('🚀 BATCH REJECTION: User confirmed, calling performBatchRejectionWithDelink');
          performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty);
        }
      }
    });
  }
  
  // Fetch delink calculation
  fetchDelinkCalculationForBatchRejection(lotId, missingQty);
}

// ✅ NEW: Fetch delink calculation specifically for batch rejection
function fetchDelinkCalculationForBatchRejection(lotId, missingQty) {
  console.log('📡 Fetching delink calculation for batch rejection - lot:', lotId, 'missing qty:', missingQty);
  
  const loadingDiv = document.getElementById('delinkLoadingDiv');
  const contentDiv = document.getElementById('delinkContentDiv');
  const errorDiv = document.getElementById('delinkErrorDiv');
  const confirmBtn = document.getElementById('confirmDelinkBtn');
  
  const apiUrl = `/nickle_inspection_zone_two/nq_zone_tray_delink_top_tray_calc/?lot_id=${encodeURIComponent(lotId)}&missing_qty=${missingQty}`;
  console.log('🌐 API URL:', apiUrl);
  
  fetch(apiUrl)
    .then(response => {
      console.log('📥 API Response status:', response.status);
      return response.json();
    })
    .then(data => {
      console.log('📊 API Response data:', data);
      
      if (loadingDiv) loadingDiv.style.display = 'none';
      
      if (data.success) {
        populateDelinkTablesForBatchRejection(data);
        if (contentDiv) contentDiv.style.display = 'block';
        if (confirmBtn) {
          confirmBtn.style.display = 'inline-block';
          // Update button text for batch rejection
          confirmBtn.innerHTML = `
            <i class="fa fa-check" style="margin-right: 6px;"></i>
            Submit
          `;
        }
      } else {
        showDelinkError(data.error || 'Failed to calculate delink requirements for batch rejection');
      }
    })
    .catch(error => {
      console.error('❌ API Error:', error);
      if (loadingDiv) loadingDiv.style.display = 'none';
      showDelinkError('Network error while calculating delink requirements for batch rejection.');
    });
}

// ✅ NEW: Populate delink tables for batch rejection (compact version)
function populateDelinkTablesForBatchRejection(data) {
  console.log('📋 Populating compact delink tables for batch rejection with data:', data);
  
  const delinkTraysSection = document.getElementById('delinkTraysSection');
  const topTraySection = document.getElementById('topTraySection');
  const delinkTableBody = document.getElementById('delinkTableBody');
  const topTrayTableBody = document.getElementById('topTrayTableBody');
  const delinkCountSpan = document.getElementById('delinkCount');
  
  // Clear existing content
  if (delinkTableBody) delinkTableBody.innerHTML = '';
  if (topTrayTableBody) topTrayTableBody.innerHTML = '';
  
  // Delink Trays Section - Compact
  if (data.delink_trays && data.delink_trays.length > 0) {
    if (delinkCountSpan) delinkCountSpan.textContent = data.delink_count || data.delink_trays.length;
    data.delink_trays.forEach((_, index) => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td style="font-weight: 600; background: #ffebee; padding: 4px; font-size: 12px; width: 40px;">${index + 1}</td>
        <td style="padding: 4px;">
          <input type="text" class="form-control delink-tray-input" value="" placeholder="Scan Tray ID" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
          <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
        </td>
      `;
      if (delinkTableBody) delinkTableBody.appendChild(row);
    });
    if (delinkTraysSection) {
      delinkTraysSection.style.display = 'block';
      // Make section header more compact
      const sectionHeader = delinkTraysSection.querySelector('.section-header');
      if (sectionHeader) {
        sectionHeader.style.padding = '6px 10px';
        sectionHeader.style.fontSize = '14px';
        sectionHeader.style.margin = '8px 0 6px 0';
      }
    }
  } else {
    if (delinkTraysSection) delinkTraysSection.style.display = 'none';
  }

  // Top Tray Section - Compact
  if (data.top_tray) {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td style="padding: 4px;">
        <input type="text" id="topTrayIdInput" class="form-control" value="" placeholder="Scan Top Tray ID" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
        <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
      </td>
      <td style="font-weight: 600; color: #2e7d32; padding: 4px; font-size: 12px; text-align: center; width: 60px;">${data.top_tray.qty}</td>
    `;
    if (topTrayTableBody) topTrayTableBody.appendChild(row);
    if (topTraySection) {
      topTraySection.style.display = 'block';
      // Make section header more compact
      const sectionHeader = topTraySection.querySelector('.section-header');
      if (sectionHeader) {
        sectionHeader.style.padding = '6px 10px';
        sectionHeader.style.fontSize = '14px';
        sectionHeader.style.margin = '8px 0 6px 0';
      }
    }
  } else {
    if (topTraySection) topTraySection.style.display = 'none';
  }

  // Make tables more compact
  const tables = document.querySelectorAll('#delinkTraysSection table, #topTraySection table');
  tables.forEach(table => {
    table.style.margin = '8px 0';
    table.style.fontSize = '12px';
    // Make table headers more compact
    const headers = table.querySelectorAll('th');
    headers.forEach(th => {
      th.style.padding = '6px 8px';
      th.style.fontSize = '11px';
    });
  });

  // Attach validation to inputs
  setTimeout(() => {
    attachValidationToInputsForBatchRejection();
  }, 100);
}

// FIXED: Attach validation AFTER modal content is loaded
function attachValidationToInputsForBatchRejection() {
  console.log('[VALIDATION] Waiting for modal inputs to load...');
  
  // Wait for inputs to be available
  const waitForInputs = () => {
    const inputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
    
    if (inputs.length === 0) {
      console.log('[VALIDATION] No inputs found, retrying in 100ms...');
      setTimeout(waitForInputs, 100);
      return;
    }
    
    console.log(`[VALIDATION] Found ${inputs.length} inputs, setting up validation`);
    setupValidation(inputs);
  };
  
  const setupValidation = (inputs) => {
    const inputArray = Array.from(inputs);
    
    inputs.forEach((input, index) => {
      console.log(`[SETUP] Configuring input ${index}:`, input);
      
      // Remove any existing listeners
      const newInput = input.cloneNode(true);
      input.parentNode.replaceChild(newInput, input);
      inputArray[index] = newInput;
      
      // Get error div
      let errorDiv = newInput.parentElement.querySelector('.tray-id-error');
      if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.className = 'tray-id-error';
        errorDiv.style.cssText = 'display: none; font-size: 10px; margin-top: 2px; color: #dc3545; font-weight: bold;';
        newInput.parentElement.appendChild(errorDiv);
      }
      
      // Navigation helper
      const moveToNextInput = () => {
        const currentIndex = inputArray.indexOf(newInput);
        const nextInput = inputArray[currentIndex + 1];
        
        if (nextInput) {
          console.log(`[MOVE] Moving from input ${currentIndex} to ${currentIndex + 1}`);
          setTimeout(() => {
            nextInput.focus();
            nextInput.select();
          }, 100);
        } else {
          console.log('[MOVE] Last input reached, focusing submit button');
          const submitBtn = document.getElementById('confirmDelinkBtn');
          if (submitBtn) {
            setTimeout(() => submitBtn.focus(), 100);
          }
        }
      };
      
      // Duplicate check function
      const checkForDuplicates = (trayId) => {
        let duplicateFound = false;
        inputArray.forEach((otherInput, otherIndex) => {
          if (otherIndex !== index && otherInput.value.trim() === trayId) {
            duplicateFound = true;
          }
        });
        return duplicateFound;
      };
      
      // Validation function
      const validateInput = (moveOnSuccess = false) => {
        const trayId = newInput.value.trim();
        console.log(`[VALIDATE] Input ${index}: "${trayId}"`);
        
        // Clear previous states
        newInput._hasError = false;
        newInput.style.border = '';
        newInput.style.backgroundColor = '';
        errorDiv.style.display = 'none';
        
        if (!trayId) {
          if (moveOnSuccess) moveToNextInput();
          return;
        }
        
        // CHECK FOR DUPLICATES FIRST
        if (checkForDuplicates(trayId)) {
          console.log(`[DUPLICATE] Found duplicate tray ID: ${trayId}`);
          newInput._hasError = true;
          newInput.style.border = '2px solid #dc3545';
          newInput.style.backgroundColor = '#ffebee';
          errorDiv.textContent = `Duplicate Tray ID: "${trayId}"`;
          errorDiv.style.color = '#dc3545';
          errorDiv.style.display = 'block';
          
          // Stay on current input and select text
          setTimeout(() => {
            newInput.focus();
            newInput.select();
          }, 100);
          
          validateAllInputsAndUpdateButtonsForBatchRejection();
          return;
        }
        
        // Show validation state
        newInput.style.border = '2px solid #ffc107';
        newInput.style.backgroundColor = '#fff3cd';
        errorDiv.textContent = 'Validating...';
        errorDiv.style.color = '#856404';
        errorDiv.style.display = 'block';
        
        const lotId = getCurrentLotId();
        console.log(`[API] Validating tray ${trayId} for lot ${lotId}`);
        
        fetch(`/nickle_inspection_zone_two/nq_zone_validate_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
          .then(res => res.json())
          .then(data => {
            console.log(`[API-RESPONSE] Input ${index}:`, data);
            
            if (data && data.exists && data.valid_for_lot) {
              // SUCCESS
              newInput.style.border = '2px solid #28a745';
              newInput.style.backgroundColor = '#f8fff8';
              newInput._hasError = false;
              
              errorDiv.textContent = '✓ Available';
              errorDiv.style.color = '#28a745';
              errorDiv.style.display = 'block';
              
              setTimeout(() => errorDiv.style.display = 'none', 1500);
              
              if (moveOnSuccess) {
                moveToNextInput();
              }
              
            } else {
              // ERROR
              newInput.style.border = '2px solid #dc3545';
              newInput.style.backgroundColor = '#ffebee';
              newInput._hasError = true;
              
              errorDiv.textContent = data.error || 'Invalid tray ID';
              errorDiv.style.color = '#dc3545';
              errorDiv.style.display = 'block';
              
              // Stay on current input
              setTimeout(() => {
                newInput.focus();
                newInput.select();
              }, 100);
            }
            
            // Update buttons
            validateAllInputsAndUpdateButtonsForBatchRejection();
          })
          .catch(error => {
            console.error(`[API-ERROR] Input ${index}:`, error);
            newInput._hasError = true;
            newInput.style.border = '2px solid #dc3545';
            newInput.style.backgroundColor = '#ffebee';
            errorDiv.textContent = 'Network error';
            errorDiv.style.color = '#dc3545';
            errorDiv.style.display = 'block';
            
            validateAllInputsAndUpdateButtonsForBatchRejection();
          });
      };
      
      // ENTER KEY EVENT
      newInput.addEventListener('keydown', function(e) {
        console.log(`[KEY] Input ${index} - Key: ${e.key}`);
        
        if (e.key === 'Enter') {
          console.log(`[ENTER] Detected on input ${index}`);
          e.preventDefault();
          e.stopPropagation();
          
          // Validate and move to next
          validateInput(true);
          return false;
        }
        
        if (e.key === 'Tab' && this._hasError) {
          e.preventDefault();
          this.focus();
          this.select();
          return false;
        }
      });
      
      // BLUR EVENT
      newInput.addEventListener('blur', function() {
        console.log(`[BLUR] Input ${index}`);
        validateInput(false);
      });
      
      // INPUT EVENT (clear errors while typing)
      newInput.addEventListener('input', function() {
        if (this._hasError) {
          this._hasError = false;
          this.style.border = '';
          this.style.backgroundColor = '';
          errorDiv.style.display = 'none';
          validateAllInputsAndUpdateButtonsForBatchRejection();
        }
      });
      
      console.log(`[READY] Input ${index} configured with Enter navigation`);
    });
    
    console.log('[SUCCESS] All inputs configured for Enter + validation');
  };
  
  // Start the process
  waitForInputs();
}


// Helper function 
function getCurrentLotId() {
  const modal = document.getElementById('delinkModal');
  return modal?.dataset?.lotId || null;
}



// ✅ NEW: Validate inputs for batch rejection
function validateAllInputsAndUpdateButtonsForBatchRejection() {
  const confirmBtn = document.getElementById('confirmDelinkBtn');
  if (!confirmBtn) return;
  
  const allInputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
  let hasErrors = false;
  let hasEmptyInputs = false;
  
  allInputs.forEach(input => {
    if (input._hasError) {
      hasErrors = true;
    }
    if (!input.value.trim()) {
      hasEmptyInputs = true;
    }
  });
  
  // Enable/disable confirm button
  if (hasErrors || hasEmptyInputs) {
    confirmBtn.disabled = true;
    confirmBtn.style.opacity = '0.5';
    confirmBtn.style.cursor = 'not-allowed';
  } else {
    confirmBtn.disabled = false;
    confirmBtn.style.opacity = '1';
    confirmBtn.style.cursor = 'pointer';
  }
}

// ✅ UPDATED: Enhanced confirm button handler that properly detects batch rejection
function setupDelinkConfirmButton() {
  const confirmDelinkBtn = document.getElementById('confirmDelinkBtn');
  if (confirmDelinkBtn) {
    // Remove existing listener and add new one
    const newConfirmBtn = confirmDelinkBtn.cloneNode(true);
    confirmDelinkBtn.parentNode.replaceChild(newConfirmBtn, confirmDelinkBtn);
    
    newConfirmBtn.addEventListener('click', function() {
      console.log('Confirm delink button clicked');
      
      const modal = document.getElementById('delinkModal');
      const lotId = modal ? modal.dataset.lotId : null;
      const batchId = modal ? modal.dataset.batchId : null;
      const missingQty = modal ? modal.dataset.missingQty : null;
      
      // ✅ FIXED: Properly detect batch rejection context
      const isBatchRejection = modal ? modal.dataset.isBatchRejection === 'true' : false;
      const lotRejectionRemarks = modal ? modal.dataset.lotRejectionRemarks : '';
      const totalQty = modal ? modal.dataset.totalQty : '0';
      
      console.log('Context detection:', { 
        lotId, 
        batchId, 
        missingQty, 
        isBatchRejection,
        lotRejectionRemarks,
        totalQty
      });
      
      if (!lotId) {
        showAlert('Error', 'Lot ID not found', 'error');
        return;
      }
      
      // Collect tray IDs
      const delinkTrayInputs = document.querySelectorAll('.delink-tray-input');
      const topTrayInput = document.getElementById('topTrayIdInput');
      
      const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);
      const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';
      const topTrayQtyElement = document.querySelector('#topTrayTableBody td:last-child');
      const topTrayQty = topTrayQtyElement ? topTrayQtyElement.textContent.trim() : '';
      
      console.log('Collected tray data:', { delinkTrayIds, topTrayId, topTrayQty });
      
      // Close delink modal
      if (modal) modal.style.display = 'none';
      
      // ✅ FIXED: Route to correct endpoint based on context
      if (isBatchRejection && batchId && lotRejectionRemarks) {
        console.log('ROUTING TO: Batch Rejection with Delink');
        showConfirm(
          'Confirm LOT Rejection with Delink',
          `This will delink ${missingQty} pieces and reject the entire batch. Are you sure?`,
          function() {
            performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty);
          }
        );
      } else {
        console.log('ROUTING TO: Accept with Delink (default)');
        showConfirm(
          'Submit',
          `This will delink ${missingQty} pieces and accept the remaining lot. Are you sure?`,
          function() {
            performDelinkAcceptAction(lotId, delinkTrayIds, topTrayId, topTrayQty);
          }
        );
      }
    });
  }
}

// Call this function when setting up modal event listeners
document.addEventListener('DOMContentLoaded', function() {
  setupDelinkConfirmButton();
});

// ✅ NEW: Function to perform batch rejection with delink - EXPLICIT ENDPOINT ROUTING
function performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty) {
  console.log('🎯 BATCH REJECTION: Starting performBatchRejectionWithDelink');
  console.log('📊 BATCH REJECTION: Parameters:', { 
    lotId, 
    batchId, 
    delinkTrayIds, 
    topTrayId, 
    topTrayQty, 
    lotRejectionRemarks,
    totalQty 
  });

  // Parse top tray quantity
  let parsedTopTrayQty = null;
  if (topTrayQty && topTrayQty !== '') {
    parsedTopTrayQty = parseInt(topTrayQty, 10);
    if (isNaN(parsedTopTrayQty)) {
      console.error('❌ BATCH REJECTION: Invalid top tray quantity:', topTrayQty);
      showAlert('Error', 'Invalid top tray quantity', 'error');
      return;
    }
  }

  const delinkPayload = {
    lot_id: lotId,
    delink_tray_ids: delinkTrayIds,
    top_tray_id: topTrayId,
    top_tray_qty: parsedTopTrayQty
  };

  console.log('📤 BATCH REJECTION: Sending delink payload:', delinkPayload);

  // Step 1: Perform delink operation first
  fetch('/nickle_inspection_zone_two/nq_zone_tray_delink_and_top_tray_update/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify(delinkPayload)
  })
  .then(res => {
    console.log('📡 BATCH REJECTION: Delink API status:', res.status);
    return res.json();
  })
  .then(data => {
    console.log('📊 BATCH REJECTION: Delink API Response:', data);
    if (data && data.success) {
      console.log('✅ BATCH REJECTION: Delink successful, now calling BATCH REJECTION endpoint...');
      
      // Step 2: EXPLICIT BATCH REJECTION CALL
      const batchRejectionPayload = {
        batch_id: batchId,
        lot_id: lotId,
        total_qty: totalQty,
        lot_rejected_comment: lotRejectionRemarks
      };
      
      console.log('📤 BATCH REJECTION: Sending to /nickle_inspection_zone_two/nq_zone_batch_rejection/');
      console.log('📦 BATCH REJECTION: Payload:', batchRejectionPayload);
      
      // ✅ EXPLICIT: Call batch rejection endpoint (NOT accept endpoint)
      return fetch('/nickle_inspection_zone_two/nq_zone_batch_rejection/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(batchRejectionPayload)
      });
    } else {
      throw new Error(data.error || 'Failed to perform delink operation');
    }
  })
  .then(res => {
    console.log('📡 BATCH REJECTION: Batch rejection API status:', res.status);
    
    // Check if it's a redirect response (which shouldn't happen for batch rejection)
    if (res.redirected) {
      console.warn('⚠️ BATCH REJECTION: Unexpected redirect to:', res.url);
    }
    
    return res.json();
  })
  .then(data => {
    console.log('📊 BATCH REJECTION: Final API Response:', data);
    
    if (data && data.success) {
      console.log('✅ BATCH REJECTION: Success - showing success message');
      showSuccess('Lot Rejection completed successfully!', function() {
        window.location.reload();
      });
    } else {
      console.error('❌ BATCH REJECTION: Failed with error:', data.error);
      showAlert('Error', 'Delink successful but batch rejection failed: ' + (data.error || 'Unknown error'), 'error');
    }
  })
  .catch(error => {
    console.error('❌ BATCH REJECTION: Network/processing error:', error);
    showAlert('Error', 'Error during batch rejection with delink: ' + error.message, 'error');
  });
}

// ✅ NEW: Function to perform normal batch rejection (without delink)
function performBatchRejection(batchId, lotId, totalQty, lotRejectionRemarks) {
  console.log('🎯 Performing normal batch rejection:', { batchId, lotId, totalQty, lotRejectionRemarks });
  
  const msgDiv = document.getElementById("batchRejectionMsg");
  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.textContent = "Saving batch rejection...";
  }
  
  fetch('/nickle_inspection_zone_two/nq_zone_batch_rejection/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      batch_id: batchId,
      lot_id: lotId,
      total_qty: totalQty,
      lot_rejected_comment: lotRejectionRemarks
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Lot rejection saved successfully!";
      }
      setTimeout(() => {
        const trayModal = document.getElementById("trayScanModal");
        if (trayModal) trayModal.classList.remove("open");
        if (msgDiv) msgDiv.textContent = "";
        window.location.reload();
      }, 1200);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save Batch Rejection";
      }
      document.getElementById("proceedButton").disabled = false;
    }
  })
  .catch(() => {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error";
    }
    document.getElementById("proceedButton").disabled = false;
  });
} 


// Cancel button event listener
        const cancelButton = document.getElementById("cancelButton");
        if (cancelButton) {
          cancelButton.addEventListener("click", () => {
            trayModal.classList.remove("open");
          });
        }
      }

      // Existing modal close event listeners
      if (closeTrayBtn) {
        closeTrayBtn.addEventListener("click", () => {
          trayModal.classList.remove("open");
        });
      }
      

      
      // New Popup Modal close events
      if (closeNewPopupBtn) {
        closeNewPopupBtn.addEventListener("click", () => {
          newPopupModal.classList.remove("open");
        });
      }
    });
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  document.querySelectorAll('.tray-scan-btn[data-is-delink-only="true"]').forEach(function(btn) {
    btn.addEventListener('click', function(event) {
      event.preventDefault();
      const lotId = btn.getAttribute('data-stock-lot-id');
      if (!lotId) return;

      // Always fetch accepted tray scan data to get latest is_delink_only status
      fetch(`/nickle_inspection_zone_two/nq_zone_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(rescanData => {
          if (rescanData.success && rescanData.is_delink_only) {
            // Check if delink trays are available
            fetch(`/nickle_inspection_zone_two/nq_zone_get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`)
              .then(res => res.json())
              .then(delinkData => {
                if (delinkData.success && delinkData.delink_trays && delinkData.delink_trays.length > 0) {
                  // Open modal in delink-only mode
                  showAcceptedTrayModal(rescanData, lotId, false, true);
                } else {
                  Swal.fire('No Delink Needed', 'There are no empty trays available for delink in this lot.', 'info');
                }
              });
          } else {
            // Fallback: show normal modal (should not happen for delink-only lots)
            showAcceptedTrayModal(rescanData, lotId, false, false);
          }
        });
    });
  });
});
</script>


  <script nonce="{{ csp_nonce }}">
// ✅ GLOBAL getCookie function - Define this FIRST before any other scripts
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}
</script>

  <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      document.querySelectorAll('.brass-checkbox').forEach(function (checkbox) {
        const row = checkbox.closest('tr');
        const lotQtySpan = row.querySelector('.lot-qty');
        const totalQty = parseInt(lotQtySpan.textContent.trim(), 10);
        const missingQtyInput = row.querySelector('.missing-qty-input');
        const physicalQtyInput = row.querySelector('.physical-qty-input');
    
        // Enable input on page load if not checked/disabled
        if (!checkbox.checked && !checkbox.disabled) {
          missingQtyInput.disabled = false;
        }
    
        // Live update physical qty as user types
        missingQtyInput.addEventListener('input', function () {
          let missingQty = parseInt(missingQtyInput.value, 10);
          if (isNaN(missingQty) || missingQty < 0) {
            physicalQtyInput.value = totalQty;
            return;
          }
          if (missingQty > totalQty) {
            missingQtyInput.value = totalQty;
            missingQty = totalQty;
          }
          physicalQtyInput.value = totalQty - missingQty;
        });
    
        checkbox.addEventListener('change', function () {
          if (checkbox.checked && !checkbox.disabled) {
            missingQtyInput.disabled = false;
            missingQtyInput.focus();
          } else {
            missingQtyInput.value = '';
            missingQtyInput.disabled = false;
            if (physicalQtyInput) physicalQtyInput.value = totalQty;
          }
        });
    
        // Save on checkbox check
        checkbox.addEventListener('change', function () {
          if (!checkbox.checked || checkbox.disabled) return;
          const lotId = checkbox.getAttribute('data-lot-id');
          let missingQty = missingQtyInput.value.trim();
          if (!lotId) {
            Swal.fire('Error', 'Lot ID not found.', 'error');
            checkbox.checked = false;
            return;
          }
          if (!missingQty || isNaN(missingQty) || parseInt(missingQty) < 0) {
            Swal.fire('Error', 'Enter a valid missing quantity.', 'error');
            checkbox.checked = false;
            return;
          }
          fetch('/nickle_inspection_zone_two/nq_zone_save_ip_checkbox/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
              lot_id: lotId,
              missing_qty: missingQty
            })
          })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              checkbox.checked = true;
              checkbox.disabled = true;
              missingQtyInput.disabled = true;
              // Update physical qty
              if (physicalQtyInput) {
                physicalQtyInput.value = totalQty - parseInt(missingQty);
              }
                  window.location.reload(); // Reload page after success

              // Update process status icon to green
              const processIcons = row.querySelectorAll('.d-flex > div');
              if (processIcons.length > 0) {
                processIcons[0].style.backgroundColor = '#0c8249';
              }
             

              

              // Enable Accept and Reject buttons
              const acceptBtn = row.querySelector('.btn-twitter');
              const rejectBtn = row.querySelector('.btn-youtube');
              if (acceptBtn) acceptBtn.disabled = false;
              if (rejectBtn) rejectBtn.disabled = false;
            } else {
              Swal.fire('Error', data.error || 'Failed to save checkbox', 'error');
              checkbox.checked = false;
            }
          })
          .catch(() => {
            Swal.fire('Error', 'Network error', 'error');
            checkbox.checked = false;
          });
        });
      });
    });
    </script>

<!--Accept functionality - Updated with confirmation dialog like IS_PickTable-->
<script nonce="{{csp_nonce}}">
console.log('🚀 Starting Accept Button Debug Script');

document.addEventListener("DOMContentLoaded", function () {
    console.log('📋 DOM Content Loaded - Starting Debug');
    
    const acceptButtons = document.querySelectorAll('.btn-twitter');
    console.log('🔍 Found accept buttons:', acceptButtons.length);
    
    setTimeout(() => {
        console.log('⏰ Timeout reached, initializing...');
        initializeAcceptFunctionality();
    }, 1000);
});

function initializeAcceptFunctionality() {
    console.log('🎬 Initializing Accept Functionality');
    
    addDelinkModal();
    addDelinkStyles();
    
    setTimeout(() => {
        setupAcceptButtons();
    }, 100);
}

function addDelinkStyles() {
    console.log('🎨 Adding Compact Delink Styles');
    
    if (document.getElementById('delink-styles')) {
        console.log('⚠️ Styles already exist, skipping');
        return;
    }
    
    const delinkModalCSS = `
    .delink-modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
    }

    .delink-modal-content {
        background-color: #fff;
        margin: 8% auto;
        padding: 15px;
        border: none;
        border-radius: 8px;
        width: 85%;
        max-width: 450px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }

    .delink-close {
        color: #aaa;
        float: right;
        font-size: 22px;
        font-weight: bold;
        cursor: pointer;
    }

    .delink-close:hover {
        color: #000;
    }

    .delink-table, .top-tray-table {
        width: 100%;
        border-collapse: collapse;
        margin: 8px 0;
        border-radius: 6px;
        overflow: hidden;
        font-size: 12px;
    }

    .delink-table th {
        background: #e74c3c;
        color: white;
        padding: 6px 8px;
        text-align: center;
        font-weight: 600;
        font-size: 11px;
    }

    .delink-table td {
        padding: 4px;
        text-align: center;
        border: 1px solid #ddd;
        background: #f9f9f9;
    }

    .top-tray-table th {
        background: #27ae60;
        color: white;
        padding: 6px 8px;
        text-align: center;
        font-weight: 600;
        font-size: 11px;
    }

    .top-tray-table td {
        padding: 4px;
        text-align: center;
        border: 1px solid #ddd;
        background: #f8fff8;
    }

    .delink-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
        padding: 10px 0;
    }

    .delink-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 20px;
        font-weight: 600;
        cursor: pointer;
        font-size: 12px;
        min-width: 80px;
    }

    .delink-btn-confirm {
        background: #27ae60;
        color: white;
    }

    .delink-btn-confirm:disabled {
        background: #95a5a6;
        cursor: not-allowed;
        opacity: 0.5;
    }

    .delink-btn-cancel {
        background: #95a5a6;
        color: white;
    }

    .section-header {
        background: #f8f9fa;
        padding: 6px 10px;
        border-radius: 4px;
        margin: 8px 0 6px 0;
        border-left: 3px solid #028084;
        font-weight: 600;
        color: #2c3e50;
        font-size: 14px;
    }

    .missing-qty-info {
        background: #fff3cd;
        border: 2px solid #ffc107;
        border-radius: 6px;
        padding: 8px 12px;
        margin: 8px 0;
        color: #856404;
        font-weight: 600;
        text-align: center;
        font-size: 13px;
    }

    .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #028084;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .error-message {
        background: #ffebee;
        border: 2px solid #f44336;
        color: #c62828;
        padding: 8px 12px;
        border-radius: 4px;
        margin: 8px 0;
        text-align: center;
        font-weight: 600;
        font-size: 12px;
    }

    .tray-id-error {
        font-size: 10px;
        margin-top: 2px;
        padding: 2px 4px;
        border-radius: 3px;
        font-weight: 600;
    }
    `;
    
    const styleSheet = document.createElement("style");
    styleSheet.id = 'delink-styles';
    styleSheet.textContent = delinkModalCSS;
    document.head.appendChild(styleSheet);
    console.log('✅ Compact styles added successfully');
}

function addDelinkModal() {
    console.log('🏗️ Adding Compact Delink Modal');
    
    if (document.getElementById('delinkModal')) {
        console.log('⚠️ Modal already exists, skipping');
        return;
    }
    
    const modalHTML = `
    <div id="delinkModal" class="delink-modal">
        <div class="delink-modal-content">
            <span class="delink-close" id="closeDelinkModal">&times;</span>
            
            <h2 style="text-align: center; color: #2c3e50; margin: 0 0 12px 0; font-size: 16px; font-weight: 600;">
                Set Top Tray
            </h2>
            
            <div class="missing-qty-info">
                <i class="fa fa-info-circle" style="margin-right: 4px;"></i>
                Missing Quantity: <span id="delinkMissingQty">0</span> pieces detected
            </div>
            
            <div id="delinkLoadingDiv" style="text-align: center; padding: 15px;">
                <div class="loading-spinner"></div>
                Calculating delink requirements...
            </div>
            
            <div id="delinkContentDiv" style="display: none;">
                <div id="delinkTraysSection" style="display: none;">
                    <div class="section-header">
                        <i class="fa fa-unlink" style="margin-right: 6px; color: #e74c3c; font-size: 12px;"></i>
                        Trays to Delink (<span id="delinkCount">0</span> trays)
                    </div>
                    <table class="delink-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">S.No</th>
                                <th>Tray ID</th>
                            </tr>
                        </thead>
                        <tbody id="delinkTableBody">
                        </tbody>
                    </table>
                </div>
                
                <div id="topTraySection" style="display: none;">
                    <div class="section-header">
                        <i class="fa fa-layer-group" style="margin-right: 6px; color: #27ae60; font-size: 12px;"></i>
                        Top Tray (Partial)
                    </div>
                    <table class="top-tray-table">
                        <thead>
                            <tr>
                                <th>Tray ID</th>
                                <th style="width: 60px;">Remaining Qty</th>
                            </tr>
                        </thead>
                        <tbody id="topTrayTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div id="delinkErrorDiv" class="error-message" style="display: none;">
            </div>
            
            <div class="delink-buttons">
                <button id="confirmDelinkBtn" class="delink-btn delink-btn-confirm" style="display: none;" disabled>
                    <i class="fa fa-check" style="margin-right: 4px;"></i>
                    Submit
                </button>
                <button id="cancelDelinkBtn" class="delink-btn delink-btn-cancel">
                    <i class="fa fa-times" style="margin-right: 4px;"></i>
                    Cancel
                </button>
            </div>
        </div>
    </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    console.log('✅ Compact modal added successfully');
    
    setupModalEventListeners();
}

function setupAcceptButtons() {
    console.log('🔧 Setting up Accept Buttons');
    
    const acceptButtons = document.querySelectorAll('.btn-twitter');
    console.log(`🎯 Found ${acceptButtons.length} accept buttons`);
    
    if (acceptButtons.length === 0) {
        console.error('❌ No accept buttons found!');
        return;
    }
    
    acceptButtons.forEach((acceptBtn, index) => {
        console.log(`🔄 Setting up button ${index}:`, acceptBtn);
        
        const newBtn = acceptBtn.cloneNode(true);
        acceptBtn.parentNode.replaceChild(newBtn, acceptBtn);
        
        newBtn.addEventListener('click', function(event) {
            console.log('🖱️ Accept button clicked!', event);
            
            event.preventDefault();
            event.stopPropagation();
            
            if (newBtn.disabled) {
                console.log('⚠️ Button is disabled, ignoring click');
                return;
            }
            
            handleAcceptButtonClick(newBtn);
        });
        
        console.log(`✅ Button ${index} setup complete`);
    });
    
    console.log('🎉 All accept buttons setup complete');
}

function handleAcceptButtonClick(acceptBtn) {
    console.log('🎬 Handling accept button click');
    
    const row = acceptBtn.closest('tr');
    console.log('📍 Found row:', row);
    
    let lotId = acceptBtn.getAttribute('data-lot-id');
    console.log('🏷️ Lot ID from button:', lotId);
    
    if (!lotId) {
        const checkbox = row ? row.querySelector('.brass-checkbox') : null;
        lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
        console.log('🏷️ Lot ID from checkbox:', lotId);
    }
    
    if (!lotId) {
        lotId = row ? row.getAttribute('data-stock-lot-id') : null;
        console.log('🏷️ Lot ID from row:', lotId);
    }
    
    if (!lotId) {
        console.error('❌ Lot ID not found!');
        showAlert('Error', 'Lot ID not found', 'error');
        return;
    }
    
    console.log('✅ Using Lot ID:', lotId);
    
    const missingQtyInput = row ? row.querySelector('.missing-qty-input') : null;
    const missingQty = missingQtyInput ? parseInt(missingQtyInput.value) || 0 : 0;
    console.log('📊 Missing quantity:', missingQty);
    
    if (missingQty > 0) {
        console.log('🔗 Showing delink modal for missing qty:', missingQty);
        showDelinkModal(lotId, missingQty);
    } else {
        console.log('✅ Showing normal accept confirmation');
        showNormalAcceptConfirmation(lotId);
    }
}

function showAlert(title, text, icon) {
    console.log('🚨 Showing alert:', title, text, icon);
    
    if (typeof Swal !== 'undefined') {
        Swal.fire(title, text, icon);
    } else {
        alert(title + (text ? '\n' + text : ''));
    }
}

function showConfirm(title, text, onConfirm) {
    console.log('❓ Showing confirmation:', title, text);
    
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            title: title,
            text: text,
            icon: 'question',
            showCancelButton: true,
            confirmButtonColor: '#28a745',
            cancelButtonColor: '#6c757d',
            confirmButtonText: 'Yes, Accept',
            cancelButtonText: 'Cancel',
            reverseButtons: true
        }).then((result) => {
            if (result.isConfirmed) {
                onConfirm();
            }
        });
    } else {
        if (confirm(title + '\n' + text)) {
            onConfirm();
        }
    }
}

function showSuccess(title, onComplete) {
    console.log('🎉 Showing success:', title);
    
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            icon: 'success',
            title: title,
            showConfirmButton: false,
            timer: 1200
        }).then(onComplete);
    } else {
        alert(title);
        onComplete();
    }
}

function showNormalAcceptConfirmation(lotId) {
    console.log('📝 Showing normal accept confirmation for lot:', lotId);
    
    showConfirm(
        'Lot Accept', 
        'Are you sure you want to accept this lot?',
        function() {
            console.log('✅ User confirmed accept');
            performAcceptAction(lotId);
        }
    );
}

function showDelinkModal(lotId, missingQty) {
    console.log('🔗 Showing compact delink modal for lot:', lotId, 'missing qty:', missingQty);
    
    const modal = document.getElementById('delinkModal');
    if (!modal) {
        console.error('❌ Delink modal not found!');
        showNormalAcceptConfirmation(lotId);
        return;
    }
    
    const missingQtySpan = document.getElementById('delinkMissingQty');
    const loadingDiv = document.getElementById('delinkLoadingDiv');
    const contentDiv = document.getElementById('delinkContentDiv');
    const errorDiv = document.getElementById('delinkErrorDiv');
    const confirmBtn = document.getElementById('confirmDelinkBtn');
    
    if (missingQtySpan) missingQtySpan.textContent = missingQty;
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (contentDiv) contentDiv.style.display = 'none';
    if (errorDiv) errorDiv.style.display = 'none';
    if (confirmBtn) {
        confirmBtn.style.display = 'none';
        confirmBtn.disabled = true;
    }
    
    modal.style.display = 'block';
    console.log('👁️ Modal should be visible now');
    
    modal.dataset.lotId = lotId;
    modal.dataset.missingQty = missingQty;
    
    fetchDelinkCalculation(lotId, missingQty);
}

function fetchDelinkCalculation(lotId, missingQty) {
    console.log('📡 Fetching delink calculation for lot:', lotId, 'missing qty:', missingQty);
    
    const loadingDiv = document.getElementById('delinkLoadingDiv');
    const contentDiv = document.getElementById('delinkContentDiv');
    const errorDiv = document.getElementById('delinkErrorDiv');
    const confirmBtn = document.getElementById('confirmDelinkBtn');
    
    const apiUrl = `/nickle_inspection_zone_two/nq_zone_tray_delink_top_tray_calc/?lot_id=${encodeURIComponent(lotId)}&missing_qty=${missingQty}`;
    console.log('🌐 API URL:', apiUrl);
    
    fetch(apiUrl)
        .then(response => {
            console.log('📥 API Response status:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('📊 API Response data:', data);
            
            if (loadingDiv) loadingDiv.style.display = 'none';
            
            if (data.success) {
                populateDelinkTables(data);
                if (contentDiv) contentDiv.style.display = 'block';
                if (confirmBtn) confirmBtn.style.display = 'inline-block';
            } else {
                showDelinkError(data.error || 'Failed to calculate delink requirements');
            }
        })
        .catch(error => {
            console.error('❌ API Error:', error);
            if (loadingDiv) loadingDiv.style.display = 'none';
            showDelinkError('Network error while calculating delink requirements.');
        });
}

function populateDelinkTables(data) {
    console.log('📋 Populating compact delink tables with data:', data);
    
    const delinkTraysSection = document.getElementById('delinkTraysSection');
    const topTraySection = document.getElementById('topTraySection');
    const delinkTableBody = document.getElementById('delinkTableBody');
    const topTrayTableBody = document.getElementById('topTrayTableBody');
    const delinkCountSpan = document.getElementById('delinkCount');
    
    if (delinkTableBody) delinkTableBody.innerHTML = '';
    if (topTrayTableBody) topTrayTableBody.innerHTML = '';
    
    // Compact Delink Trays Section
    if (data.delink_trays && data.delink_trays.length > 0) {
        if (delinkCountSpan) delinkCountSpan.textContent = data.delink_count || data.delink_trays.length;
        data.delink_trays.forEach((_, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td style="font-weight: 600; background: #ffebee; padding: 4px; font-size: 12px; width: 40px;">${index + 1}</td>
                <td style="padding: 4px;">
                    <input type="text" class="form-control delink-tray-input" value="" placeholder="Scan Tray ID" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
                    <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
                </td>
            `;
            if (delinkTableBody) delinkTableBody.appendChild(row);
        });
        if (delinkTraysSection) delinkTraysSection.style.display = 'block';
    } else {
        if (delinkTraysSection) delinkTraysSection.style.display = 'none';
    }

    // Compact Top Tray Section
    if (data.top_tray) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td style="padding: 4px;">
                <input type="text" id="topTrayIdInput" class="form-control" value="" placeholder="Scan Top Tray ID" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
                <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
            </td>
            <td style="font-weight: 600; color: #2e7d32; padding: 4px; font-size: 12px; text-align: center; width: 60px;">${data.top_tray.qty}</td>
        `;
        if (topTrayTableBody) topTrayTableBody.appendChild(row);
        if (topTraySection) topTraySection.style.display = 'block';
    } else {
        if (topTraySection) topTraySection.style.display = 'none';
    }

    setTimeout(() => {
        attachValidationToInputs();
    }, 100);
}
function attachValidationToInputs() {
  console.log('[ACCEPT-VALIDATION] Setting up Enter key validation with duplicate prevention');
  
  const inputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
  const inputArray = Array.from(inputs);
  console.log(`[ACCEPT-VALIDATION] Found ${inputs.length} inputs`);
  
  inputs.forEach((input, index) => {
    console.log(`[ACCEPT-VALIDATION] Configuring input ${index}`);
    
    // Clean rebuild to remove conflicts
    const newInput = input.cloneNode(true);
    input.parentNode.replaceChild(newInput, input);
    inputArray[index] = newInput;
    
    // Error div setup
    let errorDiv = newInput.parentElement.querySelector('.tray-id-error');
    if (!errorDiv) {
      errorDiv = document.createElement('div');
      errorDiv.className = 'tray-id-error';
      errorDiv.style.cssText = 'display: none; font-size: 10px; margin-top: 2px; font-weight: 600;';
      newInput.parentElement.appendChild(errorDiv);
    }
    
    // Find next input for navigation
    const findNextInput = () => {
      const currentIndex = inputArray.indexOf(newInput);
      return currentIndex < inputArray.length - 1 ? inputArray[currentIndex + 1] : null;
    };
    
    // Move to next field
    const moveToNext = () => {
      const nextInput = findNextInput();
      if (nextInput) {
        console.log(`[ACCEPT-NAVIGATION] Moving to next field`);
        setTimeout(() => {
          nextInput.focus();
          nextInput.select();
        }, 100);
      } else {
        console.log(`[ACCEPT-NAVIGATION] Last field - focusing submit button`);
        const submitBtn = document.getElementById('confirmDelinkBtn');
        if (submitBtn && !submitBtn.disabled) {
          setTimeout(() => submitBtn.focus(), 100);
        }
      }
    };
    
    // Check for duplicates across all inputs
    const checkForDuplicates = (trayId) => {
      let duplicateFound = false;
      inputArray.forEach((otherInput, otherIndex) => {
        if (otherIndex !== index && otherInput.value.trim() === trayId) {
          duplicateFound = true;
        }
      });
      return duplicateFound;
    };
    
    // Reset input state
    const resetState = () => {
      newInput._hasError = false;
      newInput.style.border = '';
      newInput.style.backgroundColor = '';
      errorDiv.style.display = 'none';
    };
    
    // Main validation function
    const validateAndMove = (shouldMoveOnSuccess = false) => {
      const trayId = newInput.value.trim();
      console.log(`[ACCEPT-VALIDATE] Input ${index}: "${trayId}"`);
      
      resetState();
      
      if (!trayId) {
        validateAllInputsAndUpdateButtons();
        if (shouldMoveOnSuccess) moveToNext();
        return;
      }
      
      // FIRST: Check for duplicates
      if (checkForDuplicates(trayId)) {
        console.log(`[ACCEPT-DUPLICATE] Found duplicate: ${trayId}`);
        newInput._hasError = true;
        newInput.style.border = '2px solid #dc3545';
        newInput.style.backgroundColor = '#ffebee';
        errorDiv.textContent = `Duplicate Tray ID: "${trayId}"`;
        errorDiv.style.color = '#dc3545';
        errorDiv.style.display = 'block';
        
        // Stay on current field and select text
        setTimeout(() => {
          newInput.focus();
          newInput.select();
        }, 100);
        
        validateAllInputsAndUpdateButtons();
        return;
      }
      
      // SECOND: API validation
      newInput.style.border = '2px solid #ffc107';
      newInput.style.backgroundColor = '#fff3cd';
      errorDiv.textContent = 'Validating...';
      errorDiv.style.color = '#856404';
      errorDiv.style.display = 'block';
      
      const lotId = getCurrentLotId();
      
      fetch(`/nickle_inspection_zone_two/nq_zone_validate_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(data => {
          console.log(`[ACCEPT-API-RESPONSE] Input ${index}:`, data);
          
          if (data && data.exists && data.valid_for_lot) {
            // SUCCESS
            newInput._hasError = false;
            newInput.style.border = '2px solid #28a745';
            newInput.style.backgroundColor = '#f8fff8';
            errorDiv.textContent = 'Available!';
            errorDiv.style.color = '#28a745';
            errorDiv.style.display = 'block';
            
            // Auto-hide success message
            setTimeout(() => errorDiv.style.display = 'none', 1500);
            
            // Move to next field if Enter was pressed
            if (shouldMoveOnSuccess) {
              setTimeout(moveToNext, 200);
            }
            
          } else {
            // ERROR
            newInput._hasError = true;
            newInput.style.border = '2px solid #dc3545';
            newInput.style.backgroundColor = '#ffebee';
            errorDiv.textContent = data.error || 'Invalid tray ID';
            errorDiv.style.color = '#dc3545';
            errorDiv.style.display = 'block';
            
            // Stay on current field
            setTimeout(() => {
              newInput.focus();
              newInput.select();
            }, 100);
          }
          
          validateAllInputsAndUpdateButtons();
        })
        .catch(error => {
          console.error(`[ACCEPT-API-ERROR] Input ${index}:`, error);
          newInput._hasError = true;
          newInput.style.border = '2px solid #dc3545';
          newInput.style.backgroundColor = '#ffebee';
          errorDiv.textContent = 'Network error';
          errorDiv.style.color = '#dc3545';
          errorDiv.style.display = 'block';
          
          validateAllInputsAndUpdateButtons();
        });
    };
    
    // ENTER KEY HANDLER
    newInput.addEventListener('keydown', function(e) {
      console.log(`[ACCEPT-KEY] Input ${index} - Key: ${e.key}`);
      
      if (e.key === 'Enter') {
        console.log(`[ACCEPT-ENTER] Processing Enter key on input ${index}`);
        e.preventDefault();
        e.stopPropagation();
        
        // Validate and move to next field
        validateAndMove(true);
        return false;
      }
      
      if (e.key === 'Tab' && this._hasError) {
        // Block Tab if there's an error
        e.preventDefault();
        this.focus();
        this.select();
        return false;
      }
    });
    
    // BLUR HANDLER (validate but don't move)
    newInput.addEventListener('blur', function() {
      console.log(`[ACCEPT-BLUR] Input ${index}`);
      validateAndMove(false);
    });
    
    // INPUT HANDLER (clear errors while typing)
    newInput.addEventListener('input', function() {
      if (this._hasError) {
        resetState();
        validateAllInputsAndUpdateButtons();
      }
    });
    
    console.log(`[ACCEPT-READY] Input ${index} configured with Enter navigation and duplicate prevention`);
  });
  
  console.log('[ACCEPT-SUCCESS] All accept button inputs ready for Enter + duplicate validation');
}


function getCurrentLotId() {
  
  
    const modal = document.getElementById('delinkModal');
    if (modal && modal.dataset.lotId) {
        return modal.dataset.lotId;
    }
    
    const acceptButtons = document.querySelectorAll('.btn-twitter');
    if (acceptButtons.length > 0) {
        const firstButton = acceptButtons[0];
        let lotId = firstButton.getAttribute('data-lot-id');
        
        if (!lotId) {
            const row = firstButton.closest('tr');
            const checkbox = row ? row.querySelector('.brass-checkbox') : null;
            lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
        }
        
        if (!lotId) {
            const row = firstButton.closest('tr');
            lotId = row ? row.getAttribute('data-stock-lot-id') : null;
        }
        
        return lotId;
    }
    
    return null;
}



function validateAllInputsAndUpdateButtons() {
    const confirmBtn = document.getElementById('confirmDelinkBtn');
    if (!confirmBtn) return;
    
    const allInputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
    let hasErrors = false;
    let hasEmptyInputs = false;
    
    allInputs.forEach(input => {
        if (input._hasError) {
            hasErrors = true;
        }
        if (!input.value.trim()) {
            hasEmptyInputs = true;
        }
    });
    
    if (hasErrors || hasEmptyInputs) {
        confirmBtn.disabled = true;
        confirmBtn.style.opacity = '0.5';
        confirmBtn.style.cursor = 'not-allowed';
    } else {
        confirmBtn.disabled = false;
        confirmBtn.style.opacity = '1';
        confirmBtn.style.cursor = 'pointer';
    }
}

function showDelinkError(message) {
    console.log('❌ Showing delink error:', message);
    
    const errorDiv = document.getElementById('delinkErrorDiv');
    if (errorDiv) {
        errorDiv.innerHTML = `<i class="fa fa-exclamation-triangle" style="margin-right: 4px;"></i>${message}`;
        errorDiv.style.display = 'block';
    }
}

function performAcceptAction(lotId) {
    console.log('🎯 Performing accept action for lot:', lotId);
    
    fetch('/nickle_inspection_zone_two/nq_zone_accepted_form/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({ stock_lot_id: lotId })
    })
    .then(res => {
        console.log('📥 Accept API Response status:', res.status);
        
        if (res.redirected) {
            console.log('🔄 Redirected to:', res.url);
            window.location.href = res.url;
            return;
        }
        return res.json();
    })
    .then(data => {
        console.log('📊 Accept API Response data:', data);
        
        if (data && data.success) {
            showSuccess('Accepted successfully!', function() {
                window.location.reload();
            });
        } else if (data && data.error) {
            showAlert('Error', data.error, 'error');
        }
    })
    .catch(error => {
        console.error('❌ Accept API Error:', error);
        showAlert('Error', 'Network error', 'error');
    });
}

function setupModalEventListeners() {
    console.log('🎪 Setting up modal event listeners');
    
    const delinkModal = document.getElementById('delinkModal');
    const closeDelinkModal = document.getElementById('closeDelinkModal');
    const cancelDelinkBtn = document.getElementById('cancelDelinkBtn');
    const confirmDelinkBtn = document.getElementById('confirmDelinkBtn');
    
    if (closeDelinkModal) {
        closeDelinkModal.addEventListener('click', function() {
            console.log('❌ Close button clicked');
            if (delinkModal) delinkModal.style.display = 'none';
        });
    }
    
    if (cancelDelinkBtn) {
        cancelDelinkBtn.addEventListener('click', function() {
            console.log('🚫 Cancel button clicked');
            if (delinkModal) delinkModal.style.display = 'none';
        });
    }
    
    if (delinkModal) {
        delinkModal.addEventListener('click', function(event) {
            if (event.target === delinkModal) {
                console.log('🖱️ Clicked outside modal, closing');
                delinkModal.style.display = 'none';
            }
        });
    }
    
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && delinkModal && delinkModal.style.display === 'block') {
            console.log('⌨️ ESC key pressed, closing modal');
            delinkModal.style.display = 'none';
        }
    });
    
    if (confirmDelinkBtn) {
        confirmDelinkBtn.addEventListener('click', function() {
            console.log('✅ Confirm delink button clicked');
            
            const lotId = delinkModal ? delinkModal.dataset.lotId : null;
            const missingQty = delinkModal ? delinkModal.dataset.missingQty : null;
            
            console.log('📊 Confirming delink for lot:', lotId, 'missing qty:', missingQty);
            
            if (!lotId) {
                showAlert('Error', 'Lot ID not found', 'error');
                return;
            }
            
            const delinkTrayInputs = document.querySelectorAll('.delink-tray-input');
            const topTrayInput = document.getElementById('topTrayIdInput');
            
            const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);
            const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';
            
            const topTrayQtyElement = document.querySelector('#topTrayTableBody td:last-child');
            const topTrayQty = topTrayQtyElement ? topTrayQtyElement.textContent.trim() : '';
            
            console.log('📝 Collected tray IDs:', { delinkTrayIds, topTrayId, topTrayQty });
            
            if (delinkModal) delinkModal.style.display = 'none';
            
            showConfirm(
                'Confirm Accept',
                'This will accept the remaining lot. Are you sure?',
                function() {
                    performDelinkAcceptAction(lotId, delinkTrayIds, topTrayId, topTrayQty);
                }
            );
        });
    }
    
    console.log('✅ Modal event listeners setup complete');
}

function performDelinkAcceptAction(lotId, delinkTrayIds, topTrayId, topTrayQty) {
    console.log('🎯 Performing delink accept action:', { lotId, delinkTrayIds, topTrayId, topTrayQty });

    let parsedTopTrayQty = null;
    if (topTrayQty && topTrayQty !== '') {
        parsedTopTrayQty = parseInt(topTrayQty, 10);
        if (isNaN(parsedTopTrayQty)) {
            console.error('❌ Invalid top tray quantity:', topTrayQty);
            showAlert('Error', 'Invalid top tray quantity', 'error');
            return;
        }
    }

    const payload = {
        lot_id: lotId,
        delink_tray_ids: delinkTrayIds,
        top_tray_id: topTrayId,
        top_tray_qty: parsedTopTrayQty
    };

    console.log('📤 Sending delink payload:', payload);

    fetch('/nickle_inspection_zone_two/nq_zone_tray_delink_and_top_tray_update/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
        console.log('📊 Delink & Top Tray Update API Response:', data);
        if (data && data.success) {
            console.log('✅ Delink successful, now calling accept API...');
            
            return fetch('/nickle_inspection_zone_two/nq_zone_accepted_form/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ stock_lot_id: lotId })
            });
        } else {
            throw new Error(data.error || 'Failed to update trays');
        }
    })
    .then(res => {
        console.log('📥 Accept API Response status:', res.status);
        
        if (res.redirected) {
            console.log('🔄 Redirected to:', res.url);
            window.location.href = res.url;
            return;
        }
        return res.json();
    })
    .then(data => {
        console.log('📊 Accept API Response data:', data);
        
        if (data && data.success) {
            showSuccess('Accept completed successfully!', function() {
                window.location.reload();
            });
        } else if (data && data.error) {
            showAlert('Error', 'Delink successful but accept failed: ' + data.error, 'error');
        }
    })
    .catch(error => {
        console.error('❌ Delink or Accept API Error:', error);
        showAlert('Error', error.message || 'Network error during operation', 'error');
    });
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

console.log('📝 Compact script loaded, waiting for DOM...');
</script>

   
    <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var textarea = tooltip.querySelector("textarea");
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the lot_id from the row (tr) data attribute
            var row = trigger.closest("tr");
            var lotId = row ? row.getAttribute('data-stock-lot-id') : null;
            if (!lotId) {
              Swal.fire('Error', 'Lot ID not found.', 'error');
              return;
            }
            fetch('/nickle_inspection_zone_two/nq_zone_save_ip_pick_remark/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                lot_id: lotId,
                remark: remark
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire({
                  icon: 'success',
                  title: 'Remark saved!',
                  timer: 1200,
                  showConfirmButton: false
                }).then(() => {
                  // Make the textarea readonly
                  if (textarea) {
                    textarea.setAttribute("readonly", true);
                  }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }
                                                      // Change chat icon color after remark is saved
                  const chatIcon = trigger.querySelector('img[alt="Chat"]');
                  if (chatIcon) {
                    chatIcon.style.filter = 'grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)';
                    chatIcon.style.opacity = '1';
                  }

                  hideTooltip(); // optional if you still want to hide the tooltip
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });
    });
  </script>
    <!-- Script for clearing "Tray ID" while hitting "Redo" icon -->
   <script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
        const redoBtn = document.getElementById("trayScanRedoBtn");
        if (redoBtn) {
          redoBtn.title = "Redo"; // Set tooltip on mouse hover
        }
      
        const detailsDiv = document.getElementById("trayScanDetails_BQ");
        const table = document.getElementById('order-listing');
        let msgBar = document.getElementById('dp-table-msg-bar');
      
        // Create message bar if not present
        if (!msgBar && table) {
          msgBar = document.createElement('div');
          msgBar.id = 'dp-table-msg-bar';
          msgBar.style.display = 'none';
          msgBar.style.width = '100%';
          msgBar.style.margin = '0 0 8px 0';
          msgBar.style.padding = '10px 24px';
          msgBar.style.background = '#d1eaff';
          msgBar.style.color = '#0056b3';
          msgBar.style.fontWeight = 'bold';
          msgBar.style.borderRadius = '8px';
          msgBar.style.fontSize = '1.1rem';
          msgBar.style.textAlign = 'center';
          msgBar.style.transition = 'opacity 0.3s, background 0.3s, color 0.3s';
          table.parentNode.insertBefore(msgBar, table);
        }
      
        // --- FIX: Show alert inside modal form, not on table ---
        let formMsgBar = document.getElementById('tray-id-clear-msg-bar');
        const modal = document.getElementById('trayScanModal_BQ');
        if (!formMsgBar && modal) {
          formMsgBar = document.createElement('div');
          formMsgBar.id = 'tray-id-clear-msg-bar';
          formMsgBar.style.display = 'none';
          formMsgBar.style.width = '100%';
          formMsgBar.style.margin = '0 0 8px 0';
          formMsgBar.style.padding = '8px 16px';
          formMsgBar.style.background = '#ffd6d6';
          formMsgBar.style.color = '#b30000';      // red text
          formMsgBar.style.fontWeight = 'bold';
          formMsgBar.style.borderRadius = '8px';
          formMsgBar.style.fontSize = '14px';      // 14px font
          formMsgBar.style.textAlign = 'center';
          formMsgBar.style.transition = 'opacity 0.3s, background 0.3s, color 0.3s';
          const modalContent = modal.querySelector('.tray-scan-modal-BQ-content');
          if (modalContent) {
            modalContent.insertBefore(formMsgBar, modalContent.firstChild);
          }
        }
        // -------------------------------------------------------
      
        if (redoBtn && detailsDiv) {
          redoBtn.addEventListener("click", function () {
            detailsDiv.querySelectorAll('input[type="text"]').forEach(function(input) {
              input.value = "";
            });
            // Show line alert INSIDE MODAL FORM
            if (formMsgBar) {
              formMsgBar.textContent = "Tray ID Cleared Successfully";
              formMsgBar.style.display = 'block';
              formMsgBar.style.opacity = '1';
              formMsgBar.style.background = '#d1eaff';
              formMsgBar.style.color = '#0056b3';
              setTimeout(function () {
                formMsgBar.style.opacity = '0';
                setTimeout(function () { formMsgBar.style.display = 'none'; }, 300);
              }, 2000);
            }
          });
        }
      });
   </script>
   <!-- Script for Tray Validate Status column -- enable/disable of table column -->
   <script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
        const validateBtn = document.getElementById("trayValidateBtn");
        const detailsDiv = document.getElementById("trayScanDetails_BQ");
        let validationEnabled = false;
      
        if (validateBtn && detailsDiv) {
          validateBtn.addEventListener("click", function () {
            validationEnabled = !validationEnabled;
      
            // Toggle header
            const header = detailsDiv.querySelector('.tray-validation-status-header');
            if (header) {
              header.style.opacity = validationEnabled ? "1" : "0.3";
              header.style.pointerEvents = validationEnabled ? "auto" : "none";
            }
      
            // Toggle all cells in the column
            detailsDiv.querySelectorAll('.tray-validation-status-cell').forEach(function(cell) {
              cell.style.opacity = validationEnabled ? "1" : "0.3";
              cell.style.pointerEvents = validationEnabled ? "auto" : "none";
            });
          });
        }
      });
   </script>

  <!-- Table Sorting Script -->
  <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      const table = document.getElementById("order-listing");
      if (!table) return;
      const headers = table.querySelectorAll("thead th");
      const tbody = table.querySelector("tbody");
      let sortDirection = {};
      headers.forEach((header, index) => {
        header.style.cursor = "pointer";
        header.addEventListener("click", function () {
          const rows = Array.from(tbody.querySelectorAll("tr"));
          const dir = sortDirection[index] === "asc" ? "desc" : "asc";
          sortDirection[index] = dir;
          rows.sort((a, b) => {
            const cellA = a.children[index].textContent.trim();
            const cellB = b.children[index].textContent.trim();
            const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
            const valB = isNaN(cellB) ? cellB : parseFloat(cellB);
            if (valA < valB) return dir === "asc" ? -1 : 1;
            if (valA > valB) return dir === "asc" ? 1 : -1;
            return 0;
          });
          tbody.innerHTML = "";
          rows.forEach((row) => tbody.appendChild(row));
        });
      });
    });
  </script>



  <!-- Script for Text Remarks (unchanged) -->
  <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", hideTooltip);
        }
      });
    });
  </script>

<!-- Active table row highlight -->
<script nonce="{{ csp_nonce }}">
// Row highlight & position swap for Accept, Reject, and View actions (DP_PickTable style)
document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('dp-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'dp-row-action-highlight-style';
    style.innerHTML = `
      .dp-row-action-highlight {
        transition: box-shadow 1.3s;
        background-color: #fff5bd !important;
        animation: highlightAnimation 2s ease-in-out;
      }
    `;
    document.head.appendChild(style);
  }

  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  // --- Accept Alert Integration: Clear highlight and restore row on Yes/Cancel ---
  document.querySelectorAll('.btn-twitter').forEach(function(acceptBtn) {
    acceptBtn.addEventListener('click', function() {
      if (typeof Swal !== 'undefined') {
        const origSwalFire = Swal.fire;
        Swal.fire = function(opts) {
          // Force patch for any Accept button click (don't rely only on opts.title)
          const swalPromise = origSwalFire.call(Swal, opts);
          swalPromise.then(function(result) {
            // Always restore row on Yes or Cancel
            restoreRowPosition();
            // Unpatch
            Swal.fire = origSwalFire;
          });
          return swalPromise;
        };
      }
    });
  });

  // Restore row to original position and remove highlight
  function restoreRowPosition() {
    if (movedRow && placeholderRow && placeholderRow.parentNode) {
      placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
      placeholderRow.parentNode.removeChild(placeholderRow);
      movedRow.classList.remove('dp-row-action-highlight');
      movedRow = null;
      placeholderRow = null;
      originalRowIndex = null;
    }
    document.querySelectorAll('tbody tr').forEach(function(row) {
      row.classList.remove('dp-row-action-highlight');
      row.classList.remove('highlighted-tray-scan');
    });
  }

  // Attach highlight/move for Accept, Reject, and View actions
  function attachRowHighlight(selector) {
    document.querySelectorAll(selector).forEach(function(btn) {
      btn.addEventListener('click', function(event) {
        var button = event.currentTarget;
        var row = button.closest('tr');
        document.querySelectorAll('tbody tr').forEach(function(row) {
          row.classList.remove('dp-row-action-highlight');
        });
        if (row && row.parentNode) {
          const tbody = row.parentNode;
          if (tbody.firstElementChild !== row) {
            if (movedRow && placeholderRow && placeholderRow.parentNode) {
              placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
              placeholderRow.parentNode.removeChild(placeholderRow);
              movedRow.classList.remove('dp-row-action-highlight');
              movedRow = null;
              placeholderRow = null;
              originalRowIndex = null;
            }
            originalRowIndex = Array.from(tbody.children).indexOf(row);
            movedRow = row;
            placeholderRow = document.createElement('tr');
            placeholderRow.style.display = 'none';
            for (let i = 0; i < row.children.length; i++) {
              placeholderRow.appendChild(document.createElement('td'));
            }
            tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
            tbody.insertBefore(row, tbody.firstElementChild);
          }
          row.classList.add('dp-row-action-highlight');
        }
      });
    });
  }

  // Accept, Reject, View (tray-scan-btn, tray-scan-btn-Jig, btn-twitter, tray-scan-btn-BQ-view)
  attachRowHighlight('.tray-scan-btn, .tray-scan-btn-Jig, .btn-twitter, .tray-scan-btn-BQ-view');

  // Restore on all modal closes (tray scan, day planning, new popup, etc)
  [
    'closeTrayScanModal',
    'closeTrayScanModal_DayPlanning',
    'closeNewPopupModal'
  ].forEach(function(id) {
    var btn = document.getElementById(id);
    if (btn) {
      btn.addEventListener('click', restoreRowPosition);
    }
  });

  // Also restore on modal backdrop click (for all modals)
  [
    'trayScanModal',
    'trayScanModal_DayPlanning',
    'newPopupModal'
  ].forEach(function(id) {
    var modal = document.getElementById(id);
    if (modal) {
      modal.addEventListener('click', function(event) {
        if (event.target === modal) restoreRowPosition();
      });
    }
  });

  // Restore on ESC key
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') restoreRowPosition();
  });

  // --- Fix: Also restore on SweetAlert Cancel button click (native or custom) ---
  document.addEventListener('click', function(event) {
    if (
      event.target &&
      (
        event.target.classList.contains('swal2-cancel') ||
        event.target.classList.contains('swal2-close') ||
        event.target.id === 'cancelButton'
      )
    ) {
      restoreRowPosition();
    }
  });

});
</script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  let openTooltip = null;

  // Helper function to completely close a tooltip
  function closeTooltip(tooltip, trigger) {
    if (tooltip) {
      console.log('🔴 Closing tooltip completely');
      
      // Remove pinned class
      tooltip.classList.remove("pinned");
      
      // Hide the entire tooltip completely
      tooltip.style.opacity = "0";
      tooltip.style.pointerEvents = "none";
      tooltip.style.visibility = "hidden";
      tooltip.style.display = "none"; // ✅ ADDED: Force display none
      
      // Hide buttons
      const infoBtn = tooltip.querySelector('.info-btn');
      const closeBtn = tooltip.querySelector('.close-btn');
      if (infoBtn) infoBtn.style.display = 'none';
      if (closeBtn) closeBtn.style.display = 'none';
      
      // Remove visual indicator from trigger
      if (trigger) {
        trigger.style.backgroundColor = '';
        trigger.style.borderRadius = '';
      }
      
      // Clear global reference
      openTooltip = null;
      
      console.log('✅ Tooltip completely closed');
    }
  }

  // Tooltip show/hide logic
  document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
    const tooltip = trigger.querySelector(".model-image-tooltip");

    trigger.addEventListener("mouseenter", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.display = "flex"; // ✅ ADDED: Reset display
        tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Show Info and Close buttons on hover
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      }
    });

    trigger.addEventListener("mouseleave", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.opacity = "0";
        tooltip.style.pointerEvents = "none";
        
        // Hide Info and Close buttons when not hovering and not pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'none';
        if (closeBtn) closeBtn.style.display = 'none';
      }
    });

    // Keep tooltip visible when hovering over it
    if (tooltip) {
      tooltip.addEventListener("mouseenter", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.display = "flex"; // ✅ ADDED: Reset display
          tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
        }
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Keep buttons visible when hovering over tooltip
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      });

      tooltip.addEventListener("mouseleave", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.opacity = "0";
          tooltip.style.pointerEvents = "none";
          
          // Hide buttons when leaving tooltip and not pinned
          const infoBtn = tooltip.querySelector('.info-btn');
          const closeBtn = tooltip.querySelector('.close-btn');
          if (infoBtn) infoBtn.style.display = 'none';
          if (closeBtn) closeBtn.style.display = 'none';
        }
      });
    }

    trigger.addEventListener("click", function (e) {
      e.stopPropagation();

      if (tooltip) {
        // Close any previously opened tooltip
        if (openTooltip && openTooltip !== tooltip) {
          const prevTrigger = openTooltip.closest('.model-hover-trigger');
          closeTooltip(openTooltip, prevTrigger);
        }

        tooltip.classList.add("pinned");
        tooltip.style.display = "flex"; // ✅ ADDED: Ensure display
        tooltip.style.visibility = "visible"; // ✅ ADDED: Ensure visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        openTooltip = tooltip;
        
        // Keep buttons visible when pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';

        // Add visual indicator that tooltip is pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      }
    });

    // ✅ Handle Info button click
    const infoBtn = tooltip?.querySelector('.info-btn');
    if (infoBtn) {
      // Initially hide the button
      infoBtn.style.display = 'none';
      
      infoBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        const modelNo = trigger.textContent.trim();
        
        if (typeof Swal !== 'undefined') {
          Swal.fire({
            title: 'Model Information',
            html: `<strong>Plating Stk No:</strong> ${modelNo}`,
            icon: 'info',
            confirmButtonText: 'OK',
            confirmButtonColor: '#007bff'
          });
        } else {
          alert('Model Information:\nPlating Stk No: ' + modelNo);
        }
      });
    }

    // ✅ FIXED: Handle Close button click - Complete tooltip closure
    const closeBtn = tooltip?.querySelector('.close-btn');
    if (closeBtn) {
      // Initially hide the button
      closeBtn.style.display = 'none';
      
      closeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        console.log('🔴 Close button clicked');
        
        // Use the helper function to completely close tooltip
        closeTooltip(tooltip, trigger);
        
        // Feedback animation for close button
        closeBtn.style.transform = 'scale(0.9)';
        setTimeout(() => {
          if (closeBtn.style) {
            closeBtn.style.transform = 'scale(1)';
          }
        }, 150);
      });
      
      // ✅ Add hover effect for close button
      closeBtn.addEventListener('mouseenter', function() {
        closeBtn.style.backgroundColor = '#c82333';
        closeBtn.style.transform = 'scale(1.05)';
      });
      
      closeBtn.addEventListener('mouseleave', function() {
        closeBtn.style.backgroundColor = '#dc3545';
        closeBtn.style.transform = 'scale(1)';
      });
    }
  });

  // ✅ ENHANCED: Close tooltip when clicking outside
  document.addEventListener("click", function (e) {
    if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
    }
  });

  // ✅ Close tooltip with ESC key
  document.addEventListener("keydown", function (e) {
    if (e.key === "Escape" && openTooltip) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
      console.log('✅ Tooltip closed with ESC key');
    }
  });

  // Prevent tooltip from closing when clicking inside it
  document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
    tooltip.addEventListener("click", function (e) {
      e.stopPropagation();
    });
  });
});
</script>


<!-- Script for Model / Stock No - Image Mouse Hover -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.model-hover-trigger').forEach(function(trigger) {
      const tooltip = trigger.querySelector('.model-image-tooltip');
      let currentIndex = 0;
      let tooltipPinned = false;
      let hoverTimeout = null;
      const images = Array.from(tooltip.querySelectorAll('.img-gallery img'));

      function showImages(start) {
        images.forEach((img, i) => {
          img.style.display = (i >= start && i < start + 3) ? 'block' : 'none';
        });
      }
      showImages(currentIndex);

      // Show immediately on mouseenter
      trigger.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving trigger (unless pinned)
      trigger.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            if (!tooltip.matches(':hover')) {
              tooltip.style.opacity = '0';
              tooltip.style.pointerEvents = 'none';
            }
          }, 300);
        }
      });

      // Keep visible when hovering over tooltip
      tooltip.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving tooltip (unless pinned)
      tooltip.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            tooltip.style.opacity = '0';
            tooltip.style.pointerEvents = 'none';
          }, 300);
        }
      });

      // Pin tooltip on click (make it sticky)
      trigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipPinned = true;
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
        clearTimeout(hoverTimeout);
        
        // Add visual indicator that it's pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      });

      // Unpin tooltip if user clicks outside
      document.addEventListener('mousedown', function(e) {
        if (!trigger.contains(e.target) && !tooltip.contains(e.target)) {
          tooltipPinned = false;
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
          
          // Remove visual indicator
          trigger.style.backgroundColor = '';
          trigger.style.borderRadius = '';
        }
      });

      // Handle scroll buttons with error handling
      const leftBtn = tooltip.querySelector('.img-scroll-left');
      const rightBtn = tooltip.querySelector('.img-scroll-right');
      
      if (leftBtn) {
        leftBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex > 0) {
            currentIndex--;
            showImages(currentIndex);
          }
        });
      }
      
      if (rightBtn) {
        rightBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex < images.length - 3) {
            currentIndex++;
            showImages(currentIndex);
          }
        });
      }

      // Add click event to images for modal slider
      images.forEach(function(img, idx) {
        img.style.cursor = 'pointer';
        img.addEventListener('click', function(e) {
          e.stopPropagation();
          openImageSlider(images.map(i => i.src), idx);
        });
      });
    });

    // Modal slider functions
    const modal = document.getElementById("imageSliderModal");
    const closeModal = document.getElementById("closeImageSliderModal");
    const slidesContainer = modal ? modal.querySelector(".slides") : null;
    let sliderImages = [];
    let currentSlide = 0;

    function openImageSlider(srcArray, startIdx) {
      if (!modal || !slidesContainer) return;
      
      sliderImages = srcArray;
      slidesContainer.innerHTML = '';
      sliderImages.forEach(src => {
        const slide = document.createElement('div');
        slide.className = 'slide';
        const img = document.createElement('img');
        img.src = src;
        slide.appendChild(img);
        slidesContainer.appendChild(slide);
      });
      currentSlide = startIdx;
      showSlide(currentSlide);
      modal.classList.add('open');
    }

    function showSlide(n) {
      const slides = slidesContainer ? slidesContainer.querySelectorAll('.slide') : [];
      if (!slides.length) return;
      currentSlide = (n + slides.length) % slides.length;
      slides.forEach((slide, idx) => {
        slide.classList.toggle('active', idx === currentSlide);
      });
    }

    if (modal) {
      const prevBtn = modal.querySelector("#prevBtn");
      const nextBtn = modal.querySelector("#nextBtn");
      
      if (prevBtn) {
        prevBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide - 1);
        });
      }
      
      if (nextBtn) {
        nextBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide + 1);
        });
      }
      
      if (closeModal) {
        closeModal.addEventListener("click", function() {
          modal.classList.remove("open");
        });
      }
      
      modal.addEventListener("click", function(e) {
        if (e.target === modal) modal.classList.remove("open");
      });
    }
  });
</script>

<!-- Script for restricting pointer events when modals are open -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  // List all modal IDs you use
  const modalIds = [
    "trayScanModal_DayPlanning",
    "trayScanModal",
    "newPopupModal",
    "imageSliderModal",
    "holdRemarkModal"
  ];

  function isAnyModalOpen() {
    return modalIds.some(id => {
      const el = document.getElementById(id);
      return el && (el.style.display === "block" || el.classList.contains("open") || el.style.display === "flex");
    });
  }

  function setBodyModalState(active) {
    if (active) {
      document.body.style.overflow = "hidden";
      document.body.style.pointerEvents = "none";
      // Allow pointer events for modals only
      modalIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.pointerEvents = "auto";
      });
      // Restrict pointer events for holding rows
      document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
        el.style.pointerEvents = "none";
      });
    } else {
      document.body.style.overflow = "";
      document.body.style.pointerEvents = "";
      modalIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.pointerEvents = "";
      });
      // Restore pointer events for holding rows
      document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
        el.style.pointerEvents = "";
      });
    }
  }

  // Observe modal open/close changes
  const observer = new MutationObserver(() => {
    setBodyModalState(isAnyModalOpen());
  });

  modalIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) observer.observe(el, { attributes: true, attributeFilter: ["style", "class"] });
  });

  // Also check on click (for dynamic changes)
  document.addEventListener("click", function () {
    setTimeout(() => setBodyModalState(isAnyModalOpen()), 50);
  });

  // Always restrict pointer events for holding rows, even if no modal is open
  setTimeout(() => {
    document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
      el.style.pointerEvents = "none";
    });
  }, 100);
});
</script>
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function lockParentActions() {
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button:not(#closeTrayScanModal_DayPlanning):not(#trayValidateBtn):not(#trayScanRedoBtn), .hold-toggle-btn, .hold-remark-icon, label.hold-toggle-switch'
    ).forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';
      el.classList.add('locked-action');
    });

    document.querySelectorAll('a:not(.tray-scan-btn-Jig)').forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.cursor = 'not-allowed';
      el.classList.add('locked-action');
    });

    var menuPanel = document.querySelector('.sidebar');
    if (menuPanel) {
      menuPanel.style.pointerEvents = 'none';
      menuPanel.style.cursor = 'not-allowed';
    }
    var mainPanel = document.querySelector('.main-panel');
    if (mainPanel) {
      mainPanel.style.pointerEvents = 'auto';
    }
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  function unlockParentActions() {
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button, .hold-toggle-btn, .hold-remark-icon, label.hold-toggle-switch'
    ).forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
      el.classList.remove('locked-action');
    });
    document.querySelectorAll('a').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.cursor = '';
      el.classList.remove('locked-action');
    });

    var menuPanel = document.querySelector('.sidebar');
    if (menuPanel) {
      menuPanel.style.pointerEvents = '';
      menuPanel.style.cursor = '';
    }
    var mainPanel = document.querySelector('.main-panel');
    if (mainPanel) {
      mainPanel.style.pointerEvents = '';
    }
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  var modal = document.getElementById("trayScanModal_DayPlanning");
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
</script>

{% endblock %} {% endblock content %}
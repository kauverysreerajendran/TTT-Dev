{% extends "base.html" %} 
{% load static %}
{% load stock_filters %} 
{% block content %}


  <style>

/* ========== Tablet override — paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */
@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }

.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn,
  #trayScanModal_DayPlanning input.form-control,#trayValidateBtn,
  #trayScanModal_DayPlanning table th, #trayScanModal_DayPlanning table td,
  #modalModelNo_DayPlanning
 {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(5)  { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 105px !important; max-width: 105px !important; }
  #order-listing th:nth-child(8)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(11) { min-width: 110px !important; max-width: 110px !important; }
  #order-listing th:nth-child(12) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(13) { min-width: 125px !important; max-width: 120px !important; }
  #order-listing th:nth-child(14) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(15) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(16) { min-width: 120px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(18) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(19) { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(20) { min-width: 130px !important; max-width: 130px !important; }


  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
} 
      /* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
  border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 85px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 110px;
  max-width: 110px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 90px;
  max-width: 95px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 80px;
  max-width: 80px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 90px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 160px;
  max-width: 170px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(18) {
  min-width: 100px;
  max-width: 110px;
}


/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}

/* ...existing code... */

/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 94px 175px 150px !important;
  gap: 0px !important;
  max-height: 300px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding-right: 10px;
  margin-top: 10px;
  border: 1px solid #ddd;
}
 
#trayScanModal{
overflow: scroll !important;
width: 435px !important;
}
#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* For the 4-column layout (with validation status) */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 50px 1fr 100px 140px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
 
/* Styling individual grid cells, only inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #f7f7f7;
  padding: 8px 12px;
  font-size: 12px;
  border: 1px solid #ddd;
  margin: 0; /* reset any margin from <p> or others */
}
 
/* S.no column specific styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 600;
  padding: 8px 4px; /* Reduced horizontal padding for S.no */
}
 
/* For mobile responsiveness */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 80px 100px !important;
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 2px; /* Further reduced padding on mobile */
    font-size: 11px;
  }
}
 
/* For very small screens */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 30px 1fr 70px 90px !important;
  }
}
</style>
 

<div class="content-wrapper">
   <div class="col-12 grid-margin stretch-card">
      <div class="card">
         <div class="card-body" style="padding-bottom:12px;">
            <h5 class="text-left mt-0 mb-4" style="font-weight:700;">R-Input Screening Pick Table</h5>
            <div class="table-responsive" style="overflow: scroll !important">
               <table id="order-listing" class="table">
                  <thead>
                     <tr>
                        <th>
                           S.No <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Last<br>Updated
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Plating <br> Stk No
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Polishing Stk No
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Plating Color
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Category
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Polish Finish
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Tray Cate- <br> Capacity
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Input Source
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           IPA Wiping
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           No of Trays <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Lot Qty
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th style="display: none;">
                           Physical Qty
                           <i class="fa fa-filter" aria-hidden="true" ></i>
                        </th>
                        <th>
                           Accept Qty
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Reject Qty
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Process Status
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Action <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Lot Status
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th style = "cursor: pointer;min-width: 135px;max-width: 140px;">
                           Current <br> Stage
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                     </tr>
                  </thead> 
                  <tbody>
                     <!-- Row 1 - Highlighted -->
                     {% for data in master_data %}
                     <tr class="highlighted-tray-scan{% if data.ip_hold_lot %} row-inactive{% endif %}"
                        data-stock-lot-id="{{ data.stock_lot_id }}"
                        data-batch-id="{{ data.batch_id }}"
                        data-available-qty="{{ data.available_qty }}"
                        data-ip-onhold-picking="{{ data.ip_onhold_picking }}"
                        data-few-cases-acceptance="{{data.few_cases_accepted_Ip_stock}}"
                        data-model-no="{{ data.plating_stk_no }}">
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur"{% endif %}>
                        <span style="display:flex; align-items:center; gap:3px;">
                           {% if is_admin %}
                           <!-- Admin users: Show toggle switch -->
                           <label class="hold-toggle-switch" style="margin-bottom:0;">
                           {% if not data.ip_hold_lot %}
                           <input type="checkbox" class="hold-toggle-btn" checked />
                           <span class="hold-slider"></span>
                           {% else %}
                           <input type="checkbox" class="hold-toggle-btn" />
                           <span class="hold-slider"></span>
                           {% endif %}
                           </label>
                           <!-- Hold remark icon -->
                           <span class="hold-remark-icon" 
                              style="display:{% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
                              title="{% if data.ip_holding_reason %}Holding Reason: {{ data.ip_holding_reason }}{% endif %}{% if data.ip_holding_reason and data.ip_release_reason %}&#10;{% endif %}{% if data.ip_release_reason %}Release Reason: {{ data.ip_release_reason }}{% endif %}">
                           {% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}
                           <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
                           {% endif %}
                           </span>
                           {% else %}
                           <!-- Non-admin: Only show view icon if there's a holding/release reason -->
                           {% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}
                           <span class="hold-remark-icon" 
                              style="display:inline-block; cursor:pointer;" 
                              title="{% if data.ip_holding_reason %}Holding Reason: {{ data.ip_holding_reason }}{% endif %}{% if data.ip_holding_reason and data.ip_release_reason %}&#10;{% endif %}{% if data.ip_release_reason %}Release Reason: {{ data.ip_release_reason }}{% endif %}">
                           <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
                           </span>
                           {% endif %}
                           {% endif %}
                           <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>
                        </span>
                        </td>   
                        <!-- Plating Stk No Column -->       
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}style="white-space:normal;word-break:break-all;">
                        {{ data.created_at|date:"d-M-y"  }}<br>
                        <span style="display:inline-block; margin-top:4px;word-break: break-all;">{{ data.created_at|date:"h:i A" }}</span>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
                           {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                           <div class="model-image-tooltip" style="position: absolute; left: 80%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s; min-width: 220px;">
                              <!-- Header with Info and Close buttons - Initially hidden -->
                              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                 <button class="info-btn" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer; display: none;">
                                 Info
                                 </button>
                                 <button class="close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer; display: none;">
                                 Close
                                 </button>
                              </div>
                              <!-- Image gallery section -->
                              <div style="display: flex; align-items: center; gap: 8px;">
                                 <button class="img-scroll-left" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8592;</button>
                                 <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                                    {% for img_url in data.model_images %}
                                    <img src="{{ img_url }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                                    {% endfor %}
                                 </div>
                                 <button class="img-scroll-right" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8594;</button>
                              </div>
                           </div>
                        </span>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.category }}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.polish_finish}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.tray_type}}-{{data.tray_capacity}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.location__location_name}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {% if data.wiping_required %}
                        YES
                        {% else %}
                        No
                        {% endif %}
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.no_of_trays}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <span class="lot-qty" style="min-width: 30px; text-align: right">{{ data.total_batch_quantity }}</span>
                        <span style="
                          display: inline-flex;
                          align-items: center;
                          justify-content: center;
                          width: 19px;
                          height: 19px;
                          border-radius: 50%;
                          background: {% if data.ip_person_qty_verified %}#0c8249{% else %}#bdbdbd{% endif %};
                          color: white;
                          font-size: 14px;
                          font-weight: bold;
                          margin-left: 2px;
                        ">
                          &#10003;
                        </span>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %} style="display: none;">
                        <input
                        type="text"
                        class="physical-qty-input"
                        value="{{ data.dp_physical_qty }}"
                        style="width: 36px; padding: 1px 3px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;
                        {% if data.dp_physical_qty_edited %}background-color: #fff3cd; border-color: #ffc107;{% endif %}"
                        readonly
                        {% if data.dp_physical_qty_edited %}title="This quantity was edited"{% endif %}
                        />
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{data.display_accepted_qty|default:0}}   
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{ data.ip_rejection_total_qty|default:0 }}
                        </td>
                        <!-- Process Status Column -->
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <div class="process-status-group d-flex align-items-center justify-content-center" style="gap: 6px;">
                           <!-- Q icon -->
                           <div
                              title="Tray Scan"
                              class="d-flex align-items-center justify-content-center rounded-circle"
                              style="width: 28px; height: 28px; 
                              {% if data.ip_person_qty_verified %}
                              background-color: #0c8249;
                              {% elif data.tray_verify %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% else %}
                              background-color: #bdbdbd;
                              {% endif %}
                              color: white; font-weight: bold; font-size: 15px;">
                              Q
                           </div>
                           <!-- S icon -->
                           <div
                              title="Status"
                              class="d-flex align-items-center justify-content-center rounded-circle"
                              style="
                              width: 28px; height: 28px;
                              {% if data.accepted_tray_scan_status and data.few_cases_accepted_Ip_stock and not data.ip_onhold_picking %}
                              background-color: #0c8249;
                              {% elif data.ip_onhold_picking and data.few_cases_accepted_Ip_stock %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% elif data.ip_onhold_picking  %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% else %}
                              background-color: #bdbdbd;
                              {% endif %}
                              color: white; font-weight: bold; font-size: 15px;">
                              S
                           </div>
                        </div>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {% if not data.accepted_Ip_stock and not data.rejected_ip_stock and not data.accepted_tray_scan_status %}
                        <!-- Accept/Reject Buttons Section -->
                        {% if data.few_cases_accepted_Ip_stock and data.ip_onhold_picking %}
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                           style="background-color: #66bb6a; pointer-events: none; opacity: 0.6; cursor: not-allowed;"
                           disabled>
                        <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                           style="background-color: #e57373;"
                           data-stock-lot-id="{{ data.stock_lot_id }}"
                           data-batch-id="{{ data.batch_id }}"
                           data-dp-physical-qty="{{ data.dp_physical_qty|default:0 }}">
                        <i class="fa fa-times-circle"></i>Set Top Tray
                        </button>
                        {% else %}
                        <!-- ✅ Show enabled delete button when Accept/Reject buttons are visible -->
                        {% if is_admin%}
                        <a href="#" class="delete-batch-btn" title="Delete" data-batch-id="{{ data.batch_id }}" data-stock-lot-id="{{ data.stock_lot_id }}">
                        <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
                        </a>
                        {% endif %}
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                        style="background-color: #66bb6a;"
                        data-lot-id="{{ data.stock_lot_id }}"
                        {% if not data.ip_person_qty_verified %}disabled{% endif %}>
                        <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                        style="background-color: #e57373;"
                        data-stock-lot-id="{{ data.stock_lot_id }}"
                        data-batch-id="{{ data.batch_id }}"
                        data-dp-physical-qty="{{ data.dp_physical_qty|default:0 }}"
                        {% if not data.ip_person_qty_verified %}disabled{% endif %}>
                        <i class="fa fa-times-circle"></i>Reject
                        </button>
                        {% endif %}
                        {% else %}
                        <span title="Delete Disabled" style="opacity: 0.5; pointer-events: none;">
                        <img src="{% static 'assets/icons/bin.png' %}" alt="Delete Disabled" style="width: 20px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5);" />
                        </span>
                        {% endif %}
                        <!-- Eye icon to view submitted "Tray Scan Table" -->
                        <a href="#"
                           title="View"
                           class="text-primary tray-scan-btn-DayPlanning-view tray-scan-btn-Jig"
                           style="text-decoration: underline"
                           data-stock-lot-id="{{ data.stock_lot_id }}"
                           data-batch-id="{{ data.batch_id }}"
                           data-model-no="{{ data.plating_stk_no }}"
                           data-no-of-trays="{{ data.no_of_trays }}"
                           data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
                           data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
                           data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
                           data-model-image="{{ data.model_images.0|default:'' }}"
                           data-ip-person-qty-verified="{{ data.ip_person_qty_verified|yesno:'true,false' }}"
                           data-total-batch-quantity="{{ data.total_batch_quantity }}">
                        <img src="{% static 'assets/icons/view.png' %}"
                           alt="View"
                           style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;" />
                        </a>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {% if data.ip_hold_lot %}
                        <!-- When ip_hold_lot is True, show "On Hold" status -->
                        <div
                           class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="
                           border: 1px solid #dc3545;
                           background-color: #f8d7da;
                           color: #721c24;
                           font-size: 12px;
                           white-space: nowrap;
                           padding: 5px;
                           "
                           >
                           On Hold
                        </div>
                        {% elif data.ip_onhold_picking or data.tray_verify or data.draft_tray_verify%}
                        <div
                           class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="
                           border: 1px solid #4997ac;
                           background-color: #d1f2f3;
                           color: #03425d;
                           font-size: 12px;
                           white-space: nowrap;
                           padding: 5px;
                           "
                           >
                           Draft
                        </div>
                        {% elif data.ip_onhold_picking and data.few_cases_accepted_Ip_stock %}
                        <div
                           class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="
                           border: 1px solid #4997ac;
                           background-color: #d1f2f3;
                           color: #03425d;
                           font-size: 12px;
                           white-space: nowrap;
                           padding: 5px;
                           "
                           >
                           Draft
                        </div>
                        {% else %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size: 13px; white-space: nowrap; padding: 0.3rem;">
                           Yet to Start
                        </div>
                        {% endif %}
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #d1edf3; background-color: #d1edf3; color: #033b5d; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                          <!-- VoiceRec with tooltip (audio remark) -->
                          <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                            <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                            <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
                              <!-- Audio recording UI placeholder -->
                              <div style="display: flex; align-items: center; gap: 10px;">
                                <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                                  <i class="fa fa-microphone"></i>
                                </button>
                                <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                              </div>
                              <div style="text-align: right; margin-top: 10px;">
                                <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                  <i class="fa fa-send"></i>
                                </button>
                              </div>
                            </div>
                          </a>

                          <a
                            href="#"
                            title="Add Remark"
                            class="remark-tooltip-trigger"
                            style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; position: relative; cursor: pointer;"
                          >
                            <img
                              src="{% static 'assets/icons/chat_icon.png' %}"
                              alt="Chat"
                              style="width: 20px; height: 20px; {% if data.IP_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% else %}opacity: 0.7;{% endif %}"
                            />

                            <div
                              class="remark-tooltip"
                              style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 270px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                            >
                              <textarea
                                placeholder="Type your remark..."
                                style="width: 75%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                                {% if data.IP_pick_remarks %}readonly{% endif %}
                              >{{ data.IP_pick_remarks|default_if_none:"" }}</textarea>
                              <div style="text-align: right; margin-top: -35px">
                                {% if not data.IP_pick_remarks %}
                                  <button
                                    type="button"
                                    style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                  >
                                    <i class="fa fa-send"></i>
                                  </button>
                                {% else %}
                                  <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                                    <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                                    Remark already saved and cannot be edited.
                                  </div>
                                {% endif %}
                              </div>
                            </div>
                          </a>
                        </td>
                     </tr>
                     {% endfor%}
                  </tbody>
               </table>
               <!-- Tray Scan Modal for R-Input Screening -->
               <div
                  id="trayScanModal_DayPlanning"
                  class="tray-scan-modal-DayPlanning"
                  >
                  <div class="tray-scan-modal-DayPlanning-content">
                     <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly"
                        >&times;</span
                        >
                     <!-- New top header container: title + user profile aligned left -->
                     <div
                        class="modal-top-header"
                        style="
                        display: flex;
                        align-items: center;
                        gap: 20px;
                        padding-bottom: 10px;
                        margin: 0px !important;
                        "
                        >
                        <div
                           class="user-profile"
                           style="display: flex; align-items: center; gap: 8px"
                           >
                           <img
                              src="/static/assets/images/imagePlaceholder.png"
                              alt="User Profile"
                              style="
                              border-radius: 50%;
                              width: 50px;
                              height: 50px;
                              object-fit: cover;
                              "
                              />
                           <!-- Model No and Lot Qty in same line -->
                           <div style="display: flex; flex-direction: column; gap: 2px;">
                              <div style="display: flex; align-items: center; gap: 15px;">
                                 <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-weight: bold; color: #666;">Model No:</span>
                                    <h6 id="modalModelNo_DayPlanning" style="margin: 0; color: #028084; font-weight: bold;">(Fetch Dynamically)</h6>
                                 </div>
                                 <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-weight: bold; color: #666;">Lot Qty:</span>
                                    <h6 id="modalLotQty_DayPlanning" style="margin: 0; color: #e67e22; font-weight: bold;">(Fetch Dynamically)</h6>
                                 </div>
                              </div>
                           </div>
                        </div>
                     </div>
                     <!-- Redo icon for clearing "tray ID" -->
                     <div id="trayValidateSection" style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                           R-Input Screening - Tray Scan
                        </h5>
                        <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
                        Tray Validate
                        </button>
                        <span id="trayQtyRedoBtn" title="Reset Top Tray Qty" style="display:none; cursor:pointer; margin-left:6px;">
                        <img src="{% static 'assets/icons/redo2.png' %}" style="width:22px;vertical-align:middle;" />
                        </span>
                        <!-- Hidden input field -->
                        <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
                     </div>
                     <!-- Add verification status indicator when buttons are hidden -->
                     <div id="verificationStatusIndicator" style="display: none; margin-bottom: 8px;">
                        <h5 style="text-align: center; margin: 0; font-weight: 600; color:#595959">
                           R-Input Screening - Tray Scan
                        </h5>
                     </div>
                     <!-- Error message container - initially hidden -->
                     <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
                        <span id="trayErrorText"></span>
                     </div>
                     <!-- trayScanDetails_DayPlanning will be a scrollable 3-column grid with headers and unlimited rows -->
                     <div id="trayScanDetails_DayPlanning" class="table-grid">
                        <!-- Headers -->
                        <div>S.no</div>
                        <div>Tray ID</div>
                        <div>Tray Quantity</div>
                        <div class="tray-validation-status-header">Tray Validation Status
                           <span style="margin-left: 10px;">
                           <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
                           <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
                           </span>
                        </div>
                        <!-- Example rows (replace with dynamic content) -->
                     </div>
                     <!-- No buttons for read-only modal -->
                  </div>
               </div>
            </div>
            <!-- Tray Scan Details Modal (Left Popup) -->
            <div id="trayScanModal" class="tray-scan-modal">
               <div class="tray-scan-modal-content">
                  <span id="closeTrayScanModal" class="tray-scan-close"
                     >&times;</span
                     >
                  <h4 id="trayScanModalHeader">R-Input Screening / <span class="modal-model-no"></span> / Rejection Window</h4>
                  <div id="trayScanDetails">
                     <!-- Dynamic content will be loaded here -->
                  </div>
               </div>
            </div>
            <!-- New Popup Modal (Right Popup) -->
            <div id="newPopupModal" class="new-popup-modal">
               <div class="tray-scan-modal-content" >
                  <span id="closeNewPopupModal" class="tray-scan-close"
                     >&times;</span
                     >
                  <!-- New top header container: title + user profile aligned left -->
                  <div
                     class="modal-top-header"
                     style="
                     display: flex;
                     align-items: center;
                     gap: 20px;
                     padding-bottom: 10px;
                     "
                     >
                  </div>
                  <!-- Existing centered h3 title -->
                  <!-- Redo icon for clearing "tray ID" -->
                  <!-- Accepted Case Tray Scan Table - Grid View with Visible Borders -->
                  <div id="trayScanDetails" class="table-grid">
                     <!-- NEW BUTTONS SECTION -->
                     <div class="tray-scan-modal-buttons" style="grid-column: 1 / -1; display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
                        <button
                           style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                        Draft
                        </button>
                        <button
                           style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                        Submit
                        </button>
                        <button
                           style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
                        Cancel
                        </button>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <!-- Pagination Section -->
         <div class="pagination-wrapper">
            <nav aria-label="Page navigation">
               <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                  <li>
                     <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                     <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                     </a>
                  </li>
                  {% else %}
                  <li class="disabled">
                     <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                  </li>
                  {% endif %}
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                  <li><a href="?page=1">1</a></li>
                  {% if page_obj.number > 4 %}
                  <li class="disabled"><span>…</span></li>
                  {% endif %}
                  {% endif %}
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                  {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                  {% if num == page_obj.number %}
                  <li class="active"><span>{{ num }}</span></li>
                  {% else %}
                  <li><a href="?page={{ num }}">{{ num }}</a></li>
                  {% endif %}
                  {% endif %}
                  {% endfor %}
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                  <li class="disabled"><span>…</span></li>
                  {% endif %}
                  <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                  {# Next button #}
                  {% if page_obj.has_next %}
                  <li>
                     <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                     <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                     </a>
                  </li>
                  {% else %}
                  <li class="disabled">
                     <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                  </li>
                  {% endif %}
               </ul>
            </nav>
         </div>
      </div>
   </div>
</div>
</div>
<!-- Image Slider Modal (popup) -->
<div id="imageSliderModal" class="image-slider-modal">
   <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
   <h3>Visual Aid</h3>
   <div class="slider" id="slider">
      <div class="slides" id="slidesContainer">
         <div class="slide active">
            <img src="{% static 'assets/images/carousel/banner_1.jpg' %}" alt="Slide 1">
         </div>
         <div class="slide">
            <img src="{% static 'assets/images/carousel/banner_2.jpg' %}" alt="Slide 2">
         </div>
         <div class="slide">
            <img src="{% static 'assets/images/carousel/banner_3.jpg' %}" alt="Slide 3">
         </div>
      </div>
      <button class="prev" id="prevBtn">&#10094;</button>
      <button class="next" id="nextBtn">&#10095;</button>
   </div>
</div>
<!-- Image Slider Modal -->
<div id="imageSliderModal" class="image-slider-modal">
   <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
   <div class="slider" id="slider">
      <button class="prev" id="prevBtn">&#8592;</button>
      <div class="slides"></div>
      <button class="next" id="nextBtn">&#8594;</button>
   </div>
</div>
<!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
   <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
      <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
      <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
      <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
      <div style="text-align:right; margin-top:10px;">
         <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
      </div>
      <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
   </div>
</div>
{% block script %}
<!-- Place this after your tray scan modal logic and after buildTableHTML is defined and used -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     // Show Edit icon after Tray Validate is clicked
     const validateBtn = document.getElementById("trayValidateBtn");
     const redoBtn = document.getElementById("trayQtyRedoBtn");
     const modal = document.getElementById("trayScanModal_DayPlanning");
     const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
   
     
     if (validateBtn) {
       validateBtn.addEventListener("click", function () {
         setTimeout(() => {
           const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
           if (topTrayRow) {
             const editIcon = topTrayRow.querySelector('.edit-tray-qty');
             if (editIcon) editIcon.style.display = 'inline-block';
           }
           if (redoBtn) redoBtn.style.display = 'inline-block';
         }, 100);
       });
     }
   
   
   
     // Redo icon click: reset qty, disable editing, disable Tray Validate
     if (redoBtn) {
       redoBtn.addEventListener('click', function () {
         const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
         if (topTrayRow) {
           const qtyInput = topTrayRow.querySelector('.tray-qty-input[data-top-tray="1"]');
           if (qtyInput) {
             qtyInput.value = qtyInput.getAttribute('data-initial');
             qtyInput.setAttribute('readonly', true);
           }
   
   
           // Hide Tray Validation Status column by rebuilding table without it
         if (modal && detailsDiv && modal.buildTableHTML) {
           detailsDiv.innerHTML = modal.buildTableHTML(false);
         }
          // ✅ Remove draft/cancel buttons and info message
         if (window.removeDraftCancelButtons) {
           window.removeDraftCancelButtons();
         }
         }
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
           validateBtn.style.background = "#f5faff";
           validateBtn.style.borderColor = "#023E4DCC";
           validateBtn.style.color = "#023E4DCC";
         }
         if (redoBtn) redoBtn.style.display = 'none';
       });
     }
   
     // When qty is changed, re-enable Tray Validate
     document.addEventListener('input', function (e) {
       if (e.target.classList.contains('tray-qty-input') && e.target.dataset.topTray === "1") {
         const originalQty = parseInt(e.target.getAttribute('data-initial'), 10) || 0;
         let currentQty = parseInt(e.target.value, 10) || 0;
         // Prevent increasing above original
         if (currentQty > originalQty) {
           e.target.value = originalQty;
         }
         // Prevent going below zero
         if (currentQty < 0) {
           e.target.value = 0;
         }
         // Enable Tray Validate as before
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
         }
       }
     });
   
       document.addEventListener('click', function (e) {
       if (e.target.closest('.edit-tray-qty')) {
         const row = e.target.closest('tr');
         const qtyInput = row.querySelector('.tray-qty-input[data-top-tray="1"]');
         if (qtyInput) {
           qtyInput.removeAttribute('readonly');
           qtyInput.focus();
     
           // Add blur handler to return focus to validate input after editing
           qtyInput.addEventListener('blur', function handleBlur() {
             setTimeout(() => {
               // Only refocus if not clicking Edit icon again
               const active = document.activeElement;
               if (!active || !active.classList.contains('edit-tray-qty')) {
                 const validateInput = document.getElementById("trayValidateInput");
                 if (validateInput) validateInput.focus();
               }
             }, 100);
             // Remove this handler after it runs once
             qtyInput.removeEventListener('blur', handleBlur);
           });
         }
       }
     });
   
     
   });
</script>
<!-- ✅ SCRIPT 1: Save IP Checkbox -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
     // ✅ HELPER FUNCTION: Get edited tray qty from modal
     function getEditedTrayQtyFromModal() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (!modal) {
         return null;
       }
       
       // Find the top tray input
       const editedTrayQtyInput = modal.querySelector('.tray-qty-input[data-top-tray="1"]');
       if (!editedTrayQtyInput) {
         return null;
       }
       
       const currentValue = editedTrayQtyInput.value.trim();
       const initialValue = editedTrayQtyInput.getAttribute('data-initial') || '';
       
   
       
       // Return current value regardless of whether it changed
       return currentValue || null;
     }
   
     // ✅ HELPER FUNCTION: Get CSRF token
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   
     // ✅ SAVE IP CHECKBOX HANDLER
     document.addEventListener('click', function(e) {
       if (e.target.classList.contains('save-ip-checkbox')) {
         const element = e.target;
         const row = element.closest('tr');
         
         let lotId = element.getAttribute('data-lot-id');
         if (!lotId) lotId = row.getAttribute('data-stock-lot-id');
         
         if (!lotId) {
           Swal.fire('Error', 'Lot ID not found', 'error');
           return;
         }
         
         // Get the calculated missing qty from the input
         const missingQtyInput = row.querySelector('.missing-qty-input');
         const missingQty = missingQtyInput ? missingQtyInput.value.trim() : '0';
         
         // ✅ FIXED: Get edited tray qty using helper function
         const editedTrayQty = getEditedTrayQtyFromModal();
         
   
         // Change icon to indicate processing
         if (element.tagName === 'I') {
           element.className = 'fa fa-spinner fa-spin';
         }
         
         // Disable element during processing
         element.style.pointerEvents = 'none';
         
         fetch('/recovery_is/rec_save_ip_checkbox/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({
             lot_id: lotId,
             missing_qty: missingQty || '0',
             edited_tray_qty: editedTrayQty
           })
         })
         .then(res => res.json())
         .then(data => {
           if (data.success) {
             // Change to checked state
             if (element.tagName === 'I') {
               element.className = 'fa fa-check-square';
               element.style.color = '#28a745';
             }
             
             element.title = 'IP Checkbox saved';
             
             Swal.fire({
               icon: 'success',
               title: 'Saved successfully!',
               timer: 2000,
               showConfirmButton: false
             });
             
             // Update row to show verification completed
             updateRowAfterIPSave(row, lotId, missingQty);
             
             // Reload page after a short delay
             setTimeout(() => {
               window.location.reload();
             }, 1500);
             
           } else {
             Swal.fire('Error', data.error || 'Save failed', 'error');
             // Reset icon and enable element
             if (element.tagName === 'I') {
               element.className = 'fa fa-square-o';
             }
             element.style.pointerEvents = 'auto';
           }
         })
         .catch(error => {
           Swal.fire('Error', 'Network error', 'error');
           // Reset icon and enable element
           if (element.tagName === 'I') {
             element.className = 'fa fa-square-o';
           }
           element.style.pointerEvents = 'auto';
         });
       }
     });
   
     // ✅ HELPER FUNCTION: Update row after IP save
     function updateRowAfterIPSave(row, lotId, missingQty) {
       // Update main IP checkbox
       const mainIpCheckbox = row.querySelector('.ip-checkbox');
       if (mainIpCheckbox) {
         mainIpCheckbox.checked = true;
         mainIpCheckbox.disabled = true;
       }
       
       // Update missing qty input
       const missingQtyInput = row.querySelector('.missing-qty-input');
       if (missingQtyInput) {
         missingQtyInput.disabled = true;
       }
       
       // Update physical qty
       const physicalQtyInput = row.querySelector('.physical-qty-input');
       const lotQtySpan = row.querySelector('.lot-qty');
       if (physicalQtyInput && lotQtySpan && missingQty) {
         const totalQty = parseInt(lotQtySpan.textContent.trim(), 10);
         const newPhysicalQty = totalQty - parseInt(missingQty);
         physicalQtyInput.value = newPhysicalQty;
       }
       
       // Update process status Q icon
       const processIcons = row.querySelectorAll('.d-flex > div');
       if (processIcons.length > 0) {
         processIcons[0].style.backgroundColor = '#0c8249';
       }
     }
   
     // ✅ Make helper functions available globally
     window.getEditedTrayQtyFromModal = getEditedTrayQtyFromModal;
     window.getCookie = getCookie;
   });
</script>
<!--✅ SCRIPT 2: Modal Opening and Table Building-->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     document.querySelectorAll('.tray-scan-btn-DayPlanning-view').forEach(function(link) {
       link.addEventListener('click', async function (e) {
         e.preventDefault();
   
         // Get modal elements
         const modal = document.getElementById("trayScanModal_DayPlanning");
         const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
         const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
         const modalLotQty = document.getElementById("modalLotQty_DayPlanning"); // ✅ NEW
         modal.dataset.batchId = link.getAttribute('data-batch-id');
   
         // ✅ FIXED: Get total batch quantity and USE it
         const totalBatchQuantity = link.getAttribute('data-total-batch-quantity') || "0";
         
         // Get data attributes
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         const modelNo = link.getAttribute('data-model-no');
         const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
         const trayCapacity = link.getAttribute('data-tray-capacity') || "";
         const isQtyVerified = link.getAttribute('data-ip-person-qty-verified') === 'true';
         
         let trayQtyList = [];
         try {
           trayQtyList = JSON.parse(link.getAttribute('data-tray-qty-list') || "[]");
         } catch (e) {
           trayQtyList = [];
         }
   
         // Set model number in modal
         if (modalModelNo && modelNo) {
           modalModelNo.textContent = modelNo;
         }
         
         // ✅ FIXED: Actually SET the lot quantity in modal
         if (modalLotQty) {
           modalLotQty.textContent = totalBatchQuantity;
           console.log("✅ Set Lot Qty to:", totalBatchQuantity);
         } else {
           console.log("❌ modalLotQty element not found!");
         }
   
         // Rest of your existing code...
         // Set model image, validation buttons, etc.
         // Set model image
         const modalUserImg = modal.querySelector('.user-profile img');
         const modelImage = link.getAttribute('data-model-image');
         if (modalUserImg) {
           if (modelImage) {
             modalUserImg.src = modelImage;
           } else {
             modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
           }
         }
   
         // Show/Hide validation buttons based on verification status
         const trayValidateSection = document.getElementById("trayValidateSection");
         const verificationStatusIndicator = document.getElementById("verificationStatusIndicator");
   
         if (isQtyVerified) {
           if (trayValidateSection) trayValidateSection.style.display = "none";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "block";
         } else {
           if (trayValidateSection) trayValidateSection.style.display = "flex";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "none";
         }
   
         // Fetch tray data with proper top tray handling using API
         let traysData = [];
         try {
           const resp = await fetch(`/recovery_is/rec_ip_completed_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
           const result = await resp.json();
           if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
             traysData = result.trays;
           }
         } catch (e) {
         }
   
         // Fetch existing verification status
         let verificationData = {};
         try {
           const verifyResp = await fetch(`/recovery_is/rec_get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
           const verifyResult = await verifyResp.json();
           if (verifyResult.success) {
             verificationData = verifyResult.verification_data;
           }
         } catch (e) {
         }
   
         // ✅ TABLE BUILDING FUNCTION
         function buildTableHTML(showValidationColumn = false) {
           let html = `
             <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
               <thead>
                 <tr>
                   <th style="width:50px;">S.no</th>
                   <th>Tray ID</th>
                   <th>Tray Qty</th>
                   ${showValidationColumn && !isQtyVerified ? '<th>Tray Validation Status</th>' : ''}
                 </tr>
               </thead>
               <tbody>
           `;
           
           // If we have trays data from API, use it directly
           if (traysData && traysData.length > 0) {
             traysData.forEach((tray, index) => {
               const isTopTray = tray.is_top_tray || index === 0;
               const displaySNo = tray.is_top_tray ? '1 (Top Tray)' : tray.s_no;
               const position = index + 1;
   
               // Check verification status
               const verification = verificationData[position];
               const isVerifiedByUser = verification ? verification.is_verified : false;
               const isVerifiedInDB = tray.IP_tray_verified || false;
               const isVerified = isVerifiedByUser || isVerifiedInDB;
               
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
   
               // Set input properties based on verification status
               let inputValue, inputStyle, verificationIndicator;
   
               if (isVerified) {
                 inputValue = verifiedTrayId || tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
   
               html += `
                 <tr>
                   <td>${displaySNo}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td style="position:relative; white-space:nowrap;">
                     <span style="display:inline-flex; align-items:center;">
                       <input type="number" 
                              class="form-control tray-qty-input" 
                              value="${tray.tray_quantity || ''}" 
                              readonly 
                              style="width: 40px; display:inline-block; vertical-align:middle; text-align:right; margin-right:4px;"
                              data-initial="${tray.tray_quantity || ''}"
                              ${isTopTray ? 'data-top-tray="1"' : ''} 
                       />
                      
                     </span>
                   </td>
                   ${showValidationColumn && !isQtyVerified ? `
                     <td>
                       <div class="validation-status">
                         <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                         </div>
                         <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                         </div>
                       </div>
                     </td>
                   ` : ''}
                 </tr>
               `;
             });
           } else {
             // Fallback: Use the old method if API data is not available
             let totalRows = noOfTrays;
             for (let i = 0; i < totalRows; i++) {
               const position = i + 1;
               const verification = verificationData[position];
               const isVerified = verification ? verification.is_verified : false;
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
               const trayQty = trayQtyList[i] || trayCapacity;
               
               let inputValue, inputStyle, verificationIndicator;
               
               if (isVerified) {
                 inputValue = verifiedTrayId;
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
               
               html += `
                 <tr>
                   <td>${i === 0 ? '1 (Top Tray)' : (i + 1)}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td>
                     <input type="number" class="form-control" value="${trayQty}" readonly style="width: 100%;" />
                   </td>
                   ${showValidationColumn && !isQtyVerified ? `
                     <td>
                       <div class="validation-status">
                         <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                         </div>
                         <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                         </div>
                       </div>
                     </td>
                   ` : ''}
                 </tr>
               `;
             }
           }
           
           html += `
               </tbody>
             </table>
           `;
           return html;
         }
   
   
   
         // Initially show table
         detailsDiv.innerHTML = buildTableHTML(false);
   
         // Store data in modal for later use
         modal.buildTableHTML = buildTableHTML;
         modal.traysData = traysData;
         modal.verificationData = verificationData;
         modal.noOfTrays = noOfTrays;
         modal.trayQtyList = trayQtyList;
         modal.trayCapacity = trayCapacity;
         modal.isQtyVerified = isQtyVerified;
         modal.stockLotId = stockLotId;
   
         // Show the modal
         if (modal) modal.style.display = "block";
         modal.classList.add("open");
   
         // Check verification status after modal opens
         setTimeout(() => {
           if (!modal.isQtyVerified) {
             checkVerificationStatusAndShowButtons();
           } else {
             removeDraftCancelButtons();
           }
         }, 200);
       });
     });
   
     // ✅ HELPER FUNCTIONS for modal operations
     function getCurrentBatchId() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (modal && modal.dataset.batchId) return modal.dataset.batchId;
       const lastBtn = document.querySelector('.tray-scan-btn-DayPlanning-view[data-batch-id]');
       return lastBtn ? lastBtn.getAttribute('data-batch-id') : '';
     }
   
     function getCurrentLotId() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (modal && modal.stockLotId) return modal.stockLotId;
       const lastBtn = document.querySelector('.tray-scan-btn-DayPlanning-view[data-stock-lot-id]');
       return lastBtn ? lastBtn.getAttribute('data-stock-lot-id') : '';
     }
   
     // ✅ Make helper functions available globally
     window.getCurrentBatchId = getCurrentBatchId;
     window.getCurrentLotId = getCurrentLotId;
   });
   
   
</script>
<!-- ✅ SCRIPT 3: Enhanced Tray Validation with Popup Error Handling -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
     function showError(message) {
       const errorMessage = document.getElementById("trayErrorMessage");
       const errorText = document.getElementById("trayErrorText");
       if (errorMessage && errorText) {
         errorText.textContent = message;
         
         // Enhanced styling for better visibility
         errorMessage.style.setProperty('display', 'block', 'important');
         errorMessage.style.setProperty('visibility', 'visible', 'important');
         errorMessage.style.setProperty('opacity', '1', 'important');
         errorMessage.style.setProperty('z-index', '99999', 'important');
         errorMessage.style.setProperty('position', 'relative', 'important');
         errorMessage.style.setProperty('background-color', '#ffebee', 'important');
         errorMessage.style.setProperty('border', '1px solid #f44336', 'important');
         errorMessage.style.setProperty('color', '#c62828', 'important');
         errorMessage.style.setProperty('padding', '8px 12px', 'important');
         errorMessage.style.setProperty('border-radius', '4px', 'important');
         errorMessage.style.setProperty('margin-bottom', '10px', 'important');
         errorMessage.style.setProperty('font-size', '12px', 'important');
         errorMessage.style.setProperty('text-align', 'center', 'important');
         errorMessage.style.setProperty('width', '100%', 'important');
         
         // Scroll to error message
         errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
         
         // Flash effect for better visibility
         let flashCount = 0;
         const flashInterval = setInterval(() => {
           if (flashCount < 6) {
             errorMessage.style.backgroundColor = flashCount % 2 === 0 ? '#ffcdd2' : '#ffebee';
             flashCount++;
           } else {
             clearInterval(flashInterval);
             errorMessage.style.backgroundColor = '#ffebee';
           }
         }, 200);
         
         // Auto-hide after 8 seconds
         setTimeout(() => {
           errorMessage.style.display = "none";
         }, 8000);
       } else {
         // Fallback to alert if error elements not found
         alert(message);
       }
     }
   
     
     function hideError() {
       const errorMessage = document.getElementById("trayErrorMessage");
       if (errorMessage) {
         errorMessage.style.display = "none";
       }
     }
   
     // ✅ ENHANCED: Tray validation with better error handling and automatic input clearing
     const validateInput = document.getElementById("trayValidateInput");
     const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
   
     if (validateInput && detailsDiv) {
       validateInput.addEventListener("keydown", function (e) {
         if (e.key === "Enter") {
           const trayId = validateInput.value.trim();
           if (!trayId) return;
   
           // Check if this tray ID is already verified
           const alreadyVerified = Array.from(detailsDiv.querySelectorAll("tbody tr")).some(row => {
             const input = row.querySelector('input[type="text"]');
             const verificationIndicator = row.querySelector('small');
             
             return input && 
                    input.value.trim() === trayId && 
                    verificationIndicator && 
                    verificationIndicator.textContent.includes('✓ Verified');
           });
   
           if (alreadyVerified) {
             showError(`Tray ID "${trayId}" is already verified. Cannot scan again.`);
             // ✅ ENHANCED: Auto-clear input and refocus
             setTimeout(() => {
               validateInput.value = "";
               validateInput.focus();
             }, 100);
             return;
           }
   
           const batchId = window.getCurrentBatchId();
           const lotId = window.getCurrentLotId();
           if (!batchId || !lotId) {
             showError('Batch ID or Lot ID not found. Please try again.');
             setTimeout(() => {
               validateInput.value = "";
               validateInput.focus();
             }, 100);
             return;
           }
   
           hideError();
   
           // Find the row where trayId matches and is not yet verified
           const rows = detailsDiv.querySelectorAll("tbody tr");
           let targetRow = null;
           let position = null;
   
           rows.forEach((row, index) => {
             if (!targetRow) {
               const trayIdInput = row.querySelector('input[type="text"]');
               const verificationIndicator = row.querySelector('small');
               
               if (
                 trayIdInput &&
                 trayIdInput.value.trim() === trayId &&
                 verificationIndicator &&
                 !verificationIndicator.textContent.includes('✓ Verified')
               ) {
                 targetRow = row;
                 position = parseInt(trayIdInput.getAttribute('data-position')) || (index + 1);
               }
             }
           });
   
           if (!targetRow) {
             showError(`Tray ID "${trayId}" is not expected in this position or already verified.`);
             // ✅ ENHANCED: Auto-clear input and refocus
             setTimeout(() => {
               validateInput.value = "";
               validateInput.focus();
             }, 100);
             return;
           }
   
           // ✅ ENHANCED: Show loading state
           validateInput.disabled = true;
           validateInput.style.background = '#f0f0f0';
   
           // Send validation request
           fetch("/recovery_is/rec_ip_tray_validate/", {
             method: "POST",
             headers: {
               "Content-Type": "application/json",
               "X-CSRFToken": window.getCookie('csrftoken')
             },
             body: JSON.stringify({
               batch_id: batchId,
               tray_id: trayId,
               tray_position: position,
               lot_id: lotId
             })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               const trayIdInput = targetRow.querySelector('input[type="text"]');
               const statusCell = targetRow.querySelector("td:last-child");
               
               // Fill the tray ID and make it readonly
               if (trayIdInput) {
                 trayIdInput.value = trayId;
                 trayIdInput.setAttribute('readonly', true);
                 trayIdInput.style.backgroundColor = '#f5f5f5';
                 trayIdInput.style.borderColor = data.exists ? '#28a745' : '#dc3545';
                 trayIdInput.style.color = data.exists ? '#155724' : '#721c24';
   
                 // Update verification indicator text
                 const existingIndicator = trayIdInput.parentElement.querySelector('small');
                 if (existingIndicator) {
                   existingIndicator.style.color = data.exists ? '#28a745' : '#dc3545';
                   existingIndicator.style.fontWeight = 'bold';
                   existingIndicator.textContent = data.exists ? '✓ Verified' : '✗ Failed';
                 }
               }
   
               if (statusCell) {
                 if (data.exists) {
                   // Pass validation
                   statusCell.innerHTML = `
                     <div class="validation-status">
                       <div class="status-icon fail inactive">
                         <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                       </div>
                       <div class="status-icon pass active">
                         <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                       </div>
                     </div>
                   `;
                 } else {
                   // Fail validation
                   statusCell.innerHTML = `
                     <div class="validation-status">
                       <div class="status-icon fail active">
                         <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                       </div>
                       <div class="status-icon pass inactive">
                         <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                       </div>
                     </div>
                   `;
                 }
               }
   
               // ✅ ENHANCED: Show success/failure message based on validation result
               if (!data.exists) {
                 showError(data.error || `Tray ID "${trayId}" validation failed.`);
               }
             } else {
               // ✅ ENHANCED: Show detailed error message from server
               showError(data.error || 'An error occurred while validating the tray ID.');
             }
           })
           .catch(error => {
             console.error('Validation error:', error);
             showError('Network error occurred while validating the tray ID. Please try again.');
           })
           .finally(() => {
             // ✅ ENHANCED: Always restore input state and clear for next scan
             validateInput.disabled = false;
             validateInput.style.background = '';
             validateInput.value = "";
             validateInput.focus();
   
             // Check verification status after each scan
             setTimeout(() => {
               checkVerificationStatusAndShowButtons();
             }, 100);
           });
         }
       });
     }
   
     // ✅ CHECK VERIFICATION STATUS AND SHOW BUTTONS (existing function - no changes needed)
     function checkVerificationStatusAndShowButtons() {
       const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
       const rows = detailsDiv.querySelectorAll("tbody tr");
       if (rows.length === 0) {
         return;
       }
   
       // Check if quantity is already verified
       const modal = document.getElementById("trayScanModal_DayPlanning");
       const isQtyAlreadyVerified = modal && modal.isQtyVerified;
       
       if (isQtyAlreadyVerified) {
         removeDraftCancelButtons();
         return;
       }
   
       let totalTrays = 0;
       let verifiedTrays = 0;
       let unverifiedTrays = 0;
       let filledTrays = 0;
   
       rows.forEach((row, index) => {
         const trayIdInput = row.querySelector('input[type="text"]');
         
         if (trayIdInput) {
           totalTrays++;
           const trayId = trayIdInput.value.trim();
           
           if (trayId) {
             filledTrays++;
             
             // Check for verification indicator in the Tray ID column
             const hasVerificationIndicator = trayIdInput.parentElement.querySelector('small');
             const verificationText = hasVerificationIndicator ? hasVerificationIndicator.textContent : '';
             
             // Check for validation status icons if validation column exists
             const statusCell = row.querySelector("td:last-child");
             const hasPassIcon = statusCell && statusCell.querySelector('.status-icon.pass.active');
             
             // Additional check: readonly status with verification background
             const isReadonlyVerified = trayIdInput.hasAttribute('readonly') && 
                                       (trayIdInput.style.backgroundColor.includes('#f5f5f5') || 
                                        trayIdInput.style.borderColor.includes('#28a745'));
             
             // Row is verified if any verification method returns true
             const isVerified = (hasVerificationIndicator && verificationText.includes('✓')) || 
                               hasPassIcon || 
                               isReadonlyVerified;
             
             if (isVerified) {
               verifiedTrays++;
             } else {
               unverifiedTrays++;
             }
           }
         }
       });
   
       // Show buttons logic
       if (totalTrays > 0) {
         if (verifiedTrays === totalTrays && filledTrays > 0) {
           removeDraftCancelButtons();
           autoTriggerCheckboxSave();
         } else if (verifiedTrays > 0 && unverifiedTrays > 0 && !draftButtonsShown) {
           showDraftCancelButtons();
         } else if (filledTrays === 0) {
           removeDraftCancelButtons();
         }
       }
     }
   
     // ✅ Make function available globally
     window.checkVerificationStatusAndShowButtons = checkVerificationStatusAndShowButtons;
   });
</script>
<!-- ✅ SCRIPT 4: Draft Save and Auto-trigger Functionality -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
     let draftButtonsShown = false;
   
     // ✅ CALCULATE TRAY QUANTITIES
     function calculateTrayQuantities() {
       const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
       
       let totalLotQty = 0;
       let verifiedQty = 0;
       let unverifiedQty = 0;
       
       const rows = detailsDiv.querySelectorAll("tbody tr");
       
       
       rows.forEach((row, index) => {
         const trayQtyInput = row.querySelector('input[type="number"]');
         const trayIdInput = row.querySelector('input[type="text"]');
         
         if (trayQtyInput && trayIdInput) {
           const trayQty = parseInt(trayQtyInput.value) || 0;
           totalLotQty += trayQty;
           
           // Check multiple ways to determine if row is verified
           let isVerified = false;
           
           // Method 1: Check for verification indicator (✓ Verified text)
           const hasVerificationIndicator = trayIdInput.parentElement.querySelector('small');
           if (hasVerificationIndicator && hasVerificationIndicator.textContent.includes('✓')) {
             isVerified = true;
           }
           
           // Method 2: Check for validation status icons
           if (!isVerified) {
             const statusCell = row.querySelector("td:last-child");
             const hasPassIcon = statusCell && statusCell.querySelector('.status-icon.pass.active');
             if (hasPassIcon) {
               isVerified = true;
             }
           }
           
           // Method 3: Check if tray ID input is readonly and has value
           if (!isVerified && trayIdInput.hasAttribute('readonly') && trayIdInput.value.trim()) {
             const inputStyle = trayIdInput.style.backgroundColor;
             if (inputStyle.includes('#f5f5f5')) {
               isVerified = true;
             }
           }
           
           // Add to appropriate counter
           if (isVerified) {
             verifiedQty += trayQty;
           } else {
             unverifiedQty += trayQty;
           }
         }
       });
       
   
       return {
         totalLotQty,
         verifiedQty,
         unverifiedQty
       };
     }
   
     // ✅ HANDLE DRAFT SAVE
     function handleDraftSave() {
       const lotId = window.getCurrentLotId();
       if (!lotId) {
         showError('Lot ID not found');
         return;
       }
   
       const { totalLotQty, unverifiedQty, verifiedQty } = calculateTrayQuantities();
       const editedTrayQty = window.getEditedTrayQtyFromModal();
       
   
   
       const draftBtn = document.getElementById('trayDraftBtn');
       if (draftBtn) {
         draftBtn.disabled = true;
         draftBtn.textContent = 'Saving...';
       }
   
       showSuccessMessage('Saving as draft...', '#007bff');
   
       fetch('/recovery_is/rec_ip_save_tray_draft/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': window.getCookie('csrftoken')
         },
         body: JSON.stringify({
           lot_id: lotId,
           total_lot_qty: totalLotQty,
           missing_qty: unverifiedQty,
           physical_qty: totalLotQty - unverifiedQty,
           edited_tray_qty: editedTrayQty
         })
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           showSuccessMessage('✅ Saved as draft!', '#28a745');
           updateMainTableRowForDraftWithQuantities(lotId, unverifiedQty, totalLotQty - unverifiedQty);
           setTimeout(() => {
             const modal = document.getElementById("trayScanModal_DayPlanning");
             if (modal) {
               modal.classList.remove("open");
               modal.style.display = "none";
             }
             window.location.reload();
           }, 2000);
         } else {
           showSuccessMessage('❌ Draft save failed: ' + (data.error || 'Unknown error'), '#dc3545');
           if (draftBtn) {
             draftBtn.disabled = false;
             draftBtn.textContent = 'Save as Draft';
           }
         }
       })
       .catch(error => {
         showSuccessMessage('❌ Draft save network error', '#dc3545');
         if (draftBtn) {
           draftBtn.disabled = false;
           draftBtn.textContent = 'Save as Draft';
         }
       });
     }
   
     // ✅ AUTO-TRIGGER CHECKBOX SAVE
     function autoTriggerCheckboxSave() {
       const lotId = window.getCurrentLotId();
       if (!lotId) {
         return;
       }
   
       const { totalLotQty, unverifiedQty, verifiedQty } = calculateTrayQuantities();
       const missingQty = unverifiedQty;
       const physicalQty = totalLotQty - unverifiedQty;
       const editedTrayQty = window.getEditedTrayQtyFromModal();
   
       showSuccessMessage('All trays verified! Auto-saving checkbox...', '#007bff');
   
       fetch('/recovery_is/rec_save_ip_checkbox/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': window.getCookie('csrftoken')
         },
         body: JSON.stringify({
           lot_id: lotId,
           missing_qty: missingQty || '0',
           edited_tray_qty: editedTrayQty
         })
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           showSuccessMessage('✅ Checkbox automatically saved! All trays verified.', '#28a745');
           updateMainTableRowStatus(lotId, missingQty, physicalQty);
           setTimeout(() => {
             const modal = document.getElementById("trayScanModal_DayPlanning");
             if (modal) {
               modal.classList.remove("open");
               modal.style.display = "none";
             }
             window.location.reload();
           }, 2000);
         } else {
           showSuccessMessage('❌ Auto-save failed: ' + (data.error || 'Unknown error'), '#dc3545');
         }
       })
       .catch(error => {
         showSuccessMessage('❌ Auto-save network error', '#dc3545');
       });
     }
   
     // ✅ SHOW DRAFT/CANCEL BUTTONS
     function showDraftCancelButtons() {
       if (draftButtonsShown) {
         return;
       }
   
       removeDraftCancelButtons();
   
       const infoMsg = document.createElement('div');
       infoMsg.id = 'draftInfoMessage';
       infoMsg.style.cssText = `
         background: #fff3cd;
         border: 1px solid #ffeaa7;
         color: #856404;
         padding: 12px 16px;
         border-radius: 8px;
         margin: 15px 0;
         font-size: 14px;
         text-align: center;
       `;
       infoMsg.innerHTML = `
         <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
         Some tray IDs are not verified. You can save as draft to continue later or cancel to return.
       `;
   
       const buttonContainer = document.createElement('div');
       buttonContainer.id = 'draftCancelButtons';
       buttonContainer.style.cssText = `
         display: flex;
         justify-content: center;
         gap: 15px;
         margin-top: 20px;
         padding: 15px;
         background: #f8f9fa;
         border-radius: 8px;
         border: 1px solid #dee2e6;
       `;
   
       const draftBtn = document.createElement('button');
       draftBtn.id = 'trayDraftBtn';
       draftBtn.textContent = 'Save as Draft';
       draftBtn.style.cssText = `
         padding: 10px 20px;
         background: #007bff;
         color: white;
         border: none;
         border-radius: 25px;
         font-weight: 600;
         cursor: pointer;
         transition: all 0.3s ease;
       `;
   
       const cancelBtn = document.createElement('button');
       cancelBtn.id = 'trayCancelBtn';
       cancelBtn.textContent = 'Cancel';
       cancelBtn.style.cssText = `
         padding: 10px 20px;
         background: #6c757d;
         color: white;
         border: none;
         border-radius: 25px;
         font-weight: 600;
         cursor: pointer;
         transition: all 0.3s ease;
       `;
   
       draftBtn.onmouseover = () => draftBtn.style.background = '#0056b3';
       draftBtn.onmouseout = () => draftBtn.style.background = '#007bff';
       cancelBtn.onmouseover = () => cancelBtn.style.background = '#545b62';
       cancelBtn.onmouseout = () => cancelBtn.style.background = '#6c757d';
   
       draftBtn.onclick = handleDraftSave;
       cancelBtn.onclick = handleCancel;
   
       buttonContainer.appendChild(draftBtn);
       buttonContainer.appendChild(cancelBtn);
   
       const modal = document.getElementById("trayScanModal_DayPlanning");
       const modalContent = modal.querySelector('.tray-scan-modal-DayPlanning-content');
       if (modalContent) {
         modalContent.appendChild(infoMsg);
         modalContent.appendChild(buttonContainer);
       }
   
       draftButtonsShown = true;
     }
   
     // ✅ REMOVE DRAFT/CANCEL BUTTONS
     function removeDraftCancelButtons() {
       const existingInfoMsg = document.getElementById('draftInfoMessage');
       if (existingInfoMsg) {
         existingInfoMsg.remove();
       }
   
       const existingButtons = document.getElementById('draftCancelButtons');
       if (existingButtons) {
         existingButtons.remove();
       }
   
       draftButtonsShown = false;
     }
   
     // ✅ HANDLE CANCEL
     function handleCancel() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (modal) {
         modal.classList.remove("open");
         modal.style.display = "none";
       }
     }
   
     // ✅ UPDATE MAIN TABLE ROW FOR DRAFT WITH QUANTITIES
     function updateMainTableRowForDraftWithQuantities(lotId, missingQty, physicalQty) {
       try {
         const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
         if (!mainTableRow) {
           return;
         }
   
         const missingQtyInput = mainTableRow.querySelector('.missing-qty-input');
         if (missingQtyInput) {
           missingQtyInput.value = missingQty;
           missingQtyInput.style.backgroundColor = '#fff3cd';
           missingQtyInput.style.borderColor = '#ffc107';
         }
   
         const physicalQtyInput = mainTableRow.querySelector('.physical-qty-input');
         if (physicalQtyInput) {
           physicalQtyInput.value = physicalQty;
           physicalQtyInput.style.backgroundColor = '#fff3cd';
           physicalQtyInput.style.borderColor = '#ffc107';
           physicalQtyInput.setAttribute('title', 'This quantity was calculated from draft');
         }
   
   
   
         const lotStatusCell = mainTableRow.cells[17];
         if (lotStatusCell) {
           lotStatusCell.innerHTML = `
             <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                 style="border: 1px solid #4997ac; background-color: #d1f2f3; color: #03425d; 
                        font-size: 12px; white-space: nowrap; 
                        padding-top: 0.5rem; padding-bottom: 0.5rem;">
               Draft (Qty Calculated)
             </div>
           `;
         }
   
       } catch (error) {
       }
     }
   
     // ✅ UPDATE MAIN TABLE ROW STATUS
     function updateMainTableRowStatus(lotId, missingQty, physicalQty) {
       try {
         const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
         if (!mainTableRow) {
           return;
         }
   
         const missingQtyInput = mainTableRow.querySelector('.missing-qty-input');
         if (missingQtyInput) {
           missingQtyInput.value = missingQty;
           missingQtyInput.disabled = true;
           if (missingQty === 0) {
             missingQtyInput.style.backgroundColor = '#d4edda';
             missingQtyInput.style.borderColor = '#28a745';
           } else {
             missingQtyInput.style.backgroundColor = '#fff3cd';
             missingQtyInput.style.borderColor = '#ffc107';
           }
         }
   
         const physicalQtyInput = mainTableRow.querySelector('.physical-qty-input');
         if (physicalQtyInput) {
           physicalQtyInput.value = physicalQty;
           physicalQtyInput.style.backgroundColor = '#d4edda';
           physicalQtyInput.style.borderColor = '#28a745';
           physicalQtyInput.setAttribute('title', 'Quantity verified through tray scan');
         }
   
         const checkbox = mainTableRow.querySelector('.ip-checkbox');
         if (checkbox) {
           checkbox.checked = true;
           checkbox.disabled = true;
         }
   
         const processIcons = mainTableRow.querySelectorAll('.d-flex > div');
         if (processIcons.length > 0) {
           processIcons[0].style.backgroundColor = '#0c8249';
         }
   
         const saveIpCheckbox = mainTableRow.querySelector('.save-ip-checkbox');
         if (saveIpCheckbox) {
           saveIpCheckbox.style.display = 'none';
         }
   
   
       } catch (error) {
       }
     }
   
     // ✅ SHOW SUCCESS MESSAGE
     function showSuccessMessage(message, color = '#28a745') {
       const existingMsg = document.getElementById('auto-save-message');
       if (existingMsg) {
         existingMsg.remove();
       }
   
       const messageDiv = document.createElement('div');
       messageDiv.id = 'auto-save-message';
       messageDiv.style.cssText = `
         position: fixed;
         top: 20px;
         right: 20px;
         background: ${color};
         color: white;
         padding: 12px 20px;
         border-radius: 8px;
         box-shadow: 0 4px 12px rgba(0,0,0,0.15);
         z-index: 10002;
         font-weight: 500;
         transform: translateX(400px);
         transition: transform 0.3s ease;
         max-width: 300px;
         word-wrap: break-word;
       `;
       messageDiv.style.zIndex = "1000001"; // Higher than modal
   
       messageDiv.textContent = message;
       document.body.appendChild(messageDiv);
   
       setTimeout(() => {
         messageDiv.style.transform = 'translateX(0)';
       }, 100);
   
       setTimeout(() => {
         messageDiv.style.transform = 'translateX(400px)';
         setTimeout(() => {
           if (messageDiv.parentNode) {
             messageDiv.parentNode.removeChild(messageDiv);
           }
         }, 300);
       }, 4000);
     }
   
     // ✅ Make functions available globally
     window.showDraftCancelButtons = showDraftCancelButtons;
     window.removeDraftCancelButtons = removeDraftCancelButtons;
     window.autoTriggerCheckboxSave = autoTriggerCheckboxSave;
     window.handleDraftSave = handleDraftSave;
     window.draftButtonsShown = draftButtonsShown;
   });
</script>
<!-- ✅ SCRIPT 5: Button Handlers and Modal Controls -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
   // ✅ IMPROVED: TRAY VALIDATE BUTTON HANDLER - Prevent rebuilding if already active
   const validateBtn = document.getElementById("trayValidateBtn");
   const validateInput = document.getElementById("trayValidateInput");
   const errorMessage = document.getElementById("trayErrorMessage");
   
   if (validateBtn && validateInput) {
     validateBtn.addEventListener("click", function () {
       if (validateBtn.disabled) return;
   
       // ✅ NEW: Check if validation mode is already active
       const modal = document.getElementById("trayScanModal_DayPlanning");
       const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
       
       // Check if validation column already exists
       const hasValidationColumn = detailsDiv.querySelector('th:last-child')?.textContent.includes('Tray Validation Status');
       
       if (hasValidationColumn) {
         // ✅ Validation mode already active - just focus input, don't rebuild table
         console.log('✅ Validation mode already active - preserving tick marks');
         validateInput.value = "";
         validateInput.focus();
         return;
       }
   
       // ✅ First time clicking - proceed with normal setup
       validateInput.value = "";
       if (errorMessage) {
         errorMessage.style.display = "none";
       }
       
       // Change button to active state
       validateBtn.style.background = "#e8f5e8";
       validateBtn.style.borderColor = "#4caf50";
       validateBtn.style.color = "#2e7d32";
       
       // Add the validation column to the table (only first time)
       if (modal && detailsDiv && modal.buildTableHTML) {
         detailsDiv.innerHTML = modal.buildTableHTML(true);
       }
       
       validateInput.focus();
     });
   }
   
     // ✅ REDO BUTTON HANDLER
     const redoBtn = document.getElementById("trayQtyRedoBtn");
     if (redoBtn && validateInput) {
       redoBtn.addEventListener("click", function () {
         validateInput.value = "";
         validateInput.blur();
         
         if (errorMessage) {
           errorMessage.style.display = "none";
         }
         
         // Reset button to normal state
         if (validateBtn) {
           validateBtn.style.background = "#f5faff";
           validateBtn.style.borderColor = "#023E4DCC";
           validateBtn.style.color = "#023E4DCC";
         }
         
         // Remove the validation column from the table
         const modal = document.getElementById("trayScanModal_DayPlanning");
         const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
         if (modal && detailsDiv && modal.buildTableHTML) {
           detailsDiv.innerHTML = modal.buildTableHTML(false);
         }
   
         // Reset tray verification for this lot
         const lotId = window.getCurrentLotId();
         if (lotId) {
           fetch('/recovery_is/rec_reset_tray_verification_for_lot/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': window.getCookie('csrftoken')
             },
             body: JSON.stringify({ lot_id: lotId })
           })
           .then(res => res.json())
           .then(data => {
             // Silent operation
           })
           .catch(() => {
             // Silent operation
           });
         }
   
         redoBtn.focus();
       });
     }
   
   
     // ✅ QTY INPUT CHANGE HANDLER
     document.addEventListener('input', function (e) {
       if (e.target.classList.contains('tray-qty-input') && e.target.dataset.topTray === "1") {
         const originalQty = parseInt(e.target.getAttribute('data-initial'), 10) || 0;
         let currentQty = parseInt(e.target.value, 10) || 0;
         
         // Prevent increasing above original
         if (currentQty > originalQty) {
           e.target.value = originalQty;
         }
         // Prevent going below zero
         if (currentQty < 0) {
           e.target.value = 0;
         }
         
         // Enable Tray Validate button
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
         }
       }
     });
   
     // ✅ MODAL CLOSE HANDLER
     const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
     if (closeBtn) {
       closeBtn.addEventListener("click", function () {
         window.removeDraftCancelButtons();
         window.draftButtonsShown = false;
         
         const modal = document.getElementById("trayScanModal_DayPlanning");
         if (modal) {
           modal.classList.remove("open");
           modal.style.display = "none";
         }
         
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
           validateBtn.style.background = "#f5faff";
           validateBtn.style.borderColor = "#023E4DCC";
           validateBtn.style.color = "#023E4DCC";
         }
       });
     }
   });
</script>
<!--Accept functionality-->
<script nonce="{{csp_nonce}}">
   document.addEventListener("DOMContentLoaded", function () {
     // Use event delegation to handle dynamically created buttons
     document.addEventListener('click', function(e) {
       // Check if the clicked element is an Accept button
       if (e.target.closest('.btn-twitter')) {
         const acceptBtn = e.target.closest('.btn-twitter');
         
         // Skip if button is disabled
         if (acceptBtn.disabled) return;
         
         const row = acceptBtn.closest('tr');
         if (!row) return;
         
         // Try to get lot ID from multiple sources
         let lotId = acceptBtn.getAttribute('data-lot-id');
         if (!lotId) {
           const checkbox = row.querySelector('.ip-checkbox');
           lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
         }
         if (!lotId) {
           lotId = row.getAttribute('data-stock-lot-id');
         }
         
         if (!lotId) {
           Swal.fire('Error', 'Lot ID not found', 'error');
           return;
         }
         
         // Show confirmation dialog before proceeding
         Swal.fire({
           title: 'Lot Accept',
           text: 'Are you sure you want to accept this lot?',
           icon: 'question',
           showCancelButton: true,
           confirmButtonColor: '#28a745',
           cancelButtonColor: '#6c757d',
           confirmButtonText: 'Yes, Accept',
           cancelButtonText: 'Cancel',
           reverseButtons: true
         }).then((result) => {
           if (result.isConfirmed) {
             // User confirmed, proceed with acceptance
             
             // Disable button during processing
             acceptBtn.disabled = true;
             
             fetch('/recovery_is/rec_is_accepted_form/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({ stock_lot_id: lotId })
         })
         .then(res => {
           if (res.redirected) {
             window.location.href = res.url; // handle Django redirect
             return;
           }
           return res.json();
         })
         .then(data => {
           if (data && data.success) {
             Swal.fire({
               icon: 'success',
               title: 'Accepted successfully!',
               showConfirmButton: false,
               timer: 1200
             }).then(() => {
               // Update UI elements silently instead of reloading page
               window.location.reload(); // Reload to reset state
             });
           } else if (data && data.error) {
             Swal.fire('Error', data.error, 'error');
             // Re-enable button on error
             acceptBtn.disabled = false;
           }
         })
         .catch((error) => {
           Swal.fire('Error', 'Network error', 'error');
           // Re-enable button on error
           acceptBtn.disabled = false;
         });
           }
         });
       }
     });
     
     // Helper function for CSRF token (if not already defined)
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   });
</script>
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
   
     const cancelBtn = document.getElementById("trayScanCancelBtn");
     if (cancelBtn) {
       cancelBtn.addEventListener("click", function () {
         const modal = document.getElementById("trayScanModal_BQ");
         if (modal) modal.classList.remove("open");
       });
     }
   
      // DELETE BUTTON HANDLER
   document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
     btn.addEventListener('click', function(e) {
       e.preventDefault();
       const row = btn.closest('tr');
       if (!row) return;
       const batchId = btn.getAttribute('data-batch-id');
       const stockLotId = btn.getAttribute('data-stock-lot-id');
       if (!batchId || !stockLotId) {
         Swal.fire('Error', 'Batch ID or Stock Lot ID not found!', 'error');
         return;
       }
       Swal.fire({
         title: 'Are you sure?',
         text: 'Do you really want to delete this batch?',
         icon: 'warning',
         showCancelButton: true,
         confirmButtonColor: '#d33',
         cancelButtonColor: '#3085d6',
         confirmButtonText: 'Yes, delete it!',
         cancelButtonText: 'Cancel'
       }).then((result) => {
         if (result.isConfirmed) {
           fetch('/recovery_is/rec_ip_delete_batch/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify({ batch_id: batchId, stock_lot_id: stockLotId })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               row.remove();
               Swal.fire({
                 icon: 'success',
                 title: 'Deleted!',
                 text: 'Batch has been deleted.',
                 timer: 1200,
                 showConfirmButton: false
               });                  
             } else {
               Swal.fire('Error', data.error || 'Delete failed', 'error');
             }
           });
         }
       });
     });
   });
   
   
   // Helper function to show error notification
   function showErrorNotification(message) {
   // Create or get existing notification element
   let notification = document.getElementById('error-notification');
   if (!notification) {
   notification = document.createElement('div');
   notification.id = 'error-notification';
   notification.style.cssText = `
   position: fixed;
   top: 20px;
   right: 20px;
   background: #dc3545;
   color: white;
   padding: 12px 20px;
   border-radius: 8px;
   box-shadow: 0 4px 12px rgba(220,53,69,0.15);
   z-index: 10001;
   font-weight: 500;
   transform: translateX(400px);
   transition: transform 0.3s ease;
   `;
   document.body.appendChild(notification);
   }
   
   notification.textContent = message;
   
   // Show notification
   setTimeout(() => {
   notification.style.transform = 'translateX(0)';
   }, 100);
   
   // Hide notification after 4 seconds (longer for errors)
   setTimeout(() => {
   notification.style.transform = 'translateX(400px)';
   }, 4000);
   }
   
   const table = document.getElementById("order-listing");
     if (!table) {
       return;
     }
   
     const headers = table.querySelectorAll("thead th");
     const tbody = table.querySelector("tbody");
   
     let sortDirection = {};
   
     headers.forEach((header, index) => {
       header.style.cursor = "pointer";
   
       header.addEventListener("click", function () {
         const rows = Array.from(tbody.querySelectorAll("tr"));
         const dir = sortDirection[index] === "asc" ? "desc" : "asc";
         sortDirection[index] = dir;
   
         rows.sort((a, b) => {
           const cellA = a.children[index].textContent.trim();
           const cellB = b.children[index].textContent.trim();
           const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
           const valB = isNaN(cellB) ? cellB : parseFloat(cellB);
   
           if (valA < valB) return dir === "asc" ? -1 : 1;
           if (valA > valB) return dir === "asc" ? 1 : -1;
           return 0;
         });
   
         tbody.innerHTML = "";
         rows.forEach((row) => tbody.appendChild(row));
       });
     });
   });
</script>
<!-- Complete Tray Scan Modal & New Popup Script with Simplified Single Top Tray Scan -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", () => {
     const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
     const trayModal = document.getElementById("trayScanModal");
     const closeTrayBtn = document.getElementById("closeTrayScanModal");
     if (closeTrayBtn && trayModal) {
       closeTrayBtn.addEventListener("click", function () {
         trayModal.classList.remove("open");
         trayModal.style.display = "none";
       });
     }

     const detailsDiv = document.getElementById("trayScanDetails");
     const newPopupModal = document.getElementById("newPopupModal");
     const closeNewPopupBtn = document.getElementById("closeNewPopupModal");
   
     // ✅ NEW: Draft functionality variables
     let isDraftMode = false;
     let currentDraftData = null;
   
     trayScanLinks.forEach((link) => {
       link.addEventListener("click", (event) => {
         event.preventDefault();
   
         const row = event.target.closest("tr");
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         const isOnProceed = row.getAttribute('data-few-cases-acceptance') === 'True';
   
         trayModal.dataset.batchId = batchId;
         trayModal.dataset.stockLotId = stockLotId;
   
         const dateTime = row.cells[1].textContent.trim();
         const totalQuantity = row.cells[10].textContent.trim();
         const modelNo = row.getAttribute('data-model-no') || '';
         const modalHeader = document.getElementById("trayScanModalHeader");
         if (modalHeader) {
           modalHeader.innerHTML = `R-Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
         }
   
         // If ip_onhold_picking is True, show read-only saved data
         // ✅ NEW: Check if this is a Top Tray Scan button (isOnProceed = true)
         if (isOnProceed) {
           // Skip the rejection modal and go directly to accepted tray modal
           fetch(`/recovery_is/rec_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
             .then(res => res.json())
             .then(rescanData => {
               if (rescanData.success) {
                 showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
               } else {
                 // Fallback to showing rejection modal if accepted tray data fails
                 showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
               }
             })
             .catch(error => {
               console.error('Error fetching accepted tray data:', error);
               // Fallback to showing rejection modal
               showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
             });
           return; // Exit early, don't show rejection modal
         }
   
         // ✅ EXISTING: Normal flow for new rejections (when isOnProceed = false)
         showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
       });
     });
   
     // ✅ NEW: Extract the original modal logic into a separate function
   function showRejectionModalFlow(batchId, stockLotId, isOnProceed, row) {
   const trayModal = document.getElementById("trayScanModal");
   const detailsDiv = document.getElementById("trayScanDetails");
   
   trayModal.dataset.batchId = batchId;
   trayModal.dataset.stockLotId = stockLotId;
   
   const dateTime = row.cells[1].textContent.trim();
   const totalQuantity = row.cells[10].textContent.trim();
   const modelNo = row.getAttribute('data-model-no') || '';
   const modalHeader = document.getElementById("trayScanModalHeader");
   if (modalHeader) {
   modalHeader.innerHTML = `R-Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
   }
   
   // If ip_onhold_picking is True, show read-only saved data
   if (isOnProceed) {
   showReadOnlyRejectionData(stockLotId, detailsDiv);
   } else {
   // ✅ UPDATED: Check for draft first, then show form
   checkForExistingDraft(stockLotId, batchId, detailsDiv, row);
   }
   
   trayModal.style.display = "block";
   trayModal.classList.add("open");
   }
   
     // ✅ NEW: Check for existing draft data
     function checkForExistingDraft(stockLotId, batchId, detailsDiv, row) {
       fetch(`/recovery_is/rec_get_rejection_draft/?lot_id=${encodeURIComponent(stockLotId)}`)
         .then(res => res.json())
         .then(data => {
           if (data.success && data.has_draft) {
             isDraftMode = true;
             currentDraftData = data.draft_data;
             showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, currentDraftData);
           } else {
             isDraftMode = false;
             currentDraftData = null;
             showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
           }
         })
         .catch(error => {
           // Fallback to normal form
           isDraftMode = false;
           currentDraftData = null;
           showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
         });
     }
   
// ✅ UPDATED: Function to show editable rejection form with optional draft data
function showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, draftData) {
  // Get tray capacity from the row
  const trayCapacityText = row.cells[7]?.textContent || ''; // Tray Category-Capacity column
  const trayCapacity = trayCapacityText.includes('-') ?
                      parseInt(trayCapacityText.split('-')[1]) : 10; // Default to 10
  
  // Set data attribute for tray capacity
  row.setAttribute('data-tray-capacity', trayCapacity);
  
  // ✅ NEW: Draft mode styling and indicators
  const draftIndicator = isDraftMode ? ' (Draft Mode)' : '';
  const draftAlert = isDraftMode ? `
    <div class="alert alert-info draft-mode-alert" style="margin: 10px 0; padding: 8px 12px; font-size: 14px; border-left: 4px solid #028084; animation: draftModeGlow 2s ease-in-out infinite alternate;">
      <i class="fa fa-edit"></i> <strong>Draft Mode:</strong> You are editing saved draft data. Click "Draft" to save changes or "Proceed" to finalize.
    </div>
  ` : '';

  const headerColor = isDraftMode ? '#f39c12' : '#028084';
  const inputStyle = isDraftMode ? 'background-color: #fff3cd; border-color: #f39c12; border-width: 2px;' : '';
            detailsDiv.innerHTML = `
                ${draftAlert}
                <!-- ✅ UPDATED: Enhanced header section with better visual consistency -->
                <div class="d-flex justify-content-between align-items-center mb-3" style="padding: 5px !important; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 10px; border-left: 4px solid ${isDraftMode ? '#f39c12' : '#028084'}; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                  <h4 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 8px;">
                    Rejection Reason List${draftIndicator}
                  </h4>
                  
                  <div class="form-check d-flex align-items-center" style="margin: 0; padding: 3px 12px; background: #fff; border-radius: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                      <input class="form-check-input" type="checkbox" id="batchRejection"
                             style="width: 13px; height: 13px;margin-left: 0px !important; margin-right: 8px; accent-color: ${isDraftMode ? '#f39c12' : '#028084'};"
                             ${draftData && draftData.is_batch_rejection ? 'checked' : ''} />
                      <label class="form-check-label" for="batchRejection" style="font-size: 14px; font-weight: 600; color: #495057; margin: 0; cursor: pointer;">Lot Rejection</label>
                  </div>
                </div>
              
                <!-- ✅ REDESIGNED: Perfectly matched table with enhanced headers -->
                <div id="rejection-reasons-section" class="table-responsive"
style="max-height: 320px !important; border: 1px solid #dee2e6; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); background: #fff; scrollbar-width: none; -ms-overflow-style: none; display: grid; grid-template-columns: 1fr; overflow-y: auto; overscroll-behavior: contain;">
<table class="table table-bordered text-center mb-0" style="font-size: 13px; border-collapse: initial !important; border-color: black !important; border-spacing: 0; grid-column: 1 / -1;">
                    <thead style="background: linear-gradient(135deg, ${headerColor} 0%, ${isDraftMode ? '#e67e22' : '#0056b3'} 100%); position: relative;">
                      <tr style="border: 1px solid #282f3a;">
                        <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; width: 50px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                            S.No
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); width: 65px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                            ID
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 12px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                            Rejection Reason
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); width: 75px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                            Qty
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 12px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); min-width: 150px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                            Tray ID(s)
                          </div>
                        </th>
                      </tr>
                      <!-- ✅ ADD: Subtle shadow line under header -->
                      <tr style="height: 2px; background: linear-gradient(90deg, transparent 0%, rgba(0,0,0,0.1) 50%, transparent 100%);"><td colspan="5" style="padding: 0;border: 1px solid #282f3a;"></td></tr>
                    </thead>
                    <tbody id="rejection-table-body" style="background: #fff;">
                      {% for reason in ip_rejection_reasons %}
                      <tr data-batch-id="${batchId}" data-stock-lot-id="${stockLotId}" style="border-bottom: 1px solid #f1f3f4; transition: all 0.2s ease;">
                        <td style="padding: 8px 6px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #f1f3f4;">{{ forloop.counter }}</td>
                        <td style="color: {{ reason.row_color }}; padding: 5px; font-size: 11px; font-weight: 700; border-right: 1px solid #f1f3f4; background: #fafbfc;">{{ reason.rejection_reason_id }}</td>
                        <td style="color: {{ reason.row_color }}; padding: 5px; font-size: 12px; text-align: left; font-weight: 500; border-right: 1px solid #f1f3f4;">{{ reason.rejection_reason }}</td>
                        <td style="padding: 6px; border-right: 1px solid #f1f3f4; background: #fafbfc;">
                          <input type="number"
                                 min="0"
                                 class="form-control rejection-qty-input"
                                 name="quantity_{{ forloop.counter }}"
                                 style="width: 65px; height: 25px !important; padding: 6px !important; font-size: 12px; text-align: center; border: 2px solid #e1e5e9; border-radius: 6px; font-weight: 600; transition: all 0.3s ease; ${inputStyle}"
                                 data-reason-id="{{ reason.rejection_reason_id }}"
                                 value="" />
                        </td>
                        <td style="vertical-align: middle; padding: 8px 12px; min-width: 150px; max-width: 200px; background: #fafbfc;">
                          <span style="color: #8e9aaf; font-style: italic; font-size: 11px; font-weight: 500;">Enter quantity first</span>
                        </td>
                      </tr>
                      {% endfor %}
                      <!-- ✅ ENHANCED: Total row with better styling -->
                      <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-top: 3px solid ${isDraftMode ? '#f39c12' : '#028084'};">
                        <td colspan="4" style="text-align: right; font-weight: 700; padding: 12px 16px; font-size: 14px; color: #495057; border-right: 1px solid #dee2e6;">
                          <i class="fa fa-calculator" style="margin-right: 6px; color: ${isDraftMode ? '#f39c12' : '#028084'};"></i>
                          Total Qty
                        </td>
                        <td id="rejection-total-qty" style="font-weight: 700; padding: 12px 16px; font-size: 16px; color: #28a745; background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); text-align: center;">0</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                
                <!-- ✅ ENHANCED: Better integrated remarks section -->
                <div id="lotRejectionRemarksSection" style="display: none; margin-top: 16px; padding: 16px; border: 2px solid #28a745; border-radius: 10px; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); box-shadow: 0 4px 8px rgba(40, 167, 69, 0.1);">
                  <div style="margin-bottom: 12px;">
                    <label style="font-weight: 700; color: #28a745; margin-bottom: 6px; display: block; font-size: 14px; display: flex; align-items: center; gap: 6px;">
                      <i class="fa fa-check-circle" style="font-size: 16px;"></i>
                      Lot Rejection Remarks (Required)
                    </label>
                    <textarea
                      id="lotRejectionRemarksInput"
                      placeholder="Please provide detailed reason for lot rejection..."
                      style="width: 100%; height: 70px; padding: 12px 16px; border: 2px solid #28a745; border-radius: 8px; font-size: 13px; resize: vertical; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fff; transition: all 0.3s ease;"
                      maxlength="500"></textarea>
                    <div style="text-align: right; margin-top: 5px; font-size: 12px; color: #6c757d;">
                      <span id="remarksCharCount">0</span>/500 characters
                    </div>
                  </div>
                  <div style="font-size: 12px; color: #155724; background-color: #d4edda; padding: 5px; border-radius: 6px; border-left: 4px solid #28a745; display: flex; align-items: center; gap: 8px;">
                    <i class="fa fa-info-circle" style="font-size: 14px;"></i>
                    <span><strong>Note:</strong> Lot rejection remarks are mandatory when rejecting the entire lot.</span>
                  </div>
                </div>
                
                <div id="batchRejectionMsg" style="margin: 5px 0; color: #d32f2f; font-weight: 600; font-size: 13px; text-align: center; min-height: 0px;"></div>
              
                <!-- ✅ OLD SIMPLE BUTTON DESIGN -->
                <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                  ${isDraftMode ? `
                    <button id="updateDraftButton" style="padding: 8px 16px; background: #f39c12; color: white; border: none; border-radius: 30px;">
                      Update Draft
                    </button>
                  ` : `
                    <button id="draftButton" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                      Draft
                    </button>
                  `}
                  <button id="proceedButton" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                    Proceed
                  </button>
                  <button id="cancelButton" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
                    Cancel
                  </button>
                </div>

              `;

  if (draftData) {
    loadDraftDataIntoForm(draftData);
  }

  // ✅ NEW: Add event listener for Lot Rejection checkbox
  const batchRejectionCheckbox = document.getElementById('batchRejection');
  const rejectionReasonsSection = document.getElementById('rejection-reasons-section');
  const lotRejectionRemarksSection = document.getElementById('lotRejectionRemarksSection');
  
  if (batchRejectionCheckbox) {
    // Set initial state based on checkbox status
    if (batchRejectionCheckbox.checked) {
      rejectionReasonsSection.style.display = 'none';
      lotRejectionRemarksSection.style.display = 'block';
    } else {
      rejectionReasonsSection.style.display = 'grid';
      lotRejectionRemarksSection.style.display = 'none';
    }

    batchRejectionCheckbox.addEventListener('change', function() {
      if (this.checked) {
        // When Lot Rejection is checked: Hide rejection reasons table, show only remarks section
        rejectionReasonsSection.style.display = 'none';
        lotRejectionRemarksSection.style.display = 'block';
        
        // Clear all rejection reason quantities when switching to lot rejection
        const qtyInputs = document.querySelectorAll('.rejection-qty-input');
        qtyInputs.forEach(input => {
          input.value = '';
        });
        
        // Update total quantity to 0
        const totalQtyElement = document.getElementById('rejection-total-qty');
        if (totalQtyElement) {
          totalQtyElement.textContent = '0';
        }
      } else {
        // When Lot Rejection is unchecked: Show rejection reasons table, hide remarks section
        rejectionReasonsSection.style.display = 'grid';
        lotRejectionRemarksSection.style.display = 'none';
        
        // Clear lot rejection remarks when switching back
        const lotRemarksInput = document.getElementById('lotRejectionRemarksInput');
        if (lotRemarksInput) {
          lotRemarksInput.value = '';
        }
      }
    });
  }

  // Add the updated event listeners for the editable form
  addEditableFormEventListeners(row, batchId, stockLotId);
}


     // ✅ FIXED: Enhanced loadDraftDataIntoForm function
function loadDraftDataIntoForm(draftData) {
  console.log('🔄 [loadDraftDataIntoForm] Loading draft data:', draftData);
  
  // ✅ FIRST: Load batch rejection state and show remarks section if needed
  if (draftData.is_batch_rejection) {
    console.log('✅ Loading batch rejection draft with remarks');
    
    const batchCheckbox = document.getElementById("batchRejection");
    if (batchCheckbox) {
      batchCheckbox.checked = true;
      console.log('✅ Set batch rejection checkbox to true');
      
      // ✅ CRITICAL: Show the lot rejection remarks section immediately
      const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");
      if (lotRejectionRemarksSection) {
        lotRejectionRemarksSection.style.display = "block";
        lotRejectionRemarksSection.style.opacity = "1";
        lotRejectionRemarksSection.style.transform = "translateY(0)";
        console.log('✅ Showed lot rejection remarks section');
      }
      
      // ✅ FIXED: Load the draft remarks
      const lotRejectionRemarksInput = document.getElementById("lotRejectionRemarksInput");
      if (lotRejectionRemarksInput) {
        const remarksValue = draftData.lot_rejection_remarks || '';
        lotRejectionRemarksInput.value = remarksValue;
        console.log('✅ Set remarks value:', remarksValue);
        
        // Update character count
        const remarksCharCount = document.getElementById("remarksCharCount");
        if (remarksCharCount) {
          remarksCharCount.textContent = remarksValue.length;
          
          // Update character count color
          if (remarksValue.length > 450) {
            remarksCharCount.style.color = "#dc3545";
          } else if (remarksValue.length > 350) {
            remarksCharCount.style.color = "#ffc107";
          } else {
            remarksCharCount.style.color = "#28a745";
          }
        }
        
        // Trigger input event to ensure any other listeners are notified
        lotRejectionRemarksInput.dispatchEvent(new Event('input'));
      }
      
      // Disable quantity inputs for lot rejection
      document.querySelectorAll('.rejection-qty-input').forEach(input => {
        input.disabled = true;
        input.value = ""; // Clear values
      });
      document.getElementById('rejection-total-qty').textContent = "0";
      console.log('✅ Disabled quantity inputs for batch rejection');
    }
  }
  
  // Load rejection quantities (only if not batch rejection)
  if (!draftData.is_batch_rejection && draftData.rejection_data && draftData.rejection_data.length > 0) {
    console.log('✅ Loading individual rejection data');
    
    draftData.rejection_data.forEach(item => {
      const input = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
      if (input) {
        input.value = item.qty;
        input.style.backgroundColor = '#fff3cd';
        input.style.borderColor = '#f39c12';
        input.style.borderWidth = '2px';
        
        // Trigger input event to generate tray ID fields
        input.dispatchEvent(new Event('input'));
        console.log(`✅ Set quantity ${item.qty} for reason ${item.reason_id}`);
      }
    });
    
    // Update total
    const totalQty = draftData.total_rejection_qty || 0;
    document.getElementById('rejection-total-qty').textContent = totalQty;
    console.log('✅ Set total rejection qty:', totalQty);
  }
  
  // ✅ FIXED: Load tray scans for non-batch rejections
  if (!draftData.is_batch_rejection && draftData.tray_scans && draftData.tray_scans.length > 0) {
    // Wait for tray inputs to be generated
    setTimeout(() => {
      console.log('✅ Loading tray scans:', draftData.tray_scans);
      
      // ✅ NEW: Group tray scans by reason_id first
      const traysByReason = {};
      draftData.tray_scans.forEach(scan => {
        const reasonId = scan.reason_id;
        if (!traysByReason[reasonId]) {
          traysByReason[reasonId] = [];
        }
        traysByReason[reasonId].push(scan);
      });
      
      console.log('📦 Grouped trays by reason:', traysByReason);
      
      // ✅ FIXED: Load trays for each reason
      Object.keys(traysByReason).forEach(reasonId => {
        const traysForReason = traysByReason[reasonId];
        console.log(`🎯 Loading ${traysForReason.length} trays for reason ${reasonId}`);
        
        // Find the row for this reason
        const qtyInput = document.querySelector(`input[data-reason-id="${reasonId}"]`);
        if (qtyInput) {
          const row = qtyInput.closest('tr');
          const trayIdCell = row.querySelector('td:last-child');
          
          if (trayIdCell) {
            const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
            console.log(`Found ${trayInputs.length} tray inputs for reason ${reasonId}`);
            
            // ✅ FIXED: Load each tray into the corresponding input
            traysForReason.forEach((scan, index) => {
              if (index < trayInputs.length) {
                const trayInput = trayInputs[index];
                trayInput.value = scan.tray_id;
                
                // Update styling for loaded tray inputs
                trayInput.style.backgroundColor = '#fff3cd';
                trayInput.style.borderColor = '#f39c12';
                trayInput.style.borderWidth = '2px';
                
                console.log(`  ✅ Set tray ${index + 1}: ${scan.tray_id} (qty: ${scan.tray_qty})`);
                
                // ✅ NEW: Update the data-tray-qty attribute to match the saved quantity
                if (scan.tray_qty) {
                  trayInput.setAttribute('data-tray-qty', scan.tray_qty);
                }
              } else {
                console.log(`  ⚠️ No input available for tray ${index + 1}: ${scan.tray_id}`);
              }
            });
            
            // ✅ NEW: If we have more trays than inputs, something is wrong with the generation
            if (traysForReason.length > trayInputs.length) {
              console.warn(`⚠️ Mismatch: ${traysForReason.length} saved trays but only ${trayInputs.length} inputs for reason ${reasonId}`);
              
              // ✅ FIXED: Regenerate tray inputs with correct count
              const qtyValue = parseInt(qtyInput.value) || 0;
              if (qtyValue > 0) {
                console.log(`🔧 Regenerating tray inputs for reason ${reasonId} with qty ${qtyValue}`);
                generateDynamicTrayIdInputs(row, qtyValue, trayIdCell);
                
                // Wait a bit and try loading again
                setTimeout(() => {
                  const newTrayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
                  console.log(`🔄 After regeneration: ${newTrayInputs.length} inputs available`);
                  
                  traysForReason.forEach((scan, index) => {
                    if (index < newTrayInputs.length) {
                      const trayInput = newTrayInputs[index];
                      trayInput.value = scan.tray_id;
                      trayInput.style.backgroundColor = '#fff3cd';
                      trayInput.style.borderColor = '#f39c12';
                      trayInput.style.borderWidth = '2px';
                      
                      if (scan.tray_qty) {
                        trayInput.setAttribute('data-tray-qty', scan.tray_qty);
                      }
                      
                      console.log(`  🔄 Re-loaded tray ${index + 1}: ${scan.tray_id}`);
                    }
                  });
                }, 100);
              }
            }
          }
        }
      });
    }, 500); // Wait for tray inputs to be generated
  }
  
  console.log('✅ [loadDraftDataIntoForm] Draft loading completed');
}
   
   // ✅ UPDATED: Function to add event listeners WITH draft functionality
     function addEditableFormEventListeners(row, batchId, stockLotId) {
       // Get tray capacity from the row data
       const trayCapacity = parseInt(row.getAttribute('data-tray-capacity')) || 10;
       console.log('Tray capacity:', trayCapacity);
   
       // Quantity validation with dynamic tray scan generation
       const availableQty = parseInt(row.getAttribute('data-available-qty'), 10) || 0;        
   
       // Enhanced quantity validation with proactive limiting
       // ✅ UPDATED: Enhanced quantity validation with dynamic tray ID generation
   document.querySelectorAll('.rejection-qty-input').forEach(function(input, idx, allInputs) {
   // Real-time validation on input
   input.addEventListener('input', function() {
   const currentInput = this;
   const currentValue = parseInt(currentInput.value) || 0;
   const row = currentInput.closest('tr');
   const trayIdCell = row.querySelector('td:last-child'); // Tray ID column
   
   // Remove all previous qty errors
   document.querySelectorAll('.qty-error').forEach(function(span) { span.remove(); });
   
   // Calculate total from all OTHER inputs (excluding current)
   let totalFromOthers = 0;
   let hasQuantity = false;
   
   allInputs.forEach(function(otherInput) {
     if (otherInput !== currentInput) {
       const val = parseInt(otherInput.value) || 0;
       totalFromOthers += val;
       if (val > 0) hasQuantity = true;
     }
   });
   
   // Calculate maximum allowed value for current input
   const maxAllowed = Math.max(0, availableQty - totalFromOthers);
   
   // If current value exceeds maximum allowed, automatically adjust it
   if (currentValue > maxAllowed) {
     currentInput.value = maxAllowed;
     
     // Show helpful message
     let helpSpan = document.createElement('span');
     helpSpan.className = 'qty-help';
     helpSpan.style.color = '#f39c12';
     helpSpan.style.fontSize = '12px';
     helpSpan.style.display = 'block';
     helpSpan.style.marginTop = '2px';
     helpSpan.textContent = `Max allowed: ${maxAllowed} (Total limit: ${availableQty})`;
     currentInput.parentElement.appendChild(helpSpan);
     
     // Auto-hide the help message after 3 seconds
     setTimeout(() => {
       if (helpSpan.parentNode) {
         helpSpan.parentNode.removeChild(helpSpan);
       }
     }, 3000);
   }
   
   // Get final adjusted value
   const adjustedValue = parseInt(currentInput.value) || 0;
   const finalTotal = totalFromOthers + adjustedValue;
   
   // ✅ NEW: Generate dynamic tray ID inputs based on quantity
   generateDynamicTrayIdInputs(row, adjustedValue, trayIdCell);
   
   // Update total display
   document.getElementById('rejection-total-qty').textContent = finalTotal;
   });
   });
   
   // ✅ SIMPLIFIED: Calculate required trays based on standard capacity
   function calculateRequiredTrays(rejectionQty, trayCapacity = 12) {
   if (rejectionQty <= 0) {
   return [];
   }
   
   const traysNeeded = Math.ceil(rejectionQty / trayCapacity);
   const traysWithQuantity = [];
   let remainingQty = rejectionQty;
   
   for (let i = 0; i < traysNeeded; i++) {
   const qtyForThisTray = Math.min(remainingQty, trayCapacity);
   traysWithQuantity.push({
     trayIndex: i,
     trayCapacity: trayCapacity,
     trayQty: qtyForThisTray,
     isTopTray: i === 0,
     isComplete: qtyForThisTray === trayCapacity,
     isPartial: qtyForThisTray < trayCapacity
   });
   remainingQty -= qtyForThisTray;
   }
   
   console.log(`✅ Simplified calculation for qty ${rejectionQty} with capacity ${trayCapacity}:`, 
   traysWithQuantity.map(t => `Tray ${t.trayIndex + 1}: ${t.trayQty}/${t.trayCapacity}`).join(', '));
   return traysWithQuantity;
   }
   
   
   // ✅ FIXED: Corrected column indices for proper tray distribution
   function getActualTrayQuantitiesForCurrentLot() {
   const modal = document.getElementById("trayScanModal");
   const currentRow = document.querySelector('tr.highlighted-tray-scan');
   
   if (currentRow) {
   // Option 1: Get from data attribute if available
   const trayQtyList = currentRow.getAttribute('data-tray-qty-list');
   if (trayQtyList) {
     try {
       const parsed = JSON.parse(trayQtyList);
       if (parsed && parsed.length > 0) {
         console.log('Found actual tray quantities:', parsed);
         return parsed;
       }
     } catch (e) {
       console.log('Could not parse tray qty list:', e);
     }
   }
   
   // Option 2: Get from modal data if available
   if (modal && modal.traysData && modal.traysData.length > 0) {
     const actualQties = modal.traysData.map(tray => tray.tray_quantity || 0);
     console.log('Found actual tray quantities from modal:', actualQties);
     return actualQties;
   }
   }
   
   // Option 3: Fallback - Return standard capacity array for rejection calculation
   const trayCapacityText = currentRow?.cells[7]?.textContent || '';
   const standardCapacity = trayCapacityText.includes('-') ? 
                         parseInt(trayCapacityText.split('-')[1]) : 12;
   
   console.log(`Fallback: Using standard capacity ${standardCapacity} for rejection calculation`);
   
   // ✅ FIXED: For rejection scenarios, return an array of standard capacities
   // This allows the rejection calculation to work with standard tray sizes
   return Array(10).fill(standardCapacity); // Return 10 trays of standard capacity
   }
   
   // ✅ CORRECTED: Calculate complete tray rejections based on ACTUAL tray distribution
   function calculateCompleteTraysFromActualDistribution(rejectionQty) {
   const actualTrayQties = getActualTrayQuantitiesForCurrentLot();
   const traysWithQuantity = [];
   let remainingQty = rejectionQty;
   
   console.log(`Calculating trays for rejection qty: ${rejectionQty}`);
   console.log(`Actual tray distribution: [${actualTrayQties.join(', ')}]`);
   
   // Go through trays in order (top tray first)
   for (let i = 0; i < actualTrayQties.length && remainingQty > 0; i++) {
   const trayCapacity = actualTrayQties[i];
   const qtyForThisTray = Math.min(remainingQty, trayCapacity);
   
   // ✅ NEW: Include ANY tray that gets some quantity (complete OR partial)
   traysWithQuantity.push({
     trayIndex: i,
     trayCapacity: trayCapacity,
     trayQty: qtyForThisTray,
     isTopTray: i === 0,
     isComplete: qtyForThisTray === trayCapacity,
     isPartial: qtyForThisTray < trayCapacity
   });
   
   remainingQty -= qtyForThisTray;
   
   console.log(`  Tray ${i + 1}: ${qtyForThisTray}/${trayCapacity} qty (${qtyForThisTray === trayCapacity ? 'Complete' : 'Partial'})`);
   }
   
   const result = {
   traysWithQuantity: traysWithQuantity,
   totalQtyDistributed: rejectionQty - remainingQty,
   // Only skip tray scanning for partial top tray (not complete)
   needsTrayScanning: traysWithQuantity.length > 0 && !(traysWithQuantity.length === 1 && traysWithQuantity[0].isPartial)
   };
   
   console.log(`Result:`, result);
   return result;
   }
   
// ✅ ENHANCED: Improved generateDynamicTrayIdInputs to ensure proper count
function generateDynamicTrayIdInputs(row, quantity, trayIdCell) {
  // Get current reason to check if it's SHORTAGE
  const reasonCell = row.cells[2];
  const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
  const reasonId = row.querySelector('.rejection-qty-input').getAttribute('data-reason-id');
  
  // Clear existing tray ID inputs
  trayIdCell.innerHTML = '';
  
  if (quantity <= 0) {
    trayIdCell.innerHTML = '<span style="color: #999; font-style: italic;">Enter quantity first</span>';
    return;
  }
  
  if (reasonText === 'SHORTAGE') {
    trayIdCell.innerHTML = '<span style="color: #666; font-style: italic;">N/A (Shortage)</span>';
    return;
  }
  
  // ✅ FIXED: Use direct calculation instead of complex distribution logic
  const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                   document.querySelector('[data-stock-lot-id]') ||
                   document.querySelector('tbody tr');
  let trayCapacity = 12; // Default
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || '';
    if (trayCapacityText.includes('-')) {
      trayCapacity = parseInt(trayCapacityText.split('-')[1]) || 12;
    }
  }
  
  // ✅ FIXED: Simple calculation - exactly what you expect!
  const traysNeeded = Math.ceil(quantity / trayCapacity);
  
  console.log(`🔧 Generating tray inputs for qty: ${quantity}, capacity: ${trayCapacity}, traysNeeded: ${traysNeeded}`);
  
  // Generate tray ID inputs for required trays
  const trayIdContainer = document.createElement('div');
  trayIdContainer.className = 'tray-id-container';
  trayIdContainer.style.cssText = `
    display: flex; flex-direction: column; gap: 6px; padding: 8px;
    background-color: #f8f9fa; border: 2px solid #007bff; border-radius: 8px;
  `;
  
  // Add header for tray container
  const headerDiv = document.createElement('div');
  headerDiv.style.cssText = `
    font-weight: bold; font-size: 12px; color: #007bff; margin-bottom: 4px;
    text-align: center; border-bottom: 1px solid #007bff; padding-bottom: 4px;
  `;
  headerDiv.textContent = `${traysNeeded} Tray${traysNeeded > 1 ? 's' : ''} Required`;
  trayIdContainer.appendChild(headerDiv);
  
  // Generate inputs for all required trays
  for (let i = 0; i < traysNeeded; i++) {
    let remainingQty = quantity - (i * trayCapacity);
    let trayQty = Math.min(trayCapacity, remainingQty);
    
    const trayInputGroup = document.createElement('div');
    trayInputGroup.style.cssText = `
      display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
      padding: 6px; background-color: #ffffff; border: 1px solid #dee2e6;
      border-radius: 6px; transition: all 0.2s ease;
    `;
    
    // Tray number indicator
    const trayNumber = document.createElement('span');
    trayNumber.style.cssText = `
      font-size: 11px; font-weight: bold; color: #007bff;
      background-color: #e3f2fd; padding: 4px 8px; border-radius: 12px;
      min-width: 24px; text-align: center; border: 1px solid #2196f3;
    `;
    trayNumber.textContent = `${i + 1}`;
    
    // Tray ID input
    const trayInput = document.createElement('input');
    trayInput.type = 'text';
    trayInput.className = 'form-control rejection-tray-id-input';
    trayInput.style.cssText = `
      flex: 1; font-size: 12px; padding: 6px 10px;
      border: 2px solid #ced4da; border-radius: 6px;
      transition: all 0.2s ease; text-align: center; font-weight: 500;
    `;
    trayInput.placeholder = `Scan Tray ID ${i + 1}`;
    
    // Set data attributes
    trayInput.setAttribute('data-tray-index', i);
    trayInput.setAttribute('data-tray-capacity', trayCapacity);
    trayInput.setAttribute('data-tray-qty', trayQty);
    trayInput.setAttribute('data-is-complete', trayQty === trayCapacity);
    trayInput.setAttribute('data-is-partial', trayQty < trayCapacity);
    trayInput.setAttribute('data-reason-id', reasonId);
    trayInput.setAttribute('data-rejection-qty', quantity);
    trayInput.setAttribute('data-rejection-reason', reasonText);
    trayInput.setAttribute('data-expected-total-trays', traysNeeded);
    trayInput.setAttribute('data-tray-position-in-rejection', i + 1);
    
    // Error span for this specific tray
    const errorSpan = document.createElement('span');
    errorSpan.className = 'rejection-tray-error';
    errorSpan.style.cssText = `
      color: #dc3545; font-size: 10px; display: none;
      position: absolute; top: 100%; left: 0; right: 0;
      background: #f8d7da; border: 1px solid #f5c6cb;
      border-radius: 4px; padding: 4px 8px; margin-top: 2px; z-index: 10;
    `;
    
    // Position relative for error positioning
    trayInputGroup.style.position = 'relative';
    
    trayInputGroup.appendChild(trayNumber);
    trayInputGroup.appendChild(trayInput);
    trayInputGroup.appendChild(errorSpan);
    
    trayIdContainer.appendChild(trayInputGroup);
  }
  
  // Add summary footer
  const footerDiv = document.createElement('div');
  footerDiv.style.cssText = `
    font-size: 10px; color: #6c757d; text-align: center;
    margin-top: 6px; padding-top: 6px; border-top: 1px solid #dee2e6; font-style: italic;
  `;
  footerDiv.textContent = `Total quantity: ${quantity} across ${traysNeeded} tray${traysNeeded > 1 ? 's' : ''}`;
  trayIdContainer.appendChild(footerDiv);
  
  trayIdCell.appendChild(trayIdContainer);
  
  // Add validation for all new tray inputs
  addMultipleTrayIdValidationWithDynamic(trayIdCell);
  
  console.log(`✅ Generated ${traysNeeded} tray inputs for reason ${reasonId}`);
}
   // ✅ Helper function to get total rejection quantity for a specific reason
   function getTotalRejectionQuantityForReason(reasonId) {
   const qtyInput = document.querySelector(`input[data-reason-id="${reasonId}"].rejection-qty-input`);
   return qtyInput ? parseInt(qtyInput.value) || 0 : 0;
   }
   
   
   // ✅ NEW: Function to calculate tray distribution with remainder FIRST
   function calculateTrayDistribution(totalQuantity, trayCapacities) {
   const distribution = [];
   
   if (totalQuantity <= 0 || !trayCapacities.length) {
   return distribution;
   }
   
   // Use the first tray capacity as the standard capacity
   const standardCapacity = trayCapacities[0];
   
   // Calculate how many full trays we need and what the remainder is
   const fullTrays = Math.floor(totalQuantity / standardCapacity);
   const remainder = totalQuantity % standardCapacity;
   
   console.log(`Distribution calculation: total=${totalQuantity}, capacity=${standardCapacity}, fullTrays=${fullTrays}, remainder=${remainder}`);
   
   let trayIndex = 0;
   
   // ✅ FIXED: Put remainder FIRST (if there is one)
   if (remainder > 0) {
   distribution.push({
     capacity: trayCapacities[trayIndex] || standardCapacity,
     qty: remainder,
     index: trayIndex
   });
   trayIndex++;
   }
   
   // Then add full capacity trays
   for (let i = 0; i < fullTrays; i++) {
   const currentCapacity = trayCapacities[trayIndex] || standardCapacity;
   distribution.push({
     capacity: currentCapacity,
     qty: Math.min(standardCapacity, currentCapacity), // Use min to respect individual tray limits
     index: trayIndex
   });
   trayIndex++;
   }
   
   console.log(`Final distribution:`, distribution);
   return distribution;
   }
   
   // ✅ NEW: Function to get tray capacities for current lot
   function getTrayCapacitiesForCurrentLot() {

   
   const modal = document.getElementById("trayScanModal");
   const currentRow = document.querySelector('tr.highlighted-tray-scan');
   
   if (currentRow) {
   const trayCapacityText = currentRow.cells[7]?.textContent || ''; // Tray Category-Capacity column
   const trayCapacity = trayCapacityText.includes('-') ? 
                       parseInt(trayCapacityText.split('-')[1]) : 10;
   
   // For simplicity, assuming all trays have same capacity
   // You can modify this to get actual tray capacities from your API
   return Array(10).fill(trayCapacity); // Assuming max 10 trays with same capacity
   }
   
   // Default fallback
   return [6, 12, 12, 10, 10, 10, 10, 10, 10, 10]; // Sample capacities
   }
   
   function addMultipleTrayIdValidationWithDynamic(trayIdCell) {
   const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
   
   trayInputs.forEach(function(input, idx) {
   // Remove existing event listeners
   input.removeEventListener('blur', input._blurHandler);
   input.removeEventListener('input', input._inputHandler);
   input.removeEventListener('keydown', input._keydownHandler);
   
   // Track validation state
   input._hasError = false;
   input._isValidating = false;
   
   // Input event for counter update
   input._inputHandler = function() {
     this._hasError = false;
     const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
     if (errorSpan) {
       errorSpan.style.display = 'none';
       errorSpan.textContent = '';
     }
     updateRejectionScanCounter();
   };
   input.addEventListener('input', input._inputHandler);
   
   // Keydown handler
   input._keydownHandler = function(e) {
     if (e.key === 'Enter') {
       e.preventDefault();
       
       if (this._hasError || this._isValidating || !this.value.trim()) {
         return;
       }
       
       const nextInput = trayInputs[idx + 1];
       if (nextInput) {
         nextInput.focus();
       }
     }
   };
   input.addEventListener('keydown', input._keydownHandler);
   
   // ✅ ENHANCED: NEW tray aware validation
   input._blurHandler = function() {
     const trayId = this.value.trim();
     const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
     this._hasError = false;
   
     if (errorSpan) {
       errorSpan.textContent = '';
       errorSpan.style.display = 'none';
     }
   
     if (!trayId) {
       updateRejectionScanCounter();
       return;
     }
   
     this._isValidating = true;
   
     // Check for duplicates within current form
     let isDuplicate = false;
     document.querySelectorAll('.rejection-tray-id-input').forEach(function(otherInput) {
       if (otherInput !== input && otherInput.value.trim() === trayId) {
         isDuplicate = true;
       }
     });
   
    if (isDuplicate) {
      this._hasError = true;
      this._isValidating = false;
      if (errorSpan) {
        errorSpan.innerHTML = `❌ Duplicate`;
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#dc3545';
      }
      // Do NOT clear the value. Just select all and keep focus.
      setTimeout(() => {
        this.focus();
        this.select();
        // Do NOT hide the error immediately, let user correct it.
        updateRejectionScanCounter();
      }, 100);
      return;
    }
   
     // ✅ ENHANCED: Collect session allocations with NEW tray tracking
     const currentSessionAllocations = collectCurrentSessionAllocationsWithNewTrayTracking(this);
     const currentLotId = getCurrentLotId();
     const individualTrayQty = parseInt(this.getAttribute('data-tray-qty')) || 0;
     
     const rejectionContext = {
       tray_id: trayId,
       lot_id: currentLotId,
       rejection_qty: individualTrayQty,
       current_session_allocations: JSON.stringify(currentSessionAllocations)
     };
     
     console.log('🔍 NEW tray aware validation context:', rejectionContext);
     
     const queryParams = new URLSearchParams(rejectionContext).toString();
     fetch(`/recovery_is/rec_reject_check_tray_id_simple/?${queryParams}`)
       .then(res => res.json())
       .then(data => {
         this._isValidating = false;
         
         console.log('🔍 Session-aware validation response (with NEW tray logic):', data);
   
         if (errorSpan) {
           if (data.exists && data.valid_for_rejection) {
             this._hasError = false;
             
             // Show available tray quantities and tray count if present
             let availableMsg = '';
             if (Array.isArray(data.available_quantities)) {
               availableMsg = `<br><span style="color:#007bff;font-weight:normal;font-size:11px;">
               </span>`;
             }
   
             let successMessage = `✅ ${data.status_message}${availableMsg}`;
   
                         
            errorSpan.innerHTML = successMessage;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#155724';
            errorSpan.style.backgroundColor = '#d4edda';
            errorSpan.style.padding = '4px 8px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.fontSize = '11px';
            
            // Keep focus and select input, do not auto-hide
            setTimeout(() => {
              updateRejectionScanCounter();
            }, 100);
            // Do NOT
             
           } else {
             this._hasError = true;
             
             let errorMessage = `❌ ${data.status_message || 'Invalid'}`;
             
            errorSpan.innerHTML = errorMessage;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            errorSpan.style.backgroundColor = '#f8d7da';
            errorSpan.style.padding = '4px 8px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.fontSize = '11px';
            
            // Do NOT clear the value or hide the error. Just select all and keep focus.
            setTimeout(() => {
              this.focus();
              this.select();
              updateRejectionScanCounter();
            }, 100);
           }
         } else {
           updateRejectionScanCounter();
         }
       })
      .catch(() => {
        this._isValidating = false;
        this._hasError = true;
        if (errorSpan) {
          errorSpan.innerHTML = '❌ Connection Error';
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#721c24';
          errorSpan.style.backgroundColor = '#f8d7da';
          errorSpan.style.padding = '4px 8px';
          errorSpan.style.borderRadius = '4px';
          errorSpan.style.fontSize = '11px';
          setTimeout(() => {
            this.focus();
            this.select();
            updateRejectionScanCounter();
          }, 100);
        } else {
          updateRejectionScanCounter();
        }
      
       });
   };
   input.addEventListener('blur', input._blurHandler);
   });
   }
   
   // ✅ NEW: Enhanced session allocation collection with NEW tray tracking
   function collectCurrentSessionAllocationsWithNewTrayTracking(excludeInput) {
   const allocations = [];
   
   console.log('📊 [NEW Tray Aware Collection] Starting allocation collection...');
   
   document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
   const qty = parseInt(qtyInput.value) || 0;
   const reasonId = qtyInput.getAttribute('data-reason-id');
   
   if (qty > 0) {
     const row = qtyInput.closest('tr');
     const reasonCell = row.cells[2];
     const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
     const trayIdCell = row.querySelector('td:last-child');
     const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
     
     console.log(`📋 [NEW Tray Aware Collection] Processing reason ${reasonId} (${reasonText}): qty=${qty}, inputs=${trayInputs.length}`);
     
     const validTrayAllocations = [];
     let validTrayCount = 0;
     
     trayInputs.forEach((trayInput, index) => {
       const trayId = trayInput.value.trim();
       
       if (trayInput === excludeInput) {
         console.log(`   ⏭️ Skipping current input ${index + 1}: "${trayId}" (being validated)`);
         return;
       }
       
       if (trayId) {
         const errorSpan = trayInput.parentElement.querySelector('.rejection-tray-error');
         const hasError = errorSpan && 
                          errorSpan.style.display === 'block' && 
                          (errorSpan.textContent.includes('❌') || errorSpan.style.color === '#721c24');
         
         if (!hasError) {
           const individualTrayQty = parseInt(trayInput.getAttribute('data-tray-qty')) || 0;
           
           validTrayAllocations.push({
             tray_id: trayId,
             tray_qty: individualTrayQty,
             is_new_tray: isNewTrayId(trayId)  // ✅ Track if it's a NEW tray
           });
           validTrayCount++;
           console.log(`   ✅ Valid tray ${index + 1}: "${trayId}" (qty: ${individualTrayQty}, new: ${isNewTrayId(trayId)})`);
         } else {
           console.log(`   ❌ Invalid tray ${index + 1}: "${trayId}" (has error)`);
         }
       } else {
         console.log(`   ⭕ Empty tray ${index + 1}`);
       }
     });
     
     if (validTrayCount > 0) {
       validTrayAllocations.forEach(trayAllocation => {
         const allocation = {
           reason_id: reasonId,
           reason_text: reasonText,
           qty: trayAllocation.tray_qty,
           tray_count: 1,
           tray_ids: [trayAllocation.tray_id],
           is_new_tray: trayAllocation.is_new_tray  // ✅ Include NEW tray flag
         };
         
         allocations.push(allocation);
         console.log(`   ✅ Added individual tray allocation:`, allocation);
       });
     } else {
       console.log(`   ⚠️ No valid trays for reason ${reasonId}, skipping allocation`);
     }
   }
   });
   
   console.log('📊 [NEW Tray Aware Collection] FINAL allocations:', allocations);
   return allocations;
   }
               
   // ✅ NEW: Helper function to identify NEW tray IDs (frontend version)
   function isNewTrayId(trayId) {
   // Always return false; let backend decide if a tray is "new"
   return false;
   }
   
   
   // Place this after your existing .rejection-qty-input logic
       document.querySelectorAll('.rejection-qty-input').forEach(function(qtyInput) {
         qtyInput.addEventListener('input', function() {
           const row = qtyInput.closest('tr');
           const trayInput = row.querySelector('.rejection-tray-id-input');
           if (parseInt(qtyInput.value) > 0) {
             trayInput.disabled = false;
             trayInput.required = true;
           } else {
             trayInput.value = '';
             trayInput.disabled = true;
             trayInput.required = false;
           }
         });
         // Optionally, trigger once on page load to set initial state
         qtyInput.dispatchEvent(new Event('input'));
       });
   // Batch rejection checkbox event listener
        // ✅ UPDATED: Batch rejection checkbox event listener with remarks field
       // ✅ FIXED: Batch rejection checkbox event listener
   const batchRejectionCheckbox = document.getElementById("batchRejection");
   const rejectionTableBody = document.getElementById("rejection-table-body");
   const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");
   const lotRejectionRemarksInput = document.getElementById("lotRejectionRemarksInput");
   const remarksCharCount = document.getElementById("remarksCharCount");
   
   if (batchRejectionCheckbox && rejectionTableBody) {
   batchRejectionCheckbox.addEventListener("change", function () {
   // ✅ FIXED: Target both quantity inputs and tray ID inputs specifically
   const qtyInputs = rejectionTableBody.querySelectorAll(".rejection-qty-input");
   const trayIdInputs = document.querySelectorAll(".rejection-tray-id-input");
   
   if (this.checked) {
     // ✅ Show remarks section when Lot Rejection is checked
     if (lotRejectionRemarksSection) {
       lotRejectionRemarksSection.style.display = "block";
       // Add smooth animation
       lotRejectionRemarksSection.style.opacity = "0";
       lotRejectionRemarksSection.style.transform = "translateY(-10px)";
       setTimeout(() => {
         lotRejectionRemarksSection.style.transition = "all 0.3s ease";
         lotRejectionRemarksSection.style.opacity = "1";
         lotRejectionRemarksSection.style.transform = "translateY(0)";
       }, 50);
       
       // Focus on remarks input
       if (lotRejectionRemarksInput) {
         setTimeout(() => {
           lotRejectionRemarksInput.focus();
         }, 300);
       }
     }
     
     // ✅ FIXED: Disable quantity inputs
     qtyInputs.forEach(input => {
       input.disabled = true;
       input.value = ""; // Clear values
     });
     
     // ✅ FIXED: Disable and clear tray ID inputs
     trayIdInputs.forEach(input => {
       input.disabled = true;
       input.value = "";
       // Clear any error messages
       const errorSpan = input.parentElement.querySelector('.rejection-tray-error');
       if (errorSpan) {
         errorSpan.style.display = 'none';
         errorSpan.textContent = '';
       }
     });
     
     // ✅ FIXED: Hide tray ID containers completely
     document.querySelectorAll('.tray-id-container').forEach(container => {
       container.style.display = 'none';
     });
     
     // ✅ FIXED: Update all tray cells to show "N/A" message
     document.querySelectorAll('#rejection-table-body tr').forEach(row => {
       const trayCell = row.querySelector('td:last-child');
       if (trayCell && !trayCell.textContent.includes('Total Qty')) {
         trayCell.innerHTML = '<span style="color: #666; font-style: italic;">N/A (Lot Rejection)</span>';
       }
     });
     
     document.getElementById('rejection-total-qty').textContent = "0";
     
   } else {
     // ✅ FIXED: Hide remarks section when Lot Rejection is unchecked
     if (lotRejectionRemarksSection) {
       lotRejectionRemarksSection.style.transition = "all 0.3s ease";
       lotRejectionRemarksSection.style.opacity = "0";
       lotRejectionRemarksSection.style.transform = "translateY(-10px)";
       setTimeout(() => {
         lotRejectionRemarksSection.style.display = "none";
       }, 300);
     }
     
     // Clear remarks input
     if (lotRejectionRemarksInput) {
       lotRejectionRemarksInput.value = "";
       if (typeof updateCharCount === 'function') {
         updateCharCount();
       }
     }
     
     // ✅ FIXED: Re-enable quantity inputs
     qtyInputs.forEach(input => {
       input.disabled = false;
     });
     
     // ✅ FIXED: Re-enable existing tray ID inputs
     trayIdInputs.forEach(input => {
       input.disabled = false;
     });
     
     // ✅ FIXED: Show tray ID containers again
     document.querySelectorAll('.tray-id-container').forEach(container => {
       container.style.display = 'flex';
     });
     
     // ✅ FIXED: Restore proper tray cell content based on current quantities
     document.querySelectorAll('#rejection-table-body tr').forEach(row => {
       const qtyInput = row.querySelector('.rejection-qty-input');
       const trayCell = row.querySelector('td:last-child');
       
       if (qtyInput && trayCell && !trayCell.textContent.includes('Total Qty')) {
         const currentQty = parseInt(qtyInput.value) || 0;
         if (currentQty > 0) {
           // Regenerate tray ID inputs for this row
           generateDynamicTrayIdInputs(row, currentQty, trayCell);
         } else {
           // Show default message for empty quantities
           trayCell.innerHTML = '<span style="color: #999; font-style: italic;">Enter quantity first</span>';
         }
       }
     });
   }
   });
   }
       // ✅ NEW: Character count functionality for remarks
       if (lotRejectionRemarksInput && remarksCharCount) {
         function updateCharCount() {
           const currentLength = lotRejectionRemarksInput.value.length;
           remarksCharCount.textContent = currentLength;
   
             remarksCharCount.style.color = "#6c757d"; // Default gray
         
         }
         
         lotRejectionRemarksInput.addEventListener("input", updateCharCount);
         
         // Initialize character count
         updateCharCount();
       }
   
       // ✅ UPDATED: Button event listeners based on mode
       if (isDraftMode) {
         // Update Draft button (renamed to "Draft")
         const updateDraftBtn = document.getElementById("updateDraftButton");
         if (updateDraftBtn) {
           updateDraftBtn.addEventListener("click", () => handleUpdateDraft(stockLotId, batchId));
         }
       } else {
         // Regular Draft button
         const draftBtn = document.getElementById("draftButton");
         if (draftBtn) {
           draftBtn.addEventListener("click", () => handleSaveDraft(stockLotId, batchId));
         }
       }
   
       // Proceed button (works for both modes)
       const proceedBtn = document.getElementById("proceedButton");
       if (proceedBtn) {
         proceedBtn.addEventListener("click", () => handleProceed(stockLotId, batchId, isDraftMode));
       }
   
       // Cancel button
       const cancelBtn = document.getElementById("cancelButton");
      if (cancelBtn) {
   cancelBtn.addEventListener("click", () => {
   document.getElementById("trayScanModal").classList.remove("open");
   
   // ✅ NEW: Also close trayScanModal if it's open
   const trayScanModal = document.getElementById("trayScanModal");
   if (trayScanModal && trayScanModal.classList.contains("open")) {
     trayScanModal.classList.remove("open");
     trayScanModal.style.display = "none";
   }
   
   // Add a slight delay then refresh table data only
   setTimeout(() => {
     location.reload();
   }, 300);
   });
   }
     }
   
     // ✅ NEW: Handle save draft
     function handleSaveDraft(stockLotId, batchId) {
       const draftData = collectFormData(stockLotId, batchId);
       
       if (!validateDraftData(draftData)) {
         return;
       }
       
       // Add ip_onhold_picking flag for draft
       draftData.ip_onhold_picking = true;
       
       fetch('/recovery_is/rec_save_rejection_draft/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': getCookie('csrftoken')
         },
         body: JSON.stringify(draftData)
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           showSuccessMessage('Draft saved successfully!', '#007bff');
           // Close modal and refresh 
           setTimeout(() => {
             document.getElementById("trayScanModal").classList.remove("open");
             window.location.reload();
   
           }, 1500);
         } else {
           showErrorMessage(data.error || 'Failed to save draft');
         }
       })
       .catch(error => {
         showErrorMessage('Network error occurred');
       });
     }
   
     // ✅ NEW: Handle update draft
     function handleUpdateDraft(stockLotId, batchId) {
       const draftData = collectFormData(stockLotId, batchId);
       
       if (!validateDraftData(draftData)) {
         return;
       }
       
       // Add ip_onhold_picking flag for draft
       draftData.ip_onhold_picking = true;
       
       fetch('/recovery_is/rec_save_rejection_draft/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': getCookie('csrftoken')
         },
         body: JSON.stringify(draftData)
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           showSuccessMessage('Draft updated successfully!', '#f39c12');
           setTimeout(() => {
             document.getElementById("trayScanModal").classList.remove("open");
             window.location.reload(); // <-- Only refresh table, not the whole page
           }, 1500);
           currentDraftData = draftData;
         } else {
           showErrorMessage(data.error || 'Failed to update draft');
         }
       })
       .catch(error => {
         showErrorMessage('Network error occurred');
       });
     }
   
     // ✅ UPDATED: Handle proceed (works for both regular and draft mode)
     function handleProceed(stockLotId, batchId, isDraftMode) {
       const formData = collectFormData(stockLotId, batchId);
   
           
       // Validate form data for final submission
       if (!validateFormDataForProceed(formData)) {
         return;
       }
   
       // If in draft mode, delete draft first, then proceed with normal flow
       if (isDraftMode) {
         fetch('/recovery_is/rec_delete_rejection_draft/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({ lot_id: stockLotId })
         })
         .then(() => {
           // Proceed with normal rejection flow
           proceedWithRejection(formData, stockLotId, batchId);
         })
         .catch(error => {
           // Still proceed with rejection even if draft deletion fails
           proceedWithRejection(formData, stockLotId, batchId);
         });
       } else {
         // Normal flow
         proceedWithRejection(formData, stockLotId, batchId);
       }
     }
   
   // Update the collectFormData function to include remarks
   
   // ✅ FIXED: Update collectFormData to properly collect all data
   
   function collectFormData(stockLotId, batchId) {
   const rejection_data = [];
   const tray_scans = [];
   const is_batch_rejection = document.getElementById("batchRejection").checked;
   
   // ✅ UPDATED: Always collect lot rejection remarks if batch rejection is checked
   let lot_rejection_remarks = "";
   if (is_batch_rejection) {
   const remarksInput = document.getElementById("lotRejectionRemarksInput");
   lot_rejection_remarks = remarksInput ? remarksInput.value.trim() : "";
   console.log("📝 Collected lot rejection remarks:", lot_rejection_remarks);
   }
   
   console.log("🔄 [collectFormData] Starting data collection...");
   console.log("📋 is_batch_rejection:", is_batch_rejection);
   
   // Only collect rejection data if NOT batch rejection
   if (!is_batch_rejection) {
   document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
     const qty = parseInt(qtyInput.value) || 0;
     const reasonId = qtyInput.getAttribute('data-reason-id');
     
     if (qty > 0) {
       const row = qtyInput.closest('tr');
       const reasonCell = row.cells[2];
       const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
       
       console.log(`📋 Processing reason ${reasonId} (${reasonText}): qty=${qty}`);
       
       // Add to rejection_data
       rejection_data.push({
         reason_id: reasonId,
         qty: qty,
         reason_text: reasonText
       });
       
       // ✅ FIXED: Collect tray scans for non-SHORTAGE reasons
       if (reasonText.toUpperCase() !== 'SHORTAGE') {
         const trayIdCell = row.querySelector('td:last-child');
         const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
         
         console.log(`   Found ${trayInputs.length} tray inputs for reason ${reasonId}`);
         
         trayInputs.forEach((trayInput, index) => {
           const trayId = trayInput.value.trim();
           if (trayId) {
             const individualTrayQty = parseInt(trayInput.getAttribute('data-tray-qty')) || 0;
             
             const trayData = {
               reason_id: reasonId,
               tray_id: trayId,
               tray_qty: individualTrayQty,
               reason_text: reasonText
             };
             
             tray_scans.push(trayData);
             console.log(`   ✅ Added tray scan:`, trayData);
           } else {
             console.log(`   ⭕ Empty tray input ${index + 1}`);
           }
         });
       } else {
         console.log(`   ⏭️ Skipping tray scans for SHORTAGE reason`);
       }
     }
   });
   }
   
   const result = {
   lot_id: stockLotId,
   batch_id: batchId,
   rejection_data: rejection_data,
   tray_scans: tray_scans,
   is_batch_rejection: is_batch_rejection,
   lot_rejection_remarks: lot_rejection_remarks,
   total_rejection_qty: rejection_data.reduce((sum, item) => sum + item.qty, 0)
   };
   
   console.log("📤 [collectFormData] Final result:");
   console.log("   - rejection_data:", result.rejection_data);
    console.log("   - is_batch_rejection:", result.is_batch_rejection);
    console.log("   - lot_rejection_remarks:", result.lot_rejection_remarks);
   console.log("   - tray_scans:", result.tray_scans);
   console.log("   - total_rejection_qty:", result.total_rejection_qty);
   
   return result;
   }
   
     // Update validation functions to include remarks validation
     
     // ✅ FIXED: Update the validateDraftData function to properly recognize tray scans
     
     function validateDraftData(formData) {
       console.log('🔍 [validateDraftData] Validating form data:', formData);
       
       if (formData.is_batch_rejection) {
         const remarksInput = document.getElementById("lotRejectionRemarksInput");
         const remarks = remarksInput ? remarksInput.value.trim() : "";
         
         // ✅ FIXED: For draft, only require remarks to be present (not minimum length)
         if (!remarks) {
           showErrorMessage('Please enter some remarks before saving as draft.');
           if (remarksInput) {
             remarksInput.focus();
             remarksInput.style.borderColor = "#dc3545";
             remarksInput.style.boxShadow = "0 0 0 0.2rem rgba(220, 53, 69, 0.25)";
           }
           return false;
         }
         
         console.log("✅ Lot rejection draft with remarks - validation passed");
         return true;
       }
     
       // ✅ FIXED: Check for rejection data OR tray scans (not AND)
       const hasRejectionData = formData.rejection_data && formData.rejection_data.length > 0;
       const hasTrayScans = formData.tray_scans && formData.tray_scans.length > 0;
       
       console.log('🔍 [validateDraftData] Data check:');
       console.log('   - hasRejectionData:', hasRejectionData);
       console.log('   - hasTrayScans:', hasTrayScans);
       console.log('   - rejection_data:', formData.rejection_data);
       console.log('   - tray_scans:', formData.tray_scans);
       
       // ✅ FIXED: Allow draft save if we have EITHER rejection quantities OR tray scans
       if (!hasRejectionData && !hasTrayScans) {
         showErrorMessage('Please enter at least some rejection data before saving as draft.');
         return false;
       }
     
       console.log("✅ Draft validation passed");
       return true;
     }
   
   
   // ✅ SIMPLIFIED: Update validation logic to use new calculation
   function validateFormDataForProceed(formData) {
   
   if (formData.is_batch_rejection) {
   // ✅ Validate lot rejection remarks
   const remarksInput = document.getElementById("lotRejectionRemarksInput");
   const remarks = remarksInput ? remarksInput.value.trim() : "";
   
   if (!remarks) {
     showErrorMessage('Lot rejection remarks are required when rejecting the entire lot.');
     if (remarksInput) {
       remarksInput.focus();
       remarksInput.style.borderColor = "#dc3545";
       remarksInput.style.boxShadow = "0 0 0 0.2rem rgba(220, 53, 69, 0.25)";
     }
     return false;
   }
   
   
   console.log("✅ Lot rejection with valid remarks - validation passed");
   return true;
   }
   
   if (formData.rejection_data.length === 0) {
   showErrorMessage('Please enter at least one rejection quantity.');
   return false;
   }
   
   // Check if ALL rejections are SHORTAGE
   const isAllShortage = formData.rejection_data.every(item => {
   const reasonElement = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
   if (reasonElement) {
     const reasonCell = reasonElement.closest('tr').cells[2];
     const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
     return reasonText === 'SHORTAGE';
   }
   return false;
   });
   
   if (isAllShortage) {
   console.log("✅ All SHORTAGE rejections - no tray scans required");
   return true;
   }
   
   // ✅ SIMPLIFIED: Validate tray scanning requirements
   let validationErrors = [];
   
   // Get tray capacity
   const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                    document.querySelector('[data-stock-lot-id]') ||
                    document.querySelector('tbody tr');
   let trayCapacity = 12; // Default
   if (currentRow) {
   const trayCapacityText = currentRow.cells[7]?.textContent || '';
   if (trayCapacityText.includes('-')) {
     trayCapacity = parseInt(trayCapacityText.split('-')[1]) || 12;
   }
   }
   
   console.log(`🔧 Using tray capacity: ${trayCapacity} for validation`);
   
   formData.rejection_data.forEach(item => {
   const reasonElement = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
   if (!reasonElement) return;
   
   const reasonCell = reasonElement.closest('tr').cells[2];
   const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
   
   if (reasonText !== 'SHORTAGE') {
     const row = reasonElement.closest('tr');
     const trayIdCell = row.querySelector('td:last-child');
     const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
     
     // ✅ SIMPLIFIED: Calculate expected number of trays
     const expectedTrays = Math.ceil(item.qty / trayCapacity);
     
     console.log(`🔍 Validating ${reasonText}: qty=${item.qty}, expectedTrays=${expectedTrays}, foundInputs=${trayInputs.length}`);
     
     // Check if we have the right number of inputs
     if (trayInputs.length !== expectedTrays) {
       validationErrors.push(`${reasonText}: Expected ${expectedTrays} tray input(s), found ${trayInputs.length}`);
     }
     
     // Check if all inputs are filled
     let missingTrayIds = 0;
     trayInputs.forEach((trayInput, index) => {
       const trayId = trayInput.value.trim();
       if (!trayId) {
         missingTrayIds++;
       }
     });
     
     if (missingTrayIds > 0) {
       validationErrors.push(`${reasonText}: Missing ${missingTrayIds} tray ID(s)`);
     }
   }
   });
   
   if (validationErrors.length > 0) {
   showErrorMessage(`Validation errors:\n• ${validationErrors.join('\n• ')}`);
   console.log("❌ Validation errors:", validationErrors);
   return false;
   }
   
   console.log("✅ Validation passed");
   return true;
   }
   
   
   
   // ✅ UPDATED: Enhanced error message display
   function showErrorMessage(message) {
   const msgDiv = document.getElementById("batchRejectionMsg");
   if (msgDiv) {
   msgDiv.style.color = "#d32f2f";
   msgDiv.style.backgroundColor = "#ffebee";
   msgDiv.style.border = "1px solid #f44336";
   msgDiv.style.padding = "8px 12px";
   msgDiv.style.borderRadius = "4px";
   msgDiv.style.marginTop = "10px";
   msgDiv.textContent = message;
   
   // Auto-hide after 8 seconds
   setTimeout(() => {
     msgDiv.textContent = "";
     msgDiv.style.backgroundColor = "";
     msgDiv.style.border = "";
     msgDiv.style.padding = "";
      }, 8000);
   }
   
   // Also log to console
   console.log("❌ Error:", message);
   }
   
   
   
     // ✅ NEW: Proceed with actual rejection (existing logic)
     function proceedWithRejection(formData, stockLotId, batchId) {
       if (formData.is_batch_rejection) {
         // Handle batch rejection
         handleBatchRejection(batchId, stockLotId);
       } else {
         // Handle tray-wise rejection  
         handleTrayWiseRejectionWithFormData(batchId, stockLotId, formData);
       }
     }
   
     // ✅ UPDATED: Handle tray-wise rejection with form data
   function handleTrayWiseRejectionWithFormData(batchId, stockLotId, formData) {
   const msgDiv = document.getElementById("batchRejectionMsg");
   const proceedButton = document.getElementById("proceedButton");
   
   if (proceedButton) proceedButton.disabled = true;
   
   // ✅ FIXED: Use formData.tray_scans directly instead of recreating tray_rejections
   console.log('Using tray_scans from formData:', formData.tray_scans);
   console.log('Using rejection_data from formData:', formData.rejection_data);
   
   // Send to server with correct parameter names
   fetch('/recovery_is/rec_tray_rejection/', {
   method: 'POST',
   headers: {
     'Content-Type': 'application/json',
     'X-CSRFToken': getCookie('csrftoken')
   },
   body: JSON.stringify({
     lot_id: stockLotId,
     batch_id: batchId,
     tray_scans: formData.tray_scans,      // ✅ Use collected tray_scans
     rejection_data: formData.rejection_data // ✅ Use collected rejection_data
   })
   })
   .then(res => res.json())
   .then(data => {
   if (data.success) {
     // Disable all inputs
     document.querySelectorAll('.rejection-qty-input, .rejection-tray-id-input').forEach(input => {
       input.disabled = true;
     });
     
     window.trayRejectionSaved = true;
     
     if (msgDiv) {
       msgDiv.style.color = "#388e3c";
       msgDiv.textContent = "Rejected Tray saved!";
     }

     // Disable Draft and Proceed buttons after success
    const draftBtn = document.getElementById("draftButton");
    const proceedBtn = document.getElementById("proceedButton");
    if (draftBtn) {
      draftBtn.disabled = true;
      draftBtn.style.opacity = "0.6";
      draftBtn.style.cursor = "not-allowed";
    }
    if (proceedBtn) {
      proceedBtn.disabled = true;
      proceedBtn.style.opacity = "0.6";
      proceedBtn.style.cursor = "not-allowed";
    }
   
     // Update main table row
     const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
     if (mainTableRow) {
       // Update Lot Status cell
       const lotStatusCell = mainTableRow.querySelector('td:nth-child(17)');
       if (lotStatusCell) {
         lotStatusCell.innerHTML = `
           <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
             style="border: 2px solid #4997ac; background-color: #d1f2f3; color: #03425d;
             font-size: clamp(0.75rem, 2vw, 0.875rem); white-space: nowrap;
             padding-top: 0.5rem; padding-bottom: 0.5rem;">
             Draft
           </div>
         `;
       }
   
       // Disable Accept button
       const acceptBtn = mainTableRow.querySelector('.btn-twitter');
       if (acceptBtn) {
         acceptBtn.disabled = true;
         acceptBtn.style.pointerEvents = 'none';
         acceptBtn.style.opacity = '0.6';
         acceptBtn.style.cursor = 'not-allowed';
         acceptBtn.innerHTML = `<i class="fa fa-check-circle"></i>Accept`;
         acceptBtn.classList.add('disabled');
       }
     
       // Enable Top Tray Scan button
       const partialRejectBtn = mainTableRow.querySelector('.btn-youtube.tray-scan-btn');
       if (partialRejectBtn) {
         partialRejectBtn.disabled = false;
         partialRejectBtn.style.pointerEvents = 'auto';
         partialRejectBtn.style.opacity = '1';
         partialRejectBtn.style.cursor = 'pointer';
         partialRejectBtn.innerHTML = `<i class="fa fa-times-circle"></i>Set Top Tray`;
         partialRejectBtn.style.backgroundColor = '#e57373';
         partialRejectBtn.classList.remove('disabled');
       }
     
       // Set Process Status "S" icon to half-filled
       const processIcons = mainTableRow.querySelectorAll('.d-flex > div');
       if (processIcons.length > 1) {
         processIcons[1].style.background = 'linear-gradient(to right, #0c8249 50%, #bdbdbd 50%)';
       }
   
       // Update quantities if provided in response
       if (data.lot_qty !== undefined) {
         const lotQtySpan = mainTableRow.querySelector('td:nth-child(11) .lot-qty');
         if (lotQtySpan) {
           lotQtySpan.textContent = data.lot_qty;
           lotQtySpan.style.backgroundColor = '#fff3cd';
           lotQtySpan.style.borderRadius = '4px';
           setTimeout(() => { lotQtySpan.style.backgroundColor = ''; }, 1200);
         }
       }
       
       if (data.physical_qty !== undefined) {
         const physicalQtyInput = mainTableRow.querySelector('td:nth-child(12) .physical-qty-input');
         if (physicalQtyInput) {
           physicalQtyInput.value = data.physical_qty;
           physicalQtyInput.style.backgroundColor = '#fff3cd';
           physicalQtyInput.style.borderColor = '#ffc107';
           setTimeout(() => { 
             physicalQtyInput.style.backgroundColor = ''; 
             physicalQtyInput.style.borderColor = ''; 
           }, 1200);
         }
       }
     }
     
     // Continue with accepted tray modal
     fetch(`/recovery_is/rec_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
       .then(res => res.json())
       .then(rescanData => {
         if (rescanData.success) {
           showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
         }
       })
       .catch(error => {
         console.error('Error fetching accepted tray data:', error);
       });
       
   } else {
     if (msgDiv) {
       msgDiv.style.color = "#d32f2f";
       msgDiv.textContent = data.error || "Failed to save tray rejection";
     }
     if (proceedButton) proceedButton.disabled = false;
   }
   })
   .catch(() => {
   if (msgDiv) {
     msgDiv.style.color = "#d32f2f";
     msgDiv.textContent = "Network error";
   }
   if (proceedButton) proceedButton.disabled = false;
   });
   }
     // ✅ NEW: Utility functions
     function showSuccessMessage(message, color = '#28a745') {
       const msgDiv = document.getElementById("batchRejectionMsg");
       if (msgDiv) {
         msgDiv.style.color = color;
         msgDiv.textContent = message;
         setTimeout(() => {
           msgDiv.textContent = "";
         }, 3000);
       }
     }
   
     function showErrorMessage(message) {
       const msgDiv = document.getElementById("batchRejectionMsg");
       if (msgDiv) {
         msgDiv.style.color = "#d32f2f";
         msgDiv.textContent = message;
         setTimeout(() => {
           msgDiv.textContent = "";
         }, 5000);
       }
     }
   
   
     
     // Helper function to get current lot ID
     function getCurrentLotId() {
       const modal = document.getElementById("trayScanModal");
       return modal?.dataset?.stockLotId || '';
     }
   
   // ✅ ENHANCED: Update rejection scan counter with quantity tracking
   function updateRejectionScanCounter() {
   const counter = document.getElementById('rejectionScanCounter');
   const status = document.getElementById('rejectionScanStatus');
   const progressBar = document.querySelector('#rejectionScanProgress > div');
   const distributionInfo = document.getElementById('trayDistributionInfo');
   const distributionDetails = document.getElementById('trayDistributionDetails');
   
   if (!counter) return;
   
   let totalRequiredScans = 0;
   let completedScans = 0;
   let distributionHTML = '';
   let shortageOnly = [];
   
   // Get current session allocations for better tracking
   const currentAllocations = collectCurrentSessionAllocations(null);
   
   console.log('🔄 [Counter Update] Current allocations:', currentAllocations);
   
   // Calculate total required scans and completed scans
   document.querySelectorAll('.rejection-qty-input').forEach(input => {
   const qty = parseInt(input.value) || 0;
   const row = input.closest('tr');
   const reasonCell = row.cells[2];
   const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
   const reasonId = input.getAttribute('data-reason-id');
   
   if (qty > 0 && reasonText !== 'SHORTAGE') {
     const trayIdCell = row.querySelector('td:last-child');
     const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
     
     // Calculate expected trays for this quantity
     const trayCapacity = getCurrentTrayCapacity();
     const expectedTrays = Math.ceil(qty / trayCapacity);
     totalRequiredScans += expectedTrays;
     
     // Find matching allocation for accurate count
     const matchingAllocation = currentAllocations.find(alloc => alloc.reason_id === reasonId);
     const actualCompletedTrays = matchingAllocation ? matchingAllocation.tray_count : 0;
     
     completedScans += actualCompletedTrays;
     
     // Enhanced distribution info
     let status = '';
     if (actualCompletedTrays === 0) {
       status = '⏳ Pending';
     } else if (actualCompletedTrays < expectedTrays) {
       status = `🔄 ${actualCompletedTrays}/${expectedTrays}`;
     } else {
       status = '✅ Complete';
     }
     
     distributionHTML += `
       <div style="margin-bottom: 4px; padding: 6px; border-radius: 4px; ${actualCompletedTrays === expectedTrays ? 'background-color: #d4edda;' : actualCompletedTrays > 0 ? 'background-color: #fff3cd;' : 'background-color: #f8d7da;'}">
         <span style="font-weight: 600; color: #007bff;">${reasonText}:</span>
         <span>Qty ${qty} → ${expectedTrays} tray${expectedTrays > 1 ? 's' : ''} ${status}</span>
       </div>
     `;
   } else if (qty > 0 && reasonText === 'SHORTAGE') {
     shortageOnly.push(`${reasonText}: ${qty}`);
   }
   });
   
   // Update distribution info
   if (distributionHTML) {
   distributionDetails.innerHTML = distributionHTML;
   distributionInfo.style.display = 'block';
   } else {
   distributionInfo.style.display = 'none';
   }
   
   // Update counter with enhanced information
   if (counter) {
   counter.textContent = `${completedScans}/${totalRequiredScans}`;
   
   // Enhanced color coding
   if (completedScans === totalRequiredScans && totalRequiredScans > 0) {
     counter.style.color = '#28a745'; // Green when complete
     counter.style.backgroundColor = '#d4edda';
   } else if (completedScans > 0) {
     counter.style.color = '#ffc107'; // Yellow when in progress  
     counter.style.backgroundColor = '#fff3cd';
   } else {
     counter.style.color = '#dc3545'; // Red when not started
     counter.style.backgroundColor = '#f8d7da';
   }
   
   counter.style.padding = '4px 8px';
   counter.style.borderRadius = '12px';
   counter.style.fontWeight = 'bold';
   }
   
   console.log(`🔄 [Counter Update] Total: ${completedScans}/${totalRequiredScans}`);
   }
   
   // ✅ REMOVE: Delete the old calculateCompleteTraysFromActualDistribution function
   // This function is no longer needed with the simplified logic
   
   console.log("✅ Simplified tray logic loaded - now supports:");
   console.log("   • Qty 1-12 (with capacity 12): 1 tray");
   console.log("   • Qty 13-24 (with capacity 12): 2 trays");
   console.log("   • Qty 25-36 (with capacity 12): 3 trays");
   console.log("   • etc.");
   
   // ✅ NEW: Initialize enhanced counter
   document.addEventListener('DOMContentLoaded', function() {
   updateRejectionScanCounter();
   });
   
   
   // ✅ HELPER: Get current tray capacity
   function getCurrentTrayCapacity() {
   const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                    document.querySelector('[data-stock-lot-id]') ||
                    document.querySelector('tbody tr');
   
   if (currentRow) {
   const trayCapacityText = currentRow.cells[7]?.textContent || '';
   if (trayCapacityText.includes('-')) {
     return parseInt(trayCapacityText.split('-')[1]) || 12;
   }
   }
   
   return 12; // Default capacity
   }
   
     // ✅ EXISTING: Handle batch rejection (unchanged)
     function handleBatchRejection(batchId, stockLotId) {
       const msgDiv = document.getElementById("batchRejectionMsg");
       const proceedButton = document.getElementById("proceedButton");
       const totalQty = document.getElementById('rejection-total-qty').textContent || "0";

       if (!batchId || !stockLotId) {
         if (msgDiv) msgDiv.textContent = "Batch ID or Lot ID not found.";
         if (proceedButton) proceedButton.disabled = false;
         return;
       }
       
       fetch('/recovery_is/rec_batch_rejection/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': getCookie('csrftoken')
         },
         body: JSON.stringify({
           batch_id: batchId,
           lot_id: stockLotId,
           total_qty: totalQty,
           lot_rejection_remarks: document.getElementById('lotRejectionRemarksInput')?.value?.trim() || ""


           
         })
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           if (msgDiv) {
             msgDiv.style.color = "#388e3c";
             msgDiv.textContent = "Lot rejection saved!";
           }
           updateUIForBatchRejection(batchId);
           setTimeout(() => {
             trayModal.classList.remove("open");
             if (msgDiv) msgDiv.textContent = "";
             window.location.reload();
           }, 1200);
         } else {
           if (msgDiv) {
             msgDiv.style.color = "#d32f2f";
             msgDiv.textContent = data.error || "Failed to save batch rejection";
           }
           if (proceedButton) proceedButton.disabled = false;
         }
       })
       .catch(() => {
         if (msgDiv) {
           msgDiv.style.color = "#d32f2f";
           msgDiv.textContent = "Network error";
         }
         if (proceedButton) proceedButton.disabled = false;
       });
     }
   
     // ✅ NEW: Add redo functionality for rejection tray scan
     document.addEventListener('click', function(e) {
       if (e.target.id === 'rejectionTrayRedoBtn') {
         document.querySelectorAll('.rejection-tray-id-input').forEach(function(input) {
           input.value = '';
           const errorSpan = input.parentElement.querySelector('.rejection-tray-error');
           if (errorSpan) {
             errorSpan.style.display = 'none';
             errorSpan.textContent = '';
           }
         });
         updateRejectionScanCounter();
       }
     });
   
   
   
     // Function to fetch and show normal accepted tray data
     function fetchAndShowAcceptedTrayData(lotId) {
       fetch(`/recovery_is/rec_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
         .then(res => res.json())
         .then(rescanData => {
           if (rescanData.success) {
             showAcceptedTrayModal(rescanData, lotId, false);
           }
         })
         .catch(error => {
         });
     }
   
     // Function to show read-only accepted tray data (for draft mode)
     function showReadOnlyAcceptedTrayData(lotId, detailsDiv) {
       fetch(`/recovery_is/rec_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
         .then(res => res.json())
         .then(data => {
           if (data.success && data.has_draft) {
             showAcceptedTrayModal(data, lotId, true);
           } else {
             // No draft exists, proceed with normal flow
             fetchAndShowAcceptedTrayData(lotId);
           }
         })
         .catch(error => {
           // Fallback to normal flow
           fetchAndShowAcceptedTrayData(lotId);
         });
     }
   
   // ✅ FIXED: Function to check if a tray ID is a placeholder
   function isPlaceholderTrayId(trayId) {
   return trayId && trayId.startsWith('DELINK_ONLY_');
   }
   
function showAcceptedTrayModal(rescanData, lotId, isDraft) {
  console.log('🔍 [showAcceptedTrayModal] === STARTING ===');
  console.log('🔍 Input rescanData:', rescanData);
  console.log('🔍 Input lotId:', lotId);
  console.log('🔍 Input isDraft:', isDraft);
  console.log('🔍 rescanData.has_draft:', rescanData.has_draft);
  console.log('🔍 rescanData.delink_trays:', rescanData.delink_trays);

  // ✅ Get model_no from the current row's data-model-no attribute
  const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
  let modelNo = '';
  
  if (currentRow) {
    modelNo = currentRow.getAttribute('data-model-no') || '';
    console.log('✅ Got model_no from row:', modelNo);
  } else {
    // Fallback to backend data if row not found
    modelNo = rescanData.model_no || 'N/A';
    console.log('⚠️ Fallback to backend model_no:', modelNo);
  }
  
  let topTrayQty = rescanData.top_tray_qty; // ✅ Get from backend
  let draftTrayId = rescanData.draft_tray_id || ''; // ✅ Get draft data
  
  // ✅ FIXED: Don't show placeholder values to the user
  if (isPlaceholderTrayId(draftTrayId)) {
    draftTrayId = ''; // Show empty input instead of placeholder
    console.log('✅ Hiding placeholder tray ID from user interface');
  }
  
  // ✅ NEW: Draft mode styling and indicators (matching rejection form)
  const draftIndicator = isDraft ? '' : '';
  const draftAlert = isDraft ? `

  ` : '';

  const headerColor = isDraft ? '#f39c12' : '#028084';
  const inputStyle = isDraft ? 'background-color: #fff3cd; border-color: #f39c12; border-width: 2px;' : '';
  
  // ✅ COMPLETE: Full modal HTML
  let html = `
    ${draftAlert}
    <!-- ✅ UPDATED: Compact header section -->
    <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 8px 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid ${isDraft ? '#f39c12' : '#028084'}; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
      <h4 class="mb-0" style="font-size: 18px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px; white-space: nowrap; overflow: hidden;">
        <i class="fa fa-layer-group" style="color: ${headerColor}; font-size: 12px;"></i>
        R-Input Screening / <span style="color: #616161;">${modelNo}</span>${draftIndicator}
      </h4>
      
      <button id="closeAcceptedTrayModal" style="background: none; border: none; font-size: 20px; color: #6c757d; cursor: pointer; padding: 4px; line-height: 1; border-radius: 50%; transition: all 0.3s ease;" title="Close">
        <i class="fa fa-times"></i>
      </button>
    </div>

    <!-- ✅ UPDATED: Delink Section with premium styling -->
    <div id="delinkSection">
      <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 6px 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 6px; border-left: 3px solid #028084; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
        <h5 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px;">
          Delink Trays
        </h5>

        <div style="display: flex; align-items: center; gap: 10px;">
          <img id="delinkTrayRedoBtn"
               src="{% static 'assets/icons/redo2.png' %}"
               alt="Redo"
               style="width: 20px; height: 20px; cursor: pointer; background: none; border: none; box-shadow: none; padding: 0;"
               title="Clear Top Tray ID" />
        </div>
      </div>

      <!-- ✅ REDESIGNED: Compact table styling matching rejection form colors -->
      <div class="table-responsive" style="max-height: 175px !important; border: 1px solid #dee2e6; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); background: #fff; scrollbar-width: none; -ms-overflow-style: none; display: grid; grid-template-columns: 1fr; overflow-y: auto; overscroll-behavior: contain; margin-bottom: 12px;">
        <table class="table table-bordered text-center mb-0" style="font-size: 11px; border-collapse: collapse; border-color: #028084;">
          <thead style="background: linear-gradient(135deg, #028084 0%, #0056b3 100%); position: relative;">
            <tr style="border: 1px solid #282f3a;">
              <th style="background-color: #028084 !important; padding: 8px 6px; font-size: 10px; font-weight: 700; border: 1px solid #282f3a; width: 50px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                S.No
              </th>
              <th style="background-color: #028084 !important; padding: 8px 10px; font-size: 10px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                De-Link Tray ID
              </th>
            </tr>
          </thead>
          <tbody id="delinkTableBody" style="background: #fff;">
            <tr>
              <td colspan="2" style="padding: 20px;">
                <i class="fa fa-spinner fa-spin"></i> Loading delink data...
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- ✅ UPDATED: Compact Top Tray Scan Section with matching colors -->
    <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 6px 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 6px; border-left: 3px solid #028084; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
      <h5 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px;">
        Accepted - Top Tray Scan
      </h5>
      
      <div style="display: flex; align-items: center; gap: 10px;">
        <img id="topTrayRedoBtn"
             src="{% static 'assets/icons/redo2.png' %}"
             alt="Redo"
             style="width: 20px; height: 20px; cursor: pointer; background: none; border: none; box-shadow: none; padding: 0;"
             title="Clear Top Tray ID" />
      </div>
    </div>

    <!-- ✅ UPDATED: Compact input section -->
    <div style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: #ffffff; box-shadow: 0 1px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: end; gap: 15px; width: 100%;">
        <div style="flex: 1; min-width: 0;">
          <label style="font-weight: 700; margin-bottom: 6px; display: block; color: #495057; font-size: 15px; display: flex; align-items: center; gap: 4px;">
            Scan top tray ID:
          </label>
          <input type="text" 
                 id="topTrayIdInput" 
                 placeholder="Scan Tray ID..." 
                 value="${draftTrayId}"
                 style="width: 100%; max-width: 280px; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: all 0.3s ease; background: #fff; ${inputStyle} ${draftTrayId ? 'background-color: #d4edda; border-color: #28a745;' : ''}" 
                 class="top-tray-id-input" 
                 ${(!isDraft && draftTrayId) ? 'readonly' : ''} />
          <div id="topTrayError" style="color: #dc3545; font-size: 11px; margin-top: 4px; display: none; font-weight: 500;"></div>
        </div>
        
        <div style="text-align: center;">
          <label style="font-weight: 700; margin-bottom: 6px; display: block; color: #495057; font-size: 15px;">Tray Qty:</label>
          <input type="number" 
                 value="${topTrayQty}" 
                 readonly 
                 style="width: 70px; padding: 8px 6px; text-align: center; border: 2px solid #ddd; border-radius: 6px; font-weight: 700; font-size: 14px;" />
        </div>
      </div>
    </div>

    <div id="acceptedTrayMsg" style="margin-top: 10px; text-align: center; font-weight: bold;"></div>

    <!-- ✅ ENHANCED: Simple button design as requested by client -->
    <div style="display: flex; justify-content: center; gap: 10px; margin-top: 30px;">
      ${isDraft ? `
        <button id="acceptedTrayUpdateDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
        <button id="acceptedTrayFinalSubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      ` : `
        <button id="acceptedTrayDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
        <button id="acceptedTraySubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      `}
      <button id="acceptedTrayCancelBtn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 30px;">Cancel</button>
    </div>
  `;

  // ✅ SET THE MODAL CONTENT
  const newPopupModal = document.getElementById("newPopupModal");
  document.querySelector("#newPopupModal .tray-scan-modal-content").innerHTML = html;
  newPopupModal.classList.add("open");

  // ✅ ADD: Event listener for the close button with enhanced styling
  const closeBtn = document.getElementById('closeAcceptedTrayModal');
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      document.getElementById("newPopupModal").classList.remove("open");
      // Add this to refresh table data after closing
      setTimeout(() => {
        location.reload();
      }, 300);
    });

    // Add enhanced hover effect
    closeBtn.addEventListener('mouseenter', function() {
      this.style.backgroundColor = '#dc3545';
      this.style.color = '#fff';
      this.style.transform = 'scale(1.1)';
    });

    closeBtn.addEventListener('mouseleave', function() {
      this.style.backgroundColor = 'transparent';
      this.style.color = '#6c757d';
      this.style.transform = 'scale(1)';
    });
  }

  // Add event listeners
  addTopTrayEventListeners(lotId, isDraft, topTrayQty);

  // ✅ NEW: Listen for delink table ready event
  let draftLoadAttempted = false;
  
  const handleDelinkReady = (event) => {
    console.log('✅ [showAcceptedTrayModal] Delink table ready event received:', event.detail);
    
    if (!draftLoadAttempted && event.detail.lotId === lotId) {
      draftLoadAttempted = true;
      
      console.log('✅ [showAcceptedTrayModal] Starting draft loading now that table is ready');
      
      if (rescanData.has_draft) {
        // ✅ Load draft immediately and with retries
        loadDraftDataDirectly(rescanData);
        setTimeout(() => loadDraftDataDirectly(rescanData), 200);
        setTimeout(() => loadDraftDataDirectly(rescanData), 500);
      } else {
        console.log('⏭️ [showAcceptedTrayModal] No draft data to load');
      }
      
      // Remove event listener after use
      document.removeEventListener('delinkTableReady', handleDelinkReady);
    }
  };
  
  // ✅ Add event listener BEFORE loading delink data
  document.addEventListener('delinkTableReady', handleDelinkReady);
  
  // ✅ NOW load delink data - this will trigger the event when ready
  console.log('🔍 [showAcceptedTrayModal] Loading delink data...');
  loadDelinkTrayData(lotId);
  
  // ✅ BACKUP: If event doesn't fire within 3 seconds, try anyway
  setTimeout(() => {
    if (!draftLoadAttempted && rescanData.has_draft) {
      console.log('⚠️ [showAcceptedTrayModal] BACKUP: Event timeout, trying draft load anyway');
      loadDraftDataDirectly(rescanData);
    }
  }, 3000);

    setTimeout(() => {
    const topTrayInput = document.getElementById('topTrayIdInput');
    if (topTrayInput) {
      topTrayInput.focus();
      topTrayInput.select();
    }
  }, 200);

    setTimeout(() => {
    const firstDelinkInput = document.querySelector('.delink-tray-input');
    if (firstDelinkInput) {
      firstDelinkInput.focus();
      firstDelinkInput.select();
    }
  }, 200);

  // ✅ UPDATED: Show initial success message only if we have a real tray ID (not placeholder)
  if (draftTrayId && !isPlaceholderTrayId(rescanData.draft_tray_id)) {
    showAcceptedTrayMessage('✅ Draft data loaded', '#28a745');
  } else if (isDraft && isPlaceholderTrayId(rescanData.draft_tray_id)) {
    showAcceptedTrayMessage('✅ Draft loaded (delink-only)', '#28a745');
  }
}
// ✅ NEW: Direct draft loading function
function loadDraftDataDirectly(rescanData) {
  console.log('🔄 [loadDraftDataDirectly] STARTING DIRECT LOAD...');
  console.log('🔍 [loadDraftDataDirectly] has_draft:', rescanData.has_draft);
  console.log('🔍 [loadDraftDataDirectly] delink_trays:', rescanData.delink_trays);
  
  // 1. Load top tray (this already works)
  const topTrayInput = document.getElementById('topTrayIdInput');
  if (topTrayInput && rescanData.draft_tray_id && !isPlaceholderTrayId(rescanData.draft_tray_id)) {
    const oldTopValue = topTrayInput.value;
    topTrayInput.value = rescanData.draft_tray_id;
    console.log(`✅ [loadDraftDataDirectly] Top tray: "${oldTopValue}" → "${topTrayInput.value}"`);
  } else {
    console.log('⏭️ [loadDraftDataDirectly] No top tray to load');
  }
  
  // 2. Load delink trays - THIS IS THE CRITICAL PART
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  console.log(`🔍 [loadDraftDataDirectly] Found ${delinkInputs.length} delink inputs`);
  
  if (delinkInputs.length === 0) {
    console.log('❌ [loadDraftDataDirectly] NO DELINK INPUTS FOUND - RETRYING...');
    return; // Will retry with next timeout
  }
  
  // Log all current values BEFORE loading
  console.log('🔍 [loadDraftDataDirectly] BEFORE loading:');
  delinkInputs.forEach((input, index) => {
    console.log(`  - Input[${index}]: "${input.value}"`);
  });
  
  // ✅ LOAD DELINK TRAYS
  if (Array.isArray(rescanData.delink_trays) && rescanData.delink_trays.length > 0) {
    console.log(`🔍 [loadDraftDataDirectly] Loading ${rescanData.delink_trays.length} delink trays...`);
    
    rescanData.delink_trays.forEach((tray, arrayIndex) => {
      console.log(`🔍 [loadDraftDataDirectly] Processing tray ${arrayIndex}:`, tray);
      
      const position = tray.position !== undefined ? tray.position : arrayIndex;
      const trayId = tray.tray_id || '';
      const trayQty = tray.tray_qty || 0;
      
      console.log(`  - position: ${position}, tray_id: "${trayId}", tray_qty: ${trayQty}`);
      
      if (position >= 0 && position < delinkInputs.length) {
        const targetInput = delinkInputs[position];
        const oldValue = targetInput.value;
        
        // ✅ SET THE VALUE
        targetInput.value = trayId;
        targetInput.setAttribute('data-expected-qty', trayQty);
        
        // ✅ ADD VISUAL STYLING
        targetInput.style.backgroundColor = '#d4edda';
        targetInput.style.borderColor = '#28a745';
        targetInput.style.color = '#155724';
        targetInput.style.fontWeight = '600';
        
        console.log(`✅ [loadDraftDataDirectly] Input[${position}]: "${oldValue}" → "${targetInput.value}"`);
        
        // ✅ TRIGGER EVENTS
        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
        
      } else {
        console.log(`❌ [loadDraftDataDirectly] Invalid position ${position} (max: ${delinkInputs.length - 1})`);
      }
    });
    
    // Log all values AFTER loading
    console.log('🔍 [loadDraftDataDirectly] AFTER loading:');
    delinkInputs.forEach((input, index) => {
      console.log(`  - Input[${index}]: "${input.value}"`);
    });
    
    console.log('✅ [loadDraftDataDirectly] DRAFT LOADING COMPLETED!');
    
    // ✅ UPDATE COUNTER
    if (typeof updateDelinkScanCounter === 'function') {
      updateDelinkScanCounter();
    }
    
  } else {
    console.log('⏭️ [loadDraftDataDirectly] No delink_trays to load');
  }
}


function loadDelinkTrayData(lotId) {
  console.log('🔍 [loadDelinkTrayData] Called with lotId:', lotId);
  
  const delinkSection = document.getElementById('delinkSection');
  const url = `/recovery_is/rec_get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`;

  fetch(url)
    .then(res => {
      console.log('🔍 [loadDelinkTrayData] Response status:', res.status);
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      return res.json();
    })
    .then(data => {
      console.log('🔍 [loadDelinkTrayData] Response data:', data);

      // Hide or show the delink section based on tray count
      if (delinkSection) {
        if (data.delink_trays && data.delink_trays.length === 0) {
          delinkSection.style.display = 'none';
          console.log('🔍 [loadDelinkTrayData] Hiding delink section - no trays');
        } else {
          delinkSection.style.display = '';
          console.log('🔍 [loadDelinkTrayData] Showing delink section');
        }
      }

      const tableBody = document.getElementById('delinkTableBody');
      if (!tableBody) {
        console.log('❌ [loadDelinkTrayData] delinkTableBody not found');
        return;
      }

      if (data.success && data.delink_trays && data.delink_trays.length > 0) {
        console.log('🔍 [loadDelinkTrayData] Building table for', data.delink_trays.length, 'trays');
        
        tableBody.innerHTML = '';
        data.delink_trays.forEach((tray, index) => {
          console.log(`🔍 [loadDelinkTrayData] Building row ${index} for tray:`, tray);
          
          const row = document.createElement('tr');
          row.style.cssText = 'border-bottom: 1px solid #f1f3f4; transition: all 0.2s ease;';
          row.innerHTML = `
            <td style="padding: 4px; font-size: 11px; font-weight: 600; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #f1f3f4; vertical-align: middle;">${tray.sno}</td>
            <td style="padding: 4px 6px; border-right: 1px solid #f1f3f4; background: #fafbfc; vertical-align: middle;">
              <input type="text" 
                     class="form-control delink-tray-input" 
                     placeholder="Scan Tray ID for Delink" 
                     value=""
                     style="width: 100%; padding: 4px 6px; font-size: 11px; border: 1px solid #ddd; border-radius: 3px; background: #fff; height: 24px;" 
                     data-row="${tray.sno}"
                     data-expected-qty="${tray.tray_quantity}" />
              <span class="delink-tray-error" style="color: #d32f2f; font-size: 10px; margin-left: 2px; display: none;"></span>
            </td>
          `;
          tableBody.appendChild(row);
        });
        
        console.log('✅ [loadDelinkTrayData] Table built successfully');
        
        // Add delink tray validation
        addDelinkTrayValidation(lotId);

        // ✅ CRITICAL: Notify that table is ready
        console.log('✅ [loadDelinkTrayData] DELINK TABLE READY - TRIGGERING DRAFT LOAD');
        
        // ✅ NEW: Dispatch custom event to notify draft loading can start
        const delinkReadyEvent = new CustomEvent('delinkTableReady', {
          detail: { lotId: lotId, inputCount: data.delink_trays.length }
        });
        document.dispatchEvent(delinkReadyEvent);

      } else {
        console.log('🔍 [loadDelinkTrayData] No delink data or empty array');
        
        // ✅ STILL DISPATCH EVENT even if no delink trays
        const delinkReadyEvent = new CustomEvent('delinkTableReady', {
          detail: { lotId: lotId, inputCount: 0 }
        });
        document.dispatchEvent(delinkReadyEvent);
      }

      // Setup redo functionality
      setupDelinkRedoFunctionality();
      
    })
    .catch(error => {
      console.error('❌ [loadDelinkTrayData] Error:', error);
      
      // ✅ DISPATCH EVENT even on error
      const delinkReadyEvent = new CustomEvent('delinkTableReady', {
        detail: { lotId: lotId, inputCount: 0, error: error.message }
      });
      document.dispatchEvent(delinkReadyEvent);
    });
}


// ✅ NEW: Define the missing setupDelinkRedoFunctionality function
     function setupDelinkRedoFunctionality() {
       
       // Remove existing event listener if any
       const existingBtn = document.getElementById('delinkTrayRedoBtn');
       if (existingBtn) {
         existingBtn.removeEventListener('click', existingBtn._clickHandler);
       }
       
       // Add event listener for delink redo button
       const delinkRedoBtn = document.getElementById('delinkTrayRedoBtn');
       if (delinkRedoBtn) {
         const clickHandler = function() {
           
           // Clear all delink tray input values
           document.querySelectorAll('.delink-tray-input').forEach(function(input) {
             input.value = '';
             // Clear any error messages
             const errorSpan = input.parentElement.querySelector('.delink-tray-error');
             if (errorSpan) {
               errorSpan.style.display = 'none';
               errorSpan.textContent = '';
             }
           });
           
           // Update the delink scan counter
           updateDelinkScanCounter();
           
         };
         
         // Store reference for potential removal later
         delinkRedoBtn._clickHandler = clickHandler;
         delinkRedoBtn.addEventListener('click', clickHandler);
         
       } 
     }
   
     // ✅ UPDATED: Simplified event listeners without "Set Top Tray" button logic
   // ✅ UPDATED: Simplified event listeners without "Set Top Tray" button logic
   function addTopTrayEventListeners(lotId, isDraft, topTrayQty) {
   const topTrayInput = document.getElementById('topTrayIdInput');
   const topTrayError = document.getElementById('topTrayError');
   const redoBtn = document.getElementById('topTrayRedoBtn');
   const counter = document.getElementById('topTrayScanCounter');
   
   // Input validation on blur - only for visual feedback, not blocking
   topTrayInput.addEventListener('blur', function() {
   const trayId = this.value.trim();
   if (!trayId || topTrayInput.readonly) {
     return;
   }
   
   // ✅ UPDATED: Only validate for visual feedback, don't block submission
   validateTopTrayIdForDisplay(trayId, lotId);
   });
   
   // Input change event
   topTrayInput.addEventListener('input', function() {
   if (topTrayInput.readonly) return;
   
   const trayId = this.value.trim();
   hideError();
   updateButtonStates(!!trayId); // Enable buttons when tray ID is entered
   updateCounter(!!trayId);
   });
   
   // Redo button
   if (redoBtn) {
   redoBtn.addEventListener('click', function() {
     topTrayInput.value = '';
     topTrayInput.readonly = false;
     topTrayInput.style.backgroundColor = '';
     topTrayInput.style.borderColor = '#ddd';
     hideError();
     updateButtonStates(false);
     updateCounter(false);
     topTrayInput.focus();
   });
     topTrayInput.addEventListener('input', checkForDuplicateTrayId);
   
   }
   
   // Button event listeners
   addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty);
   
   function validateTopTrayIdForDisplay(trayId, lotId) {
   showError('Validating...', '#007bff');
   
   fetch(`/recovery_is/rec_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
   .then(res => res.json())
   .then(data => {
     
     // Check for duplicate with delink trays
     let isDuplicate = false;
     const delinkInputs = document.querySelectorAll('.delink-tray-input');
     delinkInputs.forEach(input => {
       if (input.value.trim() && input.value.trim() === trayId) {
         isDuplicate = true;
       }
     });
   
    if (isDuplicate) {
      showError('❌ Same tray cannot be used for both Delink and Top Tray', '#dc3545');
      updateButtonStates(false);
      updateCounter(false);
      setTimeout(() => {
        topTrayInput.focus();
        topTrayInput.select();
      }, 100);
      return;
    }
   
    if (data.error === 'Tray id is not verified' || data.tray_status === 'not_verified') {
      showError('❌ Tray id is not verified', '#dc3545');
      updateButtonStates(false);
      updateCounter(false);
      topTrayInput.style.backgroundColor = '#f8d7da';
      topTrayInput.style.borderColor = '#dc3545';
      setTimeout(() => {
        topTrayInput.focus();
        topTrayInput.select();
      }, 100);
      return;
    }
   
     if (data.exists || data.already_used_in_acceptance) {
      showError('✅ Valid tray ID', '#28a745');
      updateButtonStates(true);
      updateCounter(true);
      topTrayInput.style.backgroundColor = '#d4edda';
      topTrayInput.style.borderColor = '#28a745';
      // Do NOT focus/select or auto-hide on success
      } else {
      // ❌ Only show error for genuinely invalid trays
      let errorMsg = 'Invalid tray ID';
      if (data.already_rejected) errorMsg = 'Tray already rejected';
      else if (data.not_in_same_lot) errorMsg = 'Tray not in same lot';
      else errorMsg = 'Tray ID not found';

      showError('❌ ' + errorMsg, '#dc3545');
      updateButtonStates(false);
      updateCounter(false);
      topTrayInput.style.backgroundColor = '#f8d7da';
      topTrayInput.style.borderColor = '#dc3545';

      // Do NOT clear the value or hide the error. Just select all and keep focus.
      setTimeout(() => {
        topTrayInput.focus();
        topTrayInput.select();
      }, 100);
      }
     })
     .catch(error => {
       // ✅ UPDATED: Don't block on connection errors, just show warning
       showError('⚠️ Connection issue - will validate on submit', '#ffc107');
       updateButtonStates(true); // Allow submission anyway
       updateCounter(true);
     });
   }
   
   function updateButtonStates(hasValidTray) {
   const draftBtn = document.getElementById('acceptedTrayDraftBtn');
   const submitBtn = document.getElementById('acceptedTraySubmitBtn');
   const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
   const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
   
   if (draftBtn) draftBtn.disabled = !hasValidTray;
   if (submitBtn) submitBtn.disabled = !hasValidTray;
   if (updateDraftBtn) updateDraftBtn.disabled = !hasValidTray;
   if (finalSubmitBtn) finalSubmitBtn.disabled = !hasValidTray;
   }
   
   function updateCounter(isValid) {
   if (counter) {
     if (isValid) {
       counter.textContent = `${topTrayQty}/${topTrayQty}`;
       counter.style.color = '#28a745';
     } else {
       counter.textContent = `0/${topTrayQty}`;
       counter.style.color = '#dc3545';
     }
   }
   }
   
   function showError(message, color) {
   topTrayError.textContent = message;
   topTrayError.style.color = color;
   topTrayError.style.display = 'block';
   }
   
   function hideError() {
   topTrayError.style.display = 'none';
   }
   }
   
   
   // ✅ UPDATED: Button event listeners remain the same but now work directly with input validation
   function addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty) {
   if (isDraft) {
   const updateDraftBtn = document.getElementById("acceptedTrayUpdateDraftBtn");
   const finalSubmitBtn = document.getElementById("acceptedTrayFinalSubmitBtn");
   
   if (updateDraftBtn) {
     updateDraftBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, true));
   }
   
   if (finalSubmitBtn) {
     finalSubmitBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, false));
   }
   } else {
   const draftBtn = document.getElementById("acceptedTrayDraftBtn");
   const submitBtn = document.getElementById("acceptedTraySubmitBtn");
   
   if (draftBtn) {
     draftBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, true));
   }
   
   if (submitBtn) {
     submitBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, false));
   }
   }
   
   const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
   if (cancelBtn) {
   cancelBtn.addEventListener("click", () => {
   // Close the newPopupModal (accepted tray modal)
   document.getElementById("newPopupModal").classList.remove("open");
   
   // ✅ NEW: Also close trayScanModal if it's open
   const trayScanModal = document.getElementById("trayScanModal");
   if (trayScanModal && trayScanModal.classList.contains("open")) {
     trayScanModal.classList.remove("open");
     trayScanModal.style.display = "none";
   }
   
   // Add a slight delay then refresh table data only
   setTimeout(() => {
     location.reload();
   }, 300);
   });
   }
   }
   
   function refreshTableData() {
   // Get current page number for pagination
   const currentPage = new URLSearchParams(window.location.search).get('page') || 1;
   
   // Fetch fresh table data silently
   fetch(`${window.location.pathname}?page=${currentPage}`, {
   method: 'GET',
   headers: {
     'X-Requested-With': 'XMLHttpRequest', // Mark as AJAX request
   }
   })
   .then(response => response.text())
   .then(html => {
   // Create a temporary container to parse the response
   const tempDiv = document.createElement('div');
   tempDiv.innerHTML = html;
   
   // Extract the new table content
   const newTableBody = tempDiv.querySelector('#order-listing tbody');
   const currentTableBody = document.querySelector('#order-listing tbody');
   
   if (newTableBody && currentTableBody) {
     // Replace table body content silently
     currentTableBody.innerHTML = newTableBody.innerHTML;
   
     // Also update pagination if needed
     const newPagination = tempDiv.querySelector('.pagination-wrapper');
     const currentPagination = document.querySelector('.pagination-wrapper');
     if (newPagination && currentPagination) {
       currentPagination.innerHTML = newPagination.innerHTML;
     }
   
     // ✅ Re-attach modal open event listeners after table refresh
   
     // ✅ FIXED: Reject button with proper conditional logic
     document.querySelectorAll('.tray-scan-btn').forEach((link) => {
       link.addEventListener('click', (event) => {
         event.preventDefault();
   
         const row = event.target.closest("tr");
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         
         // ✅ Get the row attributes to determine which modal to show
         const ipOnholdPicking = row.getAttribute('data-ip-onhold-picking') === 'True';
         const fewCasesAcceptance = row.getAttribute('data-few-cases-acceptance') === 'True';
   
         console.log('Reject button clicked:', {
           ipOnholdPicking,
           fewCasesAcceptance,
           stockLotId
         });
   
         // ✅ Apply the correct conditional logic
         if (ipOnholdPicking && fewCasesAcceptance) {
           // Both are true - show accepted tray modal (Partial Reject scenario)
           console.log('Both conditions true - showing accepted tray modal');
           fetch(`/recovery_is/rec_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
             .then(res => res.json())
             .then(rescanData => {
               if (rescanData.success) {
                 showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
               } else {
                 // Fallback to showing rejection modal if accepted tray data fails
                 showRejectionModalFlow(batchId, stockLotId, true, row);
               }
             })
             .catch(error => {
               console.error('Error fetching accepted tray data:', error);
               // Fallback to showing rejection modal
               showRejectionModalFlow(batchId, stockLotId, true, row);
             });
         } else {
           // Either both are false or only ipOnholdPicking is true - show rejection modal
           console.log('Showing rejection modal flow');
           
           // ✅ FIXED: Use the same logic as original event listener
           // Set up the modal data first
           const trayModal = document.getElementById("trayScanModal");
           const detailsDiv = document.getElementById("trayScanDetails");
           const modalHeader = document.getElementById("trayScanModalHeader");
           
           trayModal.dataset.batchId = batchId;
           trayModal.dataset.stockLotId = stockLotId;
           
           // Set modal header
           const modelNo = row.getAttribute('data-model-no') || '';
           if (modalHeader) {
             modalHeader.innerHTML = `R-Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
           }
           
           // ✅ CRITICAL: Use the same conditional logic as original
           if (ipOnholdPicking) {
             // Show read-only saved data (completed process)
             showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
           } else {
             // ✅ FIXED: Check for draft first, then show form
             checkForExistingDraft(stockLotId, batchId, detailsDiv, row);
           }
           
           // Show the modal
           trayModal.style.display = "block";
           trayModal.classList.add("open");
         }
       });
     });
   
     // View button (opens R-Input Screening modal - right side)
     document.querySelectorAll('.tray-scan-btn-DayPlanning-view').forEach((link) => {
       link.addEventListener('click', async function (e) {
         e.preventDefault();
   
         // Get modal elements
         const modal = document.getElementById("trayScanModal_DayPlanning");
         const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
         const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
         modal.dataset.batchId = link.getAttribute('data-batch-id');
   
         // Get data attributes
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         const modelNo = link.getAttribute('data-model-no');
         const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
         const trayCapacity = link.getAttribute('data-tray-capacity') || "";
         const isQtyVerified = link.getAttribute('data-ip-person-qty-verified') === 'true';
   
         let trayQtyList = [];
         try {
           trayQtyList = JSON.parse(link.getAttribute('data-tray-qty-list') || "[]");
         } catch (e) {
           trayQtyList = [];
         }
   
         // Set model number in modal
         if (modalModelNo && modelNo) {
           modalModelNo.textContent = modelNo;
         }
   
         // Set model image
         const modalUserImg = modal.querySelector('.user-profile img');
         const modelImage = link.getAttribute('data-model-image');
         if (modalUserImg) {
           if (modelImage) {
             modalUserImg.src = modelImage;
           } else {
             modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
           }
         }
   
         // Show/Hide validation buttons based on verification status
         const trayValidateSection = document.getElementById("trayValidateSection");
         const verificationStatusIndicator = document.getElementById("verificationStatusIndicator");
   
         if (isQtyVerified) {
           if (trayValidateSection) trayValidateSection.style.display = "none";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "block";
         } else {
           if (trayValidateSection) trayValidateSection.style.display = "flex";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "none";
         }
   
         // Fetch tray data with proper top tray handling using API
         let traysData = [];
         try {
           const resp = await fetch(`/recovery_is/rec_ip_completed_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
           const result = await resp.json();
           if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
             traysData = result.trays;
           }
         } catch (e) {
         }
   
         // Fetch existing verification status
         let verificationData = {};
         try {
           const verifyResp = await fetch(`/recovery_is/rec_get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
           const verifyResult = await verifyResp.json();
           if (verifyResult.success) {
             verificationData = verifyResult.verification_data;
           }
         } catch (e) {
         }
   
         // TABLE BUILDING FUNCTION (reuse your existing buildTableHTML)
         function buildTableHTML(showValidationColumn = false) {
           let html = `
             <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
               <thead>
                 <tr>
                   <th style="width:50px;">S.no</th>
                   <th>Tray ID</th>
                   <th>Tray Qty</th>
                   ${showValidationColumn && !isQtyVerified ? '<th>Tray Validation Status</th>' : ''}
                 </tr>
               </thead>
               <tbody>
           `;
           
           // If we have trays data from API, use it directly
           if (traysData && traysData.length > 0) {
             traysData.forEach((tray, index) => {
               const isTopTray = tray.is_top_tray || index === 0;
               const displaySNo = tray.is_top_tray ? '1 (Top Tray)' : tray.s_no;
               const position = index + 1;
   
               // Check verification status
               const verification = verificationData[position];
               const isVerifiedByUser = verification ? verification.is_verified : false;
               const isVerifiedInDB = tray.IP_tray_verified || false;
               const isVerified = isVerifiedByUser || isVerifiedInDB;
               
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
   
               // Set input properties based on verification status
               let inputValue, inputStyle, verificationIndicator;
   
               if (isVerified) {
                 inputValue = verifiedTrayId || tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
   
               html += `
                 <tr>
                   <td>${displaySNo}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td style="position:relative; white-space:nowrap;">
                     <span style="display:inline-flex; align-items:center;">
                       <input type="number" 
                              class="form-control tray-qty-input" 
                              value="${tray.tray_quantity || ''}" 
                              readonly 
                              style="width: 40px; display:inline-block; vertical-align:middle; text-align:right; margin-right:4px;"
                              data-initial="${tray.tray_quantity || ''}"
                              ${isTopTray ? 'data-top-tray="1"' : ''} 
                       />
                      
                     </span>
                   </td>
                   ${showValidationColumn && !isQtyVerified ? `
                     <td>
                       <div class="validation-status">
                         <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                         </div>
                         <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                         </div>
                       </div>
                     </td>
                   ` : ''}
                 </tr>
               `;
             });
           } else {
             // Fallback: Use the old method if API data is not available
             let totalRows = noOfTrays;
             for (let i = 0; i < totalRows; i++) {
               const position = i + 1;
               const verification = verificationData[position];
               const isVerified = verification ? verification.is_verified : false;
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
               const trayQty = trayQtyList[i] || trayCapacity;
               
               let inputValue, inputStyle, verificationIndicator;
               
               if (isVerified) {
                 inputValue = verifiedTrayId;
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
               
               html += `
                 <tr>
                   <td>${i === 0 ? '1 (Top Tray)' : (i + 1)}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td>
                     <input type="number" class="form-control" value="${trayQty}" readonly style="width: 100%;" />
                   </td>
                   ${showValidationColumn && !isQtyVerified ? `
                     <td>
                       <div class="validation-status">
                         <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                         </div>
                         <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                           <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                         </div>
                       </div>
                     </td>
                   ` : ''}
                 </tr>
               `;
             }
           }
           
           html += `
               </tbody>
             </table>
           `;
           return html;
         }
   
         // Initially show table
         detailsDiv.innerHTML = buildTableHTML(false);
   
         // Store data in modal for later use
         modal.buildTableHTML = buildTableHTML;
         modal.traysData = traysData;
         modal.verificationData = verificationData;
         modal.noOfTrays = noOfTrays;
         modal.trayQtyList = trayQtyList;
         modal.trayCapacity = trayCapacity;
         modal.isQtyVerified = isQtyVerified;
         modal.stockLotId = stockLotId;
   
         // Show the modal
         if (modal) modal.style.display = "block";
         modal.classList.add("open");
   
         // Check verification status after modal opens
         setTimeout(() => {
           if (!modal.isQtyVerified) {
             checkVerificationStatusAndShowButtons();
           } else {
             removeDraftCancelButtons();
           }
         }, 200);
       });
     });
   
     // ✅ Re-attach Hold Toggle functionality after table refresh
     console.log('Calling attachHoldToggleListeners after table refresh...');
     if (typeof attachHoldToggleListeners === 'function') {
       attachHoldToggleListeners();
     } else {
       console.error('attachHoldToggleListeners function not found!');
     }
   
     // Re-attach other event listeners if needed (accept buttons, delete buttons, etc.)
     reattachOtherEventListeners();
   }
   })
   .catch(error => {
   console.error('Error refreshing table data:', error);
   // Silent error - no user notification
   });
   }
   
   // Helper function to reattach other event listeners
   function reattachOtherEventListeners() {
   // Re-attach Accept button listeners
   document.addEventListener('click', function(e) {
   if (e.target.closest('.btn-twitter')) {
     // Your existing accept button logic here
   }
   });
   
   // Re-attach Delete button listeners
   document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
   btn.addEventListener('click', function(e) {
     // Your existing delete button logic here
   });
   });
   
   // Re-attach any other dynamic event listeners as needed
   }
   // Helper function to reattach other event listeners
   function reattachOtherEventListeners() {
   // Re-attach Accept button listeners
   document.addEventListener('click', function(e) {
   if (e.target.closest('.btn-twitter')) {
     // Your existing accept button logic here
   }
   });
   
   // Re-attach Delete button listeners
   document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
   btn.addEventListener('click', function(e) {
     // Your existing delete button logic here
   });
   });
   
   // Re-attach any other dynamic event listeners as needed
   }
   
   // ✅ UPDATED: Modified saveTopTrayScan to handle empty tray_id properly
   function saveTopTrayScan(lotId, topTrayQty, isDraft) {
   
   const topTrayInput = document.getElementById('topTrayIdInput');
   const trayId = topTrayInput ? topTrayInput.value.trim() : '';
   
   // ✅ FIXED: Check if we have delink trays as alternative
   const delinkInputs = document.querySelectorAll('.delink-tray-input');
   const hasDelinkTrays = Array.from(delinkInputs).some(input => input.value.trim());
   
   // ✅ UPDATED: Allow draft saving if EITHER top tray ID OR delink trays are provided
   if (!trayId && !hasDelinkTrays) {
   showAcceptedTrayMessage('Please scan at least one tray ID (either Top Tray or Delink)', '#dc3545');
   return;
   }
   
   // ✅ REMOVED: No longer block delink-only operations for draft saves
   // Allow delink-only operations for drafts, but maybe restrict for final submission
   if (!isDraft && !trayId && hasDelinkTrays) {
   showAcceptedTrayMessage('Final submission requires a top tray ID. You can save as draft with delink trays only.', '#dc3545');
   return;
   }
   
   // ✅ FIXED: Proceed with save - backend will handle all validation
   proceedWithSave();
   
   function proceedWithSave() {
   // ✅ NEW: Collect delink tray data with detailed logging
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  const delinkTrays = [];
  let allDelinkFilled = true;
  
  delinkInputs.forEach((input, index) => {
    const delinkTrayId = input.value.trim();
    const expectedQty = parseInt(input.getAttribute('data-expected-qty')) || 0;
    delinkTrays.push({
      tray_id: delinkTrayId,
      tray_qty: expectedQty,
      position: index
    });
    // Check if any delink tray is empty
    if (!delinkTrayId) {
      allDelinkFilled = false;
    }
  });
  
  // For final submit (not draft), require all delink trays to be filled if any are present
  if (!isDraft && delinkInputs.length > 0 && !allDelinkFilled) {
    showAcceptedTrayMessage('Please fill all Delink Tray IDs before submitting.', '#dc3545');
    return;
  }
  
  // ...proceedWithSave()...
   
   // ✅ UPDATED: Build payload more carefully
   const payload = {
     lot_id: lotId,
     draft_save: isDraft,
     delink_trays: delinkTrays
   };
   
   // ✅ FIXED: Only include tray_id and tray_qty if we actually have a top tray
   if (trayId) {
     payload.tray_id = trayId;
     payload.tray_qty = topTrayQty;
   }
   
   console.log('Sending payload:', payload); // ✅ Debug log
   
   // ✅ NEW: Show appropriate loading message based on what's being saved
   if (!isDraft) {
     if (trayId && delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Processing top tray scan and ${delinkTrays.length} delink operations...`, '#007bff');
     } else if (trayId) {
       showAcceptedTrayMessage('⏳ Processing top tray scan...', '#007bff');
     } else if (delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Processing ${delinkTrays.length} delink operations...`, '#007bff');
     }
   } else {
     // Draft save messages
     if (trayId && delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Saving draft with top tray and ${delinkTrays.length} delink tray(s)...`, '#007bff');
     } else if (trayId) {
       showAcceptedTrayMessage('⏳ Saving draft with top tray scan...', '#007bff');
     } else if (delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Saving draft with ${delinkTrays.length} delink tray(s)...`, '#007bff');
     }
   }
   
   fetch('/recovery_is/rec_save_single_top_tray_scan/', {
     method: 'POST',
     headers: {
       'Content-Type': 'application/json',
       'X-CSRFToken': getCookie('csrftoken')
     },
     body: JSON.stringify(payload)
   })
   .then(res => {
     return res.json();
   })
   .then(data => {
     console.log('Server response:', data); // ✅ Debug log
     
     if (data.success) {
       let message = data.message;
       
       // ✅ NEW: Show detailed success message based on what was saved
       if (!isDraft) {
         if (trayId && data.delink_count > 0) {
           message = `✅ Top tray scan completed. ${data.delink_count} tray(s) marked for delink.`;
         } else if (trayId) {
           message = '✅ Top tray scan completed successfully.';
         } else if (data.delink_count > 0) {
           message = `✅ ${data.delink_count} tray(s) marked for delink.`;
         }
       } else {
         // Draft save success messages
         if (trayId && data.delink_count > 0) {
           message = `✅ Draft saved with top tray and ${data.delink_count} delink tray(s).`;
         } else if (trayId) {
           message = '✅ Draft saved with top tray scan.';
         } else if (data.delink_count > 0) {
           message = `✅ Draft saved with ${data.delink_count} delink tray(s).`;
         } else {
           message = '✅ Draft saved successfully.';
         }
       }
       
       showAcceptedTrayMessage(message, '#28a745');
   
       setTimeout(() => {
         window.location.reload();
       }, 1500);
   
       return;
       
     } else {
       showAcceptedTrayMessage(data.error || 'Failed to save', '#dc3545');
     }
   })
   .catch(error => {
     console.error('Network error:', error); // ✅ Debug log
     showAcceptedTrayMessage('Network error occurred', '#dc3545');
   });
   }
   }
   
   // ✅ EXISTING: Show message helper
     function showAcceptedTrayMessage(message, color) {
       const msgDiv = document.getElementById("acceptedTrayMsg");
       if (msgDiv) {
         msgDiv.style.color = color;
         msgDiv.textContent = message;
         setTimeout(() => {
           msgDiv.textContent = "";
         }, 3000);
       }
     }
   
     // ✅ UPDATED: Enhanced delink tray validation using delink_check_tray_id endpoint
     function addDelinkTrayValidation(lotId) {
       console.log('🔧 Adding delink tray validation for lot:', lotId);
       
       document.querySelectorAll('.delink-tray-input').forEach(function(input, idx, allInputs) {
         // Remove existing event listeners
         if (input._blurHandler) input.removeEventListener('blur', input._blurHandler);
         if (input._inputHandler) input.removeEventListener('input', input._inputHandler);
         if (input._keydownHandler) input.removeEventListener('keydown', input._keydownHandler);
         
         // Track validation state for each input
         input._hasError = false;
         input._isValidating = false;
         
         // Input event for counter update
         input._inputHandler = function() {
           // Clear error state when user starts typing
           this._hasError = false;
           const errorSpan = this.parentElement.querySelector('.delink-tray-error');
           if (errorSpan) {
             errorSpan.style.display = 'none';
             errorSpan.textContent = '';
           }
           updateDelinkScanCounter();
         };
         input.addEventListener('input', input._inputHandler);
         
         // Enhanced keydown handler to prevent navigation on errors
         input._keydownHandler = function(e) {
           if (e.key === 'Enter') {
             e.preventDefault();
             
             // Prevent navigation if current field has error
             if (this._hasError) {
               this.focus(); // Keep focus on current field
               return;
             }
             
             // Prevent navigation if currently validating
             if (this._isValidating) {
               return;
             }
             
             // Prevent navigation if field is empty
             if (!this.value.trim()) {
               return;
             }
             
             // Allow navigation - move to next field only if no errors
             const nextInput = allInputs[idx + 1];
             if (nextInput) {
               nextInput.focus();
             }
           }
         };
         input.addEventListener('keydown', input._keydownHandler);
         
         // ✅ UPDATED: Enhanced blur handler using delink_check_tray_id validation
         input._blurHandler = function() {
           const trayId = this.value.trim();
           const errorSpan = this.parentElement.querySelector('.delink-tray-error');
           this._hasError = false;
         
           // Clear any existing error messages
           if (errorSpan) {
             errorSpan.textContent = '';
             errorSpan.style.display = 'none';
           }
         
           if (!trayId) {
             updateDelinkScanCounter();
             return;
           }
         
           this._isValidating = true;
           console.log(`🔍 [Delink Validation] Validating tray ID: ${trayId} for lot: ${lotId}`);
         
           // Check for duplicates within current form (delink inputs only)
           let isDuplicate = false;
           document.querySelectorAll('.delink-tray-input').forEach(function(otherInput) {
             if (otherInput !== input && otherInput.value.trim() === trayId) {
               isDuplicate = true;
             }
           });
         
           if (isDuplicate) {
             this._hasError = true;
             this._isValidating = false;
             console.log(`❌ [Delink Validation] Duplicate tray ID detected: ${trayId}`);
             
             if (errorSpan) {
               errorSpan.innerHTML = `❌ Duplicate`;
               errorSpan.style.display = 'block';
               errorSpan.style.color = '#dc3545';
               errorSpan.style.backgroundColor = '#f8d7da';
               errorSpan.style.padding = '4px 8px';
               errorSpan.style.borderRadius = '4px';
               errorSpan.style.fontSize = '11px';
             }
             
             setTimeout(() => {
               this.value = '';
               this._hasError = false;
               if (errorSpan) errorSpan.style.display = 'none';
               this.focus();
               updateDelinkScanCounter();
             }, 1500);
             return;
           }
     
           // ✅ NEW: Use delink_check_tray_id endpoint for validation
           const queryParams = new URLSearchParams({
             tray_id: trayId,
             lot_id: lotId
           }).toString();
           
           fetch(`/recovery_is/rec_delink_check_tray_id/?${queryParams}`)
             .then(res => res.json())
             .then(data => {
               this._isValidating = false;
               
               console.log(`🔍 [Delink Validation] Server response for ${trayId}:`, data);
         
               if (errorSpan) {
                 if (data.exists && data.valid_for_delink) {
                   // ✅ SUCCESS: Valid tray for delink
                   this._hasError = false;
                   
                   let successMessage = `✅ ${data.status_message || 'Available for Delink'}`;
                   
                   // ✅ Show additional info if available
                   if (data.tray_quantity) {
                     successMessage ;
                   }
                   
                   errorSpan.innerHTML = successMessage;
                   errorSpan.style.display = 'block';
                   errorSpan.style.color = '#155724';
                   errorSpan.style.backgroundColor = '#d4edda';
                   errorSpan.style.border = '1px solid #c3e6cb';
                   errorSpan.style.padding = '4px 8px';
                   errorSpan.style.borderRadius = '4px';
                   errorSpan.style.fontSize = '11px';
                   
                   // ✅ Update input styling for valid tray
                   this.style.backgroundColor = '#d4edda';
                   this.style.borderColor = '#28a745';
                   this.style.color = '#155724';
                   
                   setTimeout(() => {
                     if (errorSpan) errorSpan.style.display = 'none';
                     updateDelinkScanCounter();
                   }, 3000);
                   
                 } else {
                   // ❌ ERROR: Invalid tray for delink
                  this._hasError = true;
                  
                  let errorMessage = `❌ ${data.status_message || 'Invalid for Delink'}`;
                  
                  // ✅ Specific error handling based on tray status
                  if (data.tray_status === 'not_verified') {
                    errorMessage = '❌ Tray id is not verified';
                  } else if (data.tray_status === 'different_lot') {
                    errorMessage = '❌ Different Lot';
                  } else if (data.tray_status === 'already_rejected') {
                    errorMessage = '❌ Already Rejected';
                  } else if (data.tray_status === 'already_delinked') {
                    errorMessage = '❌ Already Delinked';
                  } else if (data.error === 'Tray ID not found') {
                    errorMessage = '❌ Not Found';
                  }
                  
                  errorSpan.innerHTML = errorMessage;
                  errorSpan.style.display = 'block';
                  errorSpan.style.color = '#721c24';
                  errorSpan.style.backgroundColor = '#f8d7da';
                  errorSpan.style.border = '1px solid #f5c6cb';
                  errorSpan.style.padding = '4px 8px';
                  errorSpan.style.borderRadius = '4px';
                  errorSpan.style.fontSize = '11px';
                  
                  // ✅ Update input styling for invalid tray
                  this.style.backgroundColor = '#f8d7da';
                  this.style.borderColor = '#dc3545';
                  this.style.color = '#721c24';
                  
                  // ✅ Do NOT clear the value or hide the error. Just select all and keep focus.
                  setTimeout(() => {
                    this.focus();
                    this.select();
                    updateDelinkScanCounter();
                  }, 100);
                 }
               } else {
                 updateDelinkScanCounter();
               }
             })
             .catch(error => {
               this._isValidating = false;
               this._hasError = true;
               console.error(`❌ [Delink Validation] Network error for ${trayId}:`, error);
               
               if (errorSpan) {
                 errorSpan.innerHTML = '❌ Connection Error';
                 errorSpan.style.display = 'block';
                 errorSpan.style.color = '#721c24';
                 errorSpan.style.backgroundColor = '#f8d7da';
                 errorSpan.style.padding = '4px 8px';
                 errorSpan.style.borderRadius = '4px';
                 errorSpan.style.fontSize = '11px';
                 
                 setTimeout(() => {
                   this.value = '';
                   this._hasError = false;
                   this.style.backgroundColor = '';
                   this.style.borderColor = '#ddd';
                   this.style.color = '';
                   if (errorSpan) errorSpan.style.display = 'none';
                   this.focus();
                   updateDelinkScanCounter();
                 }, 2000);
               } else {
                 updateDelinkScanCounter();
               }
             });
         };
         input.addEventListener('blur', input._blurHandler);
       });
       
       // ✅ Also add input event listener for duplicate checking with top tray
       document.querySelectorAll('.delink-tray-input').forEach(input => {
         input.addEventListener('input', checkForDuplicateTrayId);
       });
     
       console.log('✅ [Delink Validation] Event listeners attached successfully');
     }
   
   // Place this function after both above functions:
   function checkForDuplicateTrayId() {
   const topTrayInput = document.getElementById('topTrayIdInput');
   const delinkInputs = document.querySelectorAll('.delink-tray-input');
   const submitBtn = document.getElementById('acceptedTraySubmitBtn');
   const draftBtn = document.getElementById('acceptedTrayDraftBtn');
   const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
   const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
   const errorDiv = document.getElementById('topTrayError');
   let duplicate = false;
   
   if (topTrayInput && topTrayInput.value.trim()) {
   delinkInputs.forEach(input => {
     if (input.value.trim() && input.value.trim() === topTrayInput.value.trim()) {
       duplicate = true;
     }
   });
   }
   
   if (duplicate) {
   if (submitBtn) submitBtn.disabled = true;
   if (draftBtn) draftBtn.disabled = true;
   if (updateDraftBtn) updateDraftBtn.disabled = true;
   if (finalSubmitBtn) finalSubmitBtn.disabled = true;
  if (errorDiv) {
    errorDiv.textContent = '❌ Same tray cannot be used for both Delink and Top Tray';
    errorDiv.style.display = 'block';
    errorDiv.style.color = '#dc3545';
    errorDiv.style.backgroundColor = '#f8d7da';
    errorDiv.style.padding = '4px 8px';
    errorDiv.style.borderRadius = '4px';
    errorDiv.style.fontSize = '11px';
    // Focus and select the input (assuming you have a reference to the input)
    setTimeout(() => {
      if (topTrayInput) {
        topTrayInput.focus();
        topTrayInput.select();
      }
    }, 100);
  }
   } else {
   if (submitBtn) submitBtn.disabled = false;
   if (draftBtn) draftBtn.disabled = false;
   if (updateDraftBtn) updateDraftBtn.disabled = false;
   if (finalSubmitBtn) finalSubmitBtn.disabled = false;
   if (errorDiv) errorDiv.style.display = 'none';
   }
   }
   
     // ✅ NEW: Update delink scan counter
     function updateDelinkScanCounter() {
       const counter = document.getElementById('delinkScanCounter');
       if (!counter) return;
       
       const totalQuantity = parseInt(counter.getAttribute('data-total-quantity')) || 0;
       let scannedQuantity = 0;
       
       // Calculate total scanned quantity
       document.querySelectorAll('.delink-tray-input').forEach(input => {
         const trayId = input.value.trim();
         const hasError = input.parentElement.querySelector('.delink-tray-error').style.display === 'block';
         
         // Only count if tray ID is filled and has no errors
         if (trayId && !hasError) {
           // Get the expected quantity for this row
           const expectedQty = parseInt(input.getAttribute('data-expected-qty')) || 0;
           scannedQuantity += expectedQty;
         }
       });
       
       // Update counter display
       counter.textContent = `${scannedQuantity}/${totalQuantity}`;
       
       // Update color based on progress
       if (scannedQuantity === totalQuantity && totalQuantity > 0) {
         counter.style.color = '#28a745'; // Green when complete
       } else if (scannedQuantity > 0) {
         counter.style.color = '#ffc107'; // Yellow when in progress
       } else {
         counter.style.color = '#dc3545'; // Red when not started
       }
       
     }
   
     // Helper function to get CSRF token
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   
     // ✅ MISSING FUNCTIONS: Add the missing utility functions
     function updateUIForBatchRejection(batchId) {
       // Update UI after batch rejection if needed
     }

     
     // New Popup Modal close events
     closeNewPopupBtn.addEventListener("click", () => {
       newPopupModal.classList.remove("open");
     });
    
   });
   
   // ✅ NEW: Add CSS for draft mode animations and grid styling
   const draftModeCSS = `
     <style>
       @keyframes draftModeGlow {
         from { box-shadow: 0 0 5px rgba(243, 156, 18, 0.3); }
         to { box-shadow: 0 0 15px rgba(243, 156, 18, 0.6); }
       }
       
       .row-has-draft {
         background-color: #fff3cd !important;
         border-left: 4px solid #f39c12 !important;
       }
       
       .table-grid {
         display: grid;
         grid-template-columns: auto 1fr auto;
         gap: 0;
       }
       
       .table-grid > div {
         border: 1px solid #ccc;
         padding: 8px;
         background: #fff;
       }
       
       .table-grid > div:first-child,
       .table-grid > div:nth-child(3n+1) {
         background: #f8f9fa;
         font-weight: bold;
       }
       
       /* Enhanced styling for single top tray scan */
       .top-tray-input-section {
         border: 2px solid #e0e0e0;
         border-radius: 8px;
         background: #f9f9f9;
         padding: 4px;
         margin: 15px 0;
       }
       
       .top-tray-input-section.has-value {
         border-color: #28a745;
         background: #f8fff9;
       }
       
       .top-tray-input-section.has-error {
         border-color: #dc3545;
         background: #fff5f5;
       }
       
       .scan-counter {
         background: #f8f9fa;
         padding: 6px 12px;
         border-radius: 20px;
         border: 1px solid #dee2e6;
         font-size: 14px;
         font-weight: 600;
       }
       
       .scan-counter.complete {
         background: #d4edda;
         border-color: #28a745;
         color: #155724;
       }
       
       .scan-counter.progress {
         background: #fff3cd;
         border-color: #ffc107;
         color: #856404;
       }
       
       .scan-counter.pending {
         background: #f8d7da;
         border-color: #dc3545;
         color: #721c24;
       }
       
       /* Button styling improvements */
       .action-button {
         padding: 8px 16px;
         border: none;
         border-radius: 30px;
         font-weight: 500;
         transition: all 0.3s ease;
         cursor: pointer;
       }
       
       .action-button:hover:not(:disabled) {
         transform: translateY(-1px);
         box-shadow: 0 4px 8px rgba(0,0,0,0.15);
       }
       
       .action-button:disabled {
         opacity: 0.6;
         cursor: not-allowed;
       }
       
       /* Error and success message styling */
       .status-message {
         padding: 4px 8px;
         border-radius: 4px;
         font-size: 12px;
         margin-top: 4px;
         display: inline-block;
       }
       
       .status-message.success {
         color: #155724;
         background-color: #d4edda;
         border: 1px solid #c3e6cb;
       }
       
       .status-message.error {
         color: #721c24;
         background-color: #f8d7da;
         border: 1px solid #f5c6cb;
       }
       
       /* Loading spinner */
       .loading-spinner {
         display: inline-block;
         width: 16px;
         height: 16px;
         border: 2px solid #f3f3f3;
         border-top: 2px solid #007bff;
         border-radius: 50%;
         animation: spin 1s linear infinite;
       }
       
       @keyframes spin {
         0% { transform: rotate(0deg); }
         100% { transform: rotate(360deg); }
       }
       
       /* Responsive improvements */
       @media (max-width: 768px) {
         .top-tray-input-section {
           flex-direction: column;
           gap: 10px;
         }
         
         .top-tray-input-section > div {
           width: 100% !important;
         }
         
         .scan-counter {
           font-size: 12px;
           padding: 4px 8px;
         }
       }
     </style>
   `;
   
   document.head.insertAdjacentHTML('beforeend', draftModeCSS);
</script>
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     var triggers = document.querySelectorAll(".remark-tooltip-trigger");
     triggers.forEach(function (trigger) {
       var tooltip = trigger.querySelector(".remark-tooltip");
       var sendButton = tooltip ? tooltip.querySelector("button") : null;
       function showTooltip() {
         tooltip.style.opacity = "1";
         tooltip.style.visibility = "visible";
         var rect = tooltip.getBoundingClientRect();
         if (rect.right > window.innerWidth) {
           tooltip.style.left = "auto";
           tooltip.style.right = "0";
           tooltip.style.transform = "none";
         }
         if (rect.left < 0) {
           tooltip.style.left = "0";
           tooltip.style.transform = "none";
         }
         var textarea = tooltip.querySelector("textarea");
         if (textarea) {
           textarea.focus();
         }
       }
       function hideTooltip() {
         tooltip.style.opacity = "0";
         tooltip.style.visibility = "hidden";
       }
       trigger.addEventListener("mouseenter", showTooltip);
       trigger.addEventListener("mouseleave", function () {
         setTimeout(function () {
           if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
             hideTooltip();
           }
         }, 100);
       });
       tooltip.addEventListener("mouseleave", function () {
         setTimeout(function () {
           if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
             hideTooltip();
           }
         }, 100);
       });
       trigger.addEventListener("click", function (e) {
         e.preventDefault();
       });
       if (sendButton) {
         sendButton.addEventListener("click", function (e) {
           e.preventDefault();
           // Find the textarea and get its value
           var textarea = tooltip.querySelector("textarea");
           var remark = textarea ? textarea.value.trim() : "";
           if (!remark) {
             Swal.fire('Error', 'Please enter a remark before sending.', 'error');
             return;
           }
           // Find the batch_id from the row (tr) data attribute or from a hidden field
           var row = trigger.closest("tr");
           var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
           var batchId = row ? row.getAttribute('data-batch-id') : null;
           if (!batchId) {
             Swal.fire('Error', 'Batch ID not found.', 'error');
             return;
           }
           fetch('/recovery_is/rec_save_ip_pick_remark/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify({
               batch_id: batchId,
               remark: remark
             })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               Swal.fire({
                 icon: 'success',
                 title: 'Remark saved!',
                 timer: 1200,
                 showConfirmButton: false
               }).then(() => {
                 // Make the textarea readonly
                 if (textarea) {
                   textarea.setAttribute("readonly", true);
                 }
   
                 // Replace send button with info message
                 if (sendButton && tooltip) {
                   const infoDiv = document.createElement("div");
                   infoDiv.style.marginTop = "40px";
                   infoDiv.style.color = "#31708f";
                   infoDiv.style.background = "#d9edf7";
                   infoDiv.style.border = "1px solid #bce8f1";
                   infoDiv.style.borderRadius = "4px";
                   infoDiv.style.padding = "8px 12px";
                   infoDiv.style.fontSize = "10px";
                   infoDiv.style.textAlign = "left";
                   infoDiv.innerHTML = `
                     <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                     Remark already saved and cannot be edited.
                   `;
                   sendButton.parentNode.replaceChild(infoDiv, sendButton);
                 }
                 
                 // Find the chat icon <img> inside this trigger
                 const chatImg = trigger.querySelector('img[alt="Chat"]');
                 if (chatImg) {
                   chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                   chatImg.style.opacity = "1";
                 }
   
                 hideTooltip(); // optional if you still want to hide the tooltip
               });
   
             } else {
               Swal.fire('Error', data.error || 'Failed to save remark', 'error');
             }
           })
           .catch(() => {
             Swal.fire('Error', 'Network error', 'error');
           });
         });
       }
     });
   });
   
       function getCookie(name) {
     let cookieValue = null;
     if (document.cookie && document.cookie !== '') {
       const cookies = document.cookie.split(';');
       for (let i = 0; i < cookies.length; i++) {
         const cookie = cookies[i].trim();
         if (cookie.substring(0, name.length + 1) === (name + '=')) {
           cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
           break;
         }
       }
     }
     return cookieValue;
   }
</script>
<!-- Active table row highlight -->
<script nonce="{{ csp_nonce }}">
   // Row highlight & position swap for tray-scan-btn-Jig, tray-scan-btn (Set Top Tray/Reject), and btn-twitter (Accept)
   document.addEventListener("DOMContentLoaded", function() {
     // Add highlight style if not present
     if (!document.getElementById('dp-row-action-highlight-style')) {
       var style = document.createElement('style');
       style.id = 'dp-row-action-highlight-style';
       style.innerHTML = `
         .dp-row-action-highlight {
           transition: box-shadow 1.3s;
           animation: highlightAnimation 2s ease-in-out;
         }
       `;
       document.head.appendChild(style);
     }
   
     let originalRowIndex = null;
     let movedRow = null;
     let placeholderRow = null;

     // Function to handle row highlighting and movement
     function handleRowHighlight(event) {
       // Remove highlight from all rows
       document.querySelectorAll('tbody tr').forEach(function(row) {
         row.classList.remove('dp-row-action-highlight');
       });
       // Move the clicked row to the top and highlight
       var row = event.target.closest('tr');
       if (row && row.parentNode) {
         const tbody = row.parentNode;
         // Only move if not already at top
         if (tbody.firstElementChild !== row) {
           // If a previous move exists, restore it first
           if (movedRow && placeholderRow && placeholderRow.parentNode) {
             placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
             placeholderRow.parentNode.removeChild(placeholderRow);
             movedRow.classList.remove('dp-row-action-highlight');
             movedRow = null;
             placeholderRow = null;
             originalRowIndex = null;
           }
           // Store original index and row
           originalRowIndex = Array.from(tbody.children).indexOf(row);
           movedRow = row;
           // Insert a placeholder at the original position
           placeholderRow = document.createElement('tr');
           placeholderRow.style.display = 'none';
           tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
           // Move row to top
           tbody.insertBefore(row, tbody.firstElementChild);
         }
         row.classList.add('dp-row-action-highlight');
       }
     }

     // Function to restore row position and remove highlight
     function restoreRowPosition() {
       if (movedRow && placeholderRow && placeholderRow.parentNode) {
         placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
         placeholderRow.parentNode.removeChild(placeholderRow);
         movedRow.classList.remove('dp-row-action-highlight');
         movedRow = null;
         placeholderRow = null;
         originalRowIndex = null;
       }
       // Also remove highlight from any row just in case
       document.querySelectorAll('tbody tr').forEach(function(row) {
         row.classList.remove('dp-row-action-highlight');
         row.classList.remove('highlighted-tray-scan');
       });
     }

     // Add event listeners for View buttons (tray-scan-btn-Jig)
     document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
       link.addEventListener('click', handleRowHighlight);
     });

     // Add event listeners for Set Top Tray/Reject buttons (tray-scan-btn)
     document.querySelectorAll('.tray-scan-btn').forEach(function(button) {
       button.addEventListener('click', handleRowHighlight);
     });

     // Add event listeners for Accept buttons (btn-twitter)
     document.querySelectorAll('.btn-twitter').forEach(function(button) {
       // Only add listener if it's an Accept button (contains "Accept" text)
       if (button.textContent.includes('Accept')) {
         button.addEventListener('click', handleRowHighlight);
       }
     });

     // On modal close events, restore row to original position and remove highlight
     
     // For View modal (trayScanModal_DayPlanning)
     var closeViewBtn = document.getElementById('closeTrayScanModal_DayPlanning');
     if (closeViewBtn) {
       closeViewBtn.addEventListener('click', restoreRowPosition);
     }

     // For Reject modal (trayScanModal)
     var closeRejectBtn = document.getElementById('closeTrayScanModal');
     if (closeRejectBtn) {
       closeRejectBtn.addEventListener('click', restoreRowPosition);
     }

     // For Accept/Set Top Tray modal (newPopupModal)
     var closeAcceptBtn = document.getElementById('closeNewPopupModal');
     if (closeAcceptBtn) {
       closeAcceptBtn.addEventListener('click', restoreRowPosition);
     }

      // ✅ ENHANCED: Handle dynamically created elements and modal backdrops
      document.addEventListener('click', function(event) {
        if (event.target.id === 'closeAcceptedTrayModal') {
          console.log('🔴 Dynamic accepted tray modal close button clicked');
          restoreRowPosition();
          
          // ✅ ADDED: Refresh page after restoring row position
          setTimeout(() => {
            window.location.reload();
          }, 300);
        }
        
        // Check if clicked element is a modal backdrop
        if (event.target.classList.contains('tray-scan-modal') || 
            event.target.classList.contains('tray-scan-modal-DayPlanning') || 
            event.target.classList.contains('new-popup-modal')) {
          console.log('🔴 Modal backdrop clicked');
          restoreRowPosition();
          

        }
        
        // Handle dynamically created cancel buttons
        if (event.target.textContent === 'Cancel' ||
            event.target.classList.contains('cancel-btn')) {
          console.log('🔴 Dynamic cancel button clicked');
          restoreRowPosition();
          
          // ✅ ADDED: Refresh page after restoring row position
          setTimeout(() => {
            window.location.reload();
          }, 300);
        }
      });
   });
</script>
<script nonce="{{ csp_nonce }}">
   // ✅ FIXED: Store state globally so it persists across table refreshes
   window.holdToggleState = {
     currentHoldCell: null,
     intendedState: null,
     currentBatchId: null,
     currentLotId: null
   };
   
   function attachHoldToggleListeners() {
     console.log('Attaching hold toggle listeners...');
   
     // Attach batch_id to each row for easy access
     document.querySelectorAll("tbody tr").forEach(function (row) {
       const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
       if (trayScanBtn) {
         row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
       }
     });
   
     // Remove existing listeners and attach new ones
     document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
       // Remove any existing click listeners
       const newBtn = btn.cloneNode(true);
       btn.parentNode.replaceChild(newBtn, btn);
       
       // Add new event listener
       newBtn.addEventListener('click', function (e) {
         e.preventDefault();
         
         const holdCell = newBtn.closest('td');
         const row = holdCell.closest('tr');
         
         // ✅ Store state globally with all needed data
         window.holdToggleState = {
           currentHoldCell: holdCell,
           intendedState: newBtn.checked,
           currentBatchId: row.getAttribute('data-batch-id'),
           currentLotId: row.getAttribute('data-stock-lot-id'),
           // Store identifiers that can help us find the row after refresh
           rowIdentifier: row.getAttribute('data-stock-lot-id') || row.getAttribute('data-batch-id')
         };
         
         console.log('Hold toggle clicked, state:', window.holdToggleState);
         
         document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
           window.holdToggleState.intendedState ? 'Unholding Reason' : 'Holding Reason';
         document.getElementById('holdRemarkInput').value = '';
         document.getElementById('holdRemarkError').textContent = '';
         document.getElementById('holdRemarkModal').style.display = 'flex';
         document.getElementById('holdRemarkInput').focus();
       });
     });
   
     // ✅ Attach save button handler (only once globally)
     const saveBtn = document.getElementById('saveHoldRemarkBtn');
     if (saveBtn && !window.holdSaveHandlerAttached) {
       window.holdSaveHandlerAttached = true;
       
       saveBtn.onclick = function () {
         console.log('Save button clicked, current state:', window.holdToggleState);
         
         const remark = document.getElementById('holdRemarkInput').value.trim();
         if (!remark) {
           document.getElementById('holdRemarkError').textContent = 'Remark required!';
           return;
         }
         
         // ✅ Use stored state instead of current variables
         if (!window.holdToggleState.currentLotId) {
           document.getElementById('holdRemarkError').textContent = 'Lot ID not found!';
           return;
         }
       
         const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
         
         console.log('Sending request:', {
           lot_id: window.holdToggleState.currentLotId,
           remark: remark,
           action: action
         });
       
         fetch('/recovery_is/rec_ip_save_hold_unhold_reason/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({
             lot_id: window.holdToggleState.currentLotId,
             remark: remark,
             action: action
           })
         })
         .then(res => res.json())
         .then(data => {
           console.log('Server response:', data);
           
           if (data.success) {
             // ✅ Close modal first
             document.getElementById('holdRemarkModal').style.display = 'none';
             
             // ✅ Update UI immediately before refresh
             const currentRow = document.querySelector(`tr[data-stock-lot-id="${window.holdToggleState.currentLotId}"]`);
             if (currentRow) {
               const toggle = currentRow.querySelector('.hold-toggle-btn');
               const icon = currentRow.querySelector('.hold-remark-icon');
               
               if (action === 'hold') {
                 if (toggle) toggle.checked = false;
                 currentRow.classList.add('row-inactive');
                 currentRow.querySelectorAll('td').forEach((td, idx) => {
                   if (idx > 0) {
                     td.classList.add('row-inactive-blur');
                   } else {
                     td.classList.remove('row-inactive-blur');
                   }
                 });
                 if (icon) {
                   icon.style.display = 'inline-block';
                   icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:18px; height:18px;" />`;
                   icon.setAttribute('title', 'Holding Reason: ' + remark);
                 }
               } else {
                 if (toggle) toggle.checked = true;
                 currentRow.classList.remove('row-inactive');
                 currentRow.querySelectorAll('td').forEach(td => {
                   td.classList.remove('row-inactive-blur');
                 });
                 if (icon) {
                   icon.style.display = 'none';
                 }
               }
             }
             
             // ✅ Then refresh the table data
             setTimeout(() => {
               if (typeof refreshTableData === 'function') {
                 location.reload();
               } else {
                 location.reload();
               }
             }, 500);
             
           } else {
             document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
           }
         })
         .catch((error) => {
           console.error('Request failed:', error);
           document.getElementById('holdRemarkError').textContent = 'Network error!';
         });
       };
     }
   
     // ✅ Attach close button handler (only once globally)
     const closeBtn = document.getElementById('closeHoldRemarkModal');
     if (closeBtn && !window.holdCloseHandlerAttached) {
       window.holdCloseHandlerAttached = true;
       closeBtn.onclick = function () {
         document.getElementById('holdRemarkModal').style.display = 'none';
         // Clear the state when modal is closed
         window.holdToggleState = {
           currentHoldCell: null,
           intendedState: null,
           currentBatchId: null,
           currentLotId: null
         };
       };
     }
   
     // Helper for CSRF
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   }
   
   // ✅ Call on page load
   document.addEventListener("DOMContentLoaded", function () {
     attachHoldToggleListeners();
   });
</script>
<!-- Script for restricting pointer events when modals are open -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     // List all modal IDs you use
     const modalIds = [
       "trayScanModal_DayPlanning",
       "trayScanModal",
       "newPopupModal",
       "imageSliderModal",
       "holdRemarkModal"
     ];
   
     function isAnyModalOpen() {
       return modalIds.some(id => {
         const el = document.getElementById(id);
         return el && (el.style.display === "block" || el.classList.contains("open") || el.style.display === "flex");
       });
     }
   
     function setBodyModalState(active) {
       if (active) {
         document.body.style.overflow = "hidden";
         document.body.style.pointerEvents = "none";
         // Allow pointer events for modals only
         modalIds.forEach(id => {
           const el = document.getElementById(id);
           if (el) el.style.pointerEvents = "auto";
         });
         // Restrict pointer events for holding rows
         document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
           el.style.pointerEvents = "none";
         });
       } else {
         document.body.style.overflow = "";
         document.body.style.pointerEvents = "";
         modalIds.forEach(id => {
           const el = document.getElementById(id);
           if (el) el.style.pointerEvents = "";
         });
         // Restore pointer events for holding rows
         document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
           el.style.pointerEvents = "";
         });
       }
     }
   
     // Observe modal open/close changes
     const observer = new MutationObserver(() => {
       setBodyModalState(isAnyModalOpen());
     });
   
     modalIds.forEach(id => {
       const el = document.getElementById(id);
       if (el) observer.observe(el, { attributes: true, attributeFilter: ["style", "class"] });
     });
   
     // Also check on click (for dynamic changes)
     document.addEventListener("click", function () {
       setTimeout(() => setBodyModalState(isAnyModalOpen()), 50);
     });
   
     // Always restrict pointer events for holding rows, even if no modal is open
     setTimeout(() => {
       document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
         el.style.pointerEvents = "none";
       });
     }, 100);
   });
</script>
<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     let openTooltip = null;
   
     // Helper function to completely close a tooltip
     function closeTooltip(tooltip, trigger) {
       if (tooltip) {
         console.log('🔴 Closing tooltip completely');
         
         // Remove pinned class
         tooltip.classList.remove("pinned");
         
         // Hide the entire tooltip completely
         tooltip.style.opacity = "0";
         tooltip.style.pointerEvents = "none";
         tooltip.style.visibility = "hidden";
         tooltip.style.display = "none"; // ✅ ADDED: Force display none
         
         // Hide buttons
         const infoBtn = tooltip.querySelector('.info-btn');
         const closeBtn = tooltip.querySelector('.close-btn');
         if (infoBtn) infoBtn.style.display = 'none';
         if (closeBtn) closeBtn.style.display = 'none';
         
         // Remove visual indicator from trigger
         if (trigger) {
           trigger.style.backgroundColor = '';
           trigger.style.borderRadius = '';
         }
         
         // Clear global reference
         openTooltip = null;
         
         console.log('✅ Tooltip completely closed');
       }
     }

         document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let lotId = null; 
    let batchId = null;
    if (row) {
      lotId = row.getAttribute('data-lot-id');
      batchId = row.getAttribute('data-batch-id');
    }
    // Build the URL with lot_id and batch_id if found
    let url = "/adminportal/rec_dp_visualaid/";
    if (lotId) {
      url += encodeURIComponent(lotId) + "/";
    }
    if (batchId) {
      url += "?batch_id=" + encodeURIComponent(batchId);
    }
    window.location.href = url;
  });
});
  
   
     // Tooltip show/hide logic
     document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
       const tooltip = trigger.querySelector(".model-image-tooltip");
   
       trigger.addEventListener("mouseenter", function () {
         if (tooltip && !tooltip.classList.contains("pinned")) {
           tooltip.style.display = "flex"; // ✅ ADDED: Reset display
           tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           
           // Show Info and Close buttons on hover
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
         }
       });
   
       trigger.addEventListener("mouseleave", function () {
         if (tooltip && !tooltip.classList.contains("pinned")) {
           tooltip.style.opacity = "0";
           tooltip.style.pointerEvents = "none";
           
           // Hide Info and Close buttons when not hovering and not pinned
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'none';
           if (closeBtn) closeBtn.style.display = 'none';
         }
       });
   
       // Keep tooltip visible when hovering over it
       if (tooltip) {
         tooltip.addEventListener("mouseenter", function () {
           if (!tooltip.classList.contains("pinned")) {
             tooltip.style.display = "flex"; // ✅ ADDED: Reset display
             tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
           }
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           
           // Keep buttons visible when hovering over tooltip
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
         });
   
         tooltip.addEventListener("mouseleave", function () {
           if (!tooltip.classList.contains("pinned")) {
             tooltip.style.opacity = "0";
             tooltip.style.pointerEvents = "none";
             
             // Hide buttons when leaving tooltip and not pinned
             const infoBtn = tooltip.querySelector('.info-btn');
             const closeBtn = tooltip.querySelector('.close-btn');
             if (infoBtn) infoBtn.style.display = 'none';
             if (closeBtn) closeBtn.style.display = 'none';
           }
         });
       }
   
       trigger.addEventListener("click", function (e) {
         e.stopPropagation();
   
         if (tooltip) {
           // Close any previously opened tooltip
           if (openTooltip && openTooltip !== tooltip) {
             const prevTrigger = openTooltip.closest('.model-hover-trigger');
             closeTooltip(openTooltip, prevTrigger);
           }
   
           tooltip.classList.add("pinned");
           tooltip.style.display = "flex"; // ✅ ADDED: Ensure display
           tooltip.style.visibility = "visible"; // ✅ ADDED: Ensure visibility
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           openTooltip = tooltip;
           
           // Keep buttons visible when pinned
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
   
           // Add visual indicator that tooltip is pinned
           trigger.style.backgroundColor = '#e3f2fd';
           trigger.style.borderRadius = '4px';
         }
       });
   

       // ✅ FIXED: Handle Close button click - Complete tooltip closure
       const closeBtn = tooltip?.querySelector('.close-btn');
       if (closeBtn) {
         // Initially hide the button
         closeBtn.style.display = 'none';
         
         closeBtn.addEventListener('click', function(e) {
           e.stopPropagation();
           console.log('🔴 Close button clicked');
           
           // Use the helper function to completely close tooltip
           closeTooltip(tooltip, trigger);
           
           // Feedback animation for close button
           closeBtn.style.transform = 'scale(0.9)';
           setTimeout(() => {
             if (closeBtn.style) {
               closeBtn.style.transform = 'scale(1)';
             }
           }, 150);
         });
         
         // ✅ Add hover effect for close button
         closeBtn.addEventListener('mouseenter', function() {
           closeBtn.style.backgroundColor = '#c82333';
           closeBtn.style.transform = 'scale(1.05)';
         });
         
         closeBtn.addEventListener('mouseleave', function() {
           closeBtn.style.backgroundColor = '#dc3545';
           closeBtn.style.transform = 'scale(1)';
         });
       }
     });
   
     // ✅ ENHANCED: Close tooltip when clicking outside
     document.addEventListener("click", function (e) {
       if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
         const openTrigger = openTooltip.closest('.model-hover-trigger');
         closeTooltip(openTooltip, openTrigger);
       }
     });
   
     // ✅ Close tooltip with ESC key
     document.addEventListener("keydown", function (e) {
       if (e.key === "Escape" && openTooltip) {
         const openTrigger = openTooltip.closest('.model-hover-trigger');
         closeTooltip(openTooltip, openTrigger);
         console.log('✅ Tooltip closed with ESC key');
       }
     });
   
     // Prevent tooltip from closing when clicking inside it
     document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
       tooltip.addEventListener("click", function (e) {
         e.stopPropagation();
       });
     });
   });
</script>

<!-- // --- Child Screen Lock Feature ---
// When child screen (tray scan modal) is open, only allow scroll and Eye icon (view) access on parent.
// All other actions (edit, delete, filter, etc.) are blocked visually and functionally.
 -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  // Only disables actions, not table scroll!
  function lockParentActions() {
    // Disable all actions except view (eye) icon
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button:not(#closeTrayScanModal_DayPlanning):not(#trayValidateBtn):not(#trayScanRedoBtn)'
    ).forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';
    });

    // Also block all <a> except .tray-scan-btn-Jig
    document.querySelectorAll('a:not(.tray-scan-btn-Jig)').forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.cursor = 'not-allowed';
    });

    // ✅ Ensure table scroll is always allowed
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  function unlockParentActions() {
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button'
    ).forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
    });
    document.querySelectorAll('a').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.cursor = '';
    });

    // Restore table scroll (just in case)
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var modal = document.getElementById("trayScanModal_DayPlanning");
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  // When any view icon is clicked and modal opens, lock parent
  document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  // When modal closes, unlock parent
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
function setBodyModalState(active) {
  if (active) {
    document.body.style.overflow = "hidden";
    document.body.style.pointerEvents = ""; // <-- THIS LINE BLOCKS ALL POINTER EVENTS (INCLUDING SCROLL)
    // Allow pointer events for modals only
    modalIds.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.pointerEvents = "auto";
    });
    // Restrict pointer events for holding rows
    document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
      el.style.pointerEvents = "none";
    });
  } else {
    document.body.style.overflow = "";
    document.body.style.pointerEvents = "";
    modalIds.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.pointerEvents = "";
    });
    document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
      el.style.pointerEvents = "";
    });
  }
}
</script>
{% endblock %} {% endblock content %}
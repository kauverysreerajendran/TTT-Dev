
{% extends "base.html" %} {% load static %} {% block content %}
{% load stock_filters %} 

  <style>
    /* ========== Tablet override â€” paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */
@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }
.rounded-circle{
  padding: 17px !important;
}
.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn,
  #trayScanModal_DayPlanning input.form-control,#trayValidateBtn,
  #trayScanModal_DayPlanning table th, #trayScanModal_DayPlanning table td,
  #modalModelNo_DayPlanning
 {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(5)  { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 115px !important; max-width: 125px !important; }
  #order-listing th:nth-child(8)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(11) { min-width: 120px !important; max-width: 130px !important; }
  #order-listing th:nth-child(12) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(13) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(14) { min-width: 130px !important; max-width: 140px !important; }
  #order-listing th:nth-child(15) { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(16) { min-width: 130px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(18) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(19) { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(20) { min-width: 130px !important; max-width: 130px !important; }


  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
}

    /* Highlight sticky columns when row is active */
.spider-row-action-highlight td,
.spider-row-action-highlight th {
  background-color: #fff5bd !important;
  z-index: 50 !important;
}
.spider-row-action-highlight td:first-child,
.spider-row-action-highlight th:first-child {
  background-color: #fff5bd !important;
  z-index: 51 !important;
}
.spider-row-action-highlight td:nth-child(2),
.spider-row-action-highlight th:nth-child(2) {
  background-color: #fff5bd !important;
  z-index: 51 !important;
}
.spider-row-action-highlight td:nth-child(3),
.spider-row-action-highlight th:nth-child(3) {
  background-color: #fff5bd !important;
  z-index: 51 !important;
}
  /* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
        /* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
      /* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
  border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 85px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 110px;
  max-width: 110px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 105px;
  max-width: 105px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 80px;
  max-width: 80px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 100px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 100px;
  max-width: 100px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(18) {
  min-width: 100px;
  max-width: 110px;
}

@media (min-width: 600px) and (max-width: 900px) {
  #order-listing {
    table-layout: auto !important; /* Let columns auto-fit content */
    width: 100% !important;
    min-width: unset !important;
    max-width: 100vw !important;
  }
  /* Adjust width for all headings (th) and cells (td) */
  #order-listing th,
  #order-listing td {
    min-width: 160px !important;
    max-width: 260px !important;
    width: 180px !important;
  }
  #order-listing th {
    position: relative;
    padding-right: 48px !important; /* More space for filter icon */
    white-space: normal !important;
    overflow: visible !important;
    text-overflow: ellipsis;
  }
  #order-listing th .fa-filter {
    position: absolute;
    right: 18px !important;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
    background: transparent;
    pointer-events: auto;
  }
}
/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 94px 175px 150px !important;
  gap: 0px !important;
  max-height: 300px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding-right: 10px;
  margin-top: 10px;
  border: 1px solid #ddd;
}

#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* For the 4-column layout (with validation status) */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 50px 1fr 100px 140px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
 
/* Styling individual grid cells, only inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #f7f7f7;
  padding: 8px 12px;
  font-size: 12px;
  border: 1px solid #ddd;
  margin: 0; /* reset any margin from <p> or others */
}
 
/* S.no column specific styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 600;
  padding: 8px 4px; /* Reduced horizontal padding for S.no */
}
 
/* For mobile responsiveness */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 80px 100px !important;
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 2px; /* Further reduced padding on mobile */
    font-size: 11px;
  }
}
 
/* For very small screens */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 30px 1fr 70px 90px !important;
  }
}
      /* Lot ID Colors for Tray Table */
.lot-color-1 { background-color: #e8f5e8 !important; } /* Light Green */
.lot-color-2 { background-color: #e3f2fd !important; } /* Light Blue */
.lot-color-3 { background-color: #fff3e0 !important; } /* Light Orange */
.lot-color-4 { background-color: #f3e5f5 !important; } /* Light Purple */
.lot-color-5 { background-color: #fff8e1 !important; } /* Light Yellow */
.lot-color-6 { background-color: #ffebee !important; } /* Light Red */

/* Color legend styling */
.lot-legend {
  margin-top: 10px; 
  font-size: 12px; 
  display: flex; 
  gap: 10px; 
  flex-wrap: wrap;
}

.lot-legend span {
  padding: 2px 8px; 
  border-radius: 4px; 
  border: 1px solid #ccc;
  font-weight: bold;
}
/* Modal Base Styles */
.right-slide-modal {
  position: fixed;
  top: 0;
  right: -100%;
  width: 100%;
  max-width: 650px;
  height: 100%;
  background: #ffffff;
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
  transition: right 0.4s ease, opacity 0.3s ease;
  z-index: 10500;
  overflow-y: auto;
  font-family: 'Segoe UI', sans-serif;
  border-radius: 16px 0 0 16px;
}

.right-slide-modal.open {
  right: 0 !important;
  opacity: 1;
}

.right-slide-modal:not(.open) {
  opacity: 0;
}

.right-slide-modal.minimized {
  right: 0 !important;
  width: 350px !important;
  max-width: 350px !important;
  height: 60px !important;
  min-height: 60px !important;
  overflow: hidden;
  border-radius: 16px 0 0 0;
  transition: width 0.3s, height 0.3s;
  padding: 0 !important;
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed !important;
  top: 20px !important;
  z-index: 10500 !important;
}

.right-slide-modal.minimized .right-slide-content {
  width: 100%;
  height: 100%;
  padding: 8px 16px !important;
  display: flex;
  align-items: center;
  justify-content: center;
}

.right-slide-modal.minimized .modal-header {
  display: flex !important;
  align-items: center;
  justify-content: space-between !important;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

.right-slide-modal.minimized .modal-header h3 {
  font-size: 14px !important;
  margin: 0;
  flex: 1;
  text-align: left !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.right-slide-modal.minimized .close-btn {
  display: block !important;
  font-size: 18px !important;
  margin-left: 10px;
  flex-shrink: 0;
}

.right-slide-modal.minimized .modal-actions,
.right-slide-modal.minimized .form-section,
.right-slide-modal.minimized .model-slider-wrapper,
.right-slide-modal.minimized h4 {
  display: none !important;
}

.right-slide-modal.minimized .tray-table,
.right-slide-modal.minimized .action-buttons,
.right-slide-modal.minimized #selectedItemsStatus {
  display: none !important;
}

/* Modal Content */
.right-slide-content {
  padding: 24px;
}

/* Modal Header */
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h3 {
  font-size: 18px;
  margin: 0;
}

.highlight {
  color: #028084;
}

.close-btn {
  font-size: 26px;
  text-decoration: none;
  color: #666;
  cursor: pointer;
}

.close-btn:hover {
  color: red;
}

/* Modal Actions */
.modal-actions {
  display: flex;
  gap: 10px;
  align-items: center;
  margin: 20px 0;
  flex-wrap: wrap;
}

.btn-action {
  padding: 6px 14px;
  border: none;
  border-radius: 20px;
  font-size: 13px;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
}

.btn-action:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn-action.blue { 
  background-color: #0378bd; 
}

.btn-action.teal { 
  background-color: #02b4a8; 
}

.cycle-status {
  background: #e6f9fa;
  padding: 6px 14px;
  border-radius: 20px;
  color: #017d7a;
  font-size: 13px;
}

/* Form Section in Modal */
.form-section {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 10px !important;
  margin-bottom: 20px;
}

.form-group {
  display: flex;
  flex-direction: column;
  margin-bottom: 0.5rem !important;
}

.form-group label {
  font-size: 13px;
  margin-bottom: 4px;
  color: #555;
}

.form-group input {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
  background: #f9f9f9;
  font-size: 13px;
}

/* QR validation error styling */
.qr-validation-error {
  color: #dc3545;
  font-size: 12px;
  margin-top: 4px;
  font-weight: 500;
}

/* UPDATED: Tray Table in Modal - Changed to 2 columns */

.tray-table {
  position: sticky;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0px;
  margin: 5px 0;
  border: 1px solid #ddd;
  border-radius: 6px;
  max-height: 110px;           /* Set a max height for scroll */
  overflow-y: auto !important; /* Enable vertical scroll */
  overflow-x: hidden !important;
  scrollbar-width: thin;       /* Firefox */
  scrollbar-color: #b0b0b0 #f5f5f5; /* Firefox */
}
/* Make the first two grid items (headers) sticky */
.tray-table > div:nth-child(1),
.tray-table > div:nth-child(2) {
  position: sticky;
  top: 0;
  z-index: 2;
  background: #d1f2f3 !important;
  font-weight: bold;
  color: #028084;
  border-bottom: 2px solid #b0b0b0;
}

/* Chrome, Edge, Safari */
.tray-table::-webkit-scrollbar {
  width: 6px;
}
.tray-table::-webkit-scrollbar-thumb {
  background: #b0b0b0;
  border-radius: 4px;
}
.tray-table::-webkit-scrollbar-track {
  background: #f5f5f5;
  border-radius: 4px;
}


.tray-table > div {
  background: #f0fdfc;
  border: 1px solid #d1d1d1;
  padding: 8px;
  font-size: 13px;
  text-align: center;
}

.tray-table > div:nth-child(-n+2) { /* Changed from -n+3 to -n+2 */
  position: sticky;
  background: #d1f2f3 !important;
  font-weight: bold;
  color: #028084;
}


/* Status indicator styling */
#selectedItemsStatus {
  animation: fadeIn 0.3s ease;
  margin: 15px 0;
  padding: 10px;
  background: #f8f9fa;
  border-radius: 6px;
  font-size: 14px;
  color: #666;
  display: none;
}

/* Action Buttons in Modal */
.action-buttons {
  display: flex;
  flex-wrap: nowrap;
  gap: 12px;
  margin-top: 20px;
}

.action-buttons button {
  flex: 1 1 calc(50% - 6px);
  padding: 10px;
  border: none;
  border-radius: 30px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
}

.btn-twitter { 
  background-color: #028084a8; 
  color: white; 
}

.btn-success { 
  background-color: #28a745; 
  color: white; 
}

.btn-warning { 
  background-color: #ffc107; 
  color: #000; 
}

.btn-danger { 
  background-color: #dc3545; 
  color: white; 
}

/* Animations for Modal */
@keyframes fadeIn {
  from { 
    opacity: 0; 
    transform: translateY(-10px); 
  }
  to { 
    opacity: 1; 
    transform: translateY(0); 
  }
}

/* Toast animations */
@keyframes slideInToast {
  from { 
    opacity: 0; 
    transform: translateX(100%); 
  }
  to { 
    opacity: 1; 
    transform: translateX(0); 
  }
}

@keyframes slideOutToast {
  from { 
    opacity: 1; 
    transform: translateX(0); 
  }
  to { 
    opacity: 0; 
    transform: translateX(100%); 
  }
}

/* Modal message animations */
@keyframes slideInMessage {
  from { 
    opacity: 0; 
    transform: translateY(-10px); 
  }
  to { 
    opacity: 1; 
    transform: translateY(0); 
  }
}

@keyframes slideOutMessage {
  from { 
    opacity: 1; 
    transform: translateY(0); 
  }
  to { 
    opacity: 0; 
    transform: translateY(-10px); 
  }
}

/* Filter indicator animation */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* Model Slider in Modal */
.model-slider-wrapper {
  position: relative;
  margin-bottom: 20px;
}

.slider-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.1);
  border: none;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  color: #666;
  z-index: 10;
  display: none;
}

.prev-btn {
  left: 4px;
}

.next-btn {
  right: 4px;
}

.model-slider-container {
  overflow: hidden;
  margin: 0 40px;
}

.model-slider {
  display: flex;
  transition: transform 0.3s ease;
  gap: 12px;
}

.model-loaded-item {
  min-width: 160px;
  flex: 0 0 auto;
  margin-right: 12px;
  display: flex;
  align-items: center;
  background: linear-gradient(135deg, #e8f5e8 0%, #fff5bd 100%);
  border: 2px solid #28a745;
  border-radius: 12px;
  padding: 12px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Responsive Design for Modal */
@media (max-width: 600px) {
  .right-slide-content {
    padding: 16px;
  }
  
  .tray-table {
    grid-template-columns: 1fr;
  }
  
  .form-section {
    grid-template-columns: 1fr;
  }
  
  .action-buttons button {
    flex: 1 1 100%;
  }
}
</style>

<div class="content-wrapper">
   <div class="col-12 grid-margin stretch-card">
      <div class="card">
         <div class="card-body" style="padding-bottom:12px;">
            <h5 class="text-left mt-0 mb-4" style="font-weight:700;">Spider Spindle Pick Table</h5>
            <div class="table-responsive" style="overflow: scroll !important">
              <table id="order-listing" class="table">
                <thead>
                  <tr>
                    <th>
                      S.No <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Last<br>Updated
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                       Plating <br> Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polishing Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating Color
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polish Finish
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                   
                    <th>
                      Version <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Source - Location
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Tray Cate- <br> Capacity
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      No of Trays <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Jig Type Capacity 
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      IP Info<i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Process Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Action <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Current <br> Stage
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                  </tr>
                </thead>
              <tbody>
                {% for data in master_data %}
                <tr class="highlighted-tray-scan" data-stock-lot-id="{{ data.stock_lot_id }}">
                  <td>
                      <div style="display: flex; align-items: center; gap: 8px;">
                          <input type="checkbox" 
                                class="model-select-checkbox" 
                                data-model-no="{{ data.model_stock_no__model_no }}" 
                                data-stock-lot-id="{{ data.stock_lot_id }}"
                                data-img-url="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}"
                                style="display: none;" />                       
                      </div>
                        <span style="display:flex; align-items:center; gap:3px;">
                    {% if is_admin %}
                      <!-- Admin users: Show toggle switch -->
                      <label class="hold-toggle-switch" style="margin-bottom:0;">
                        {% if not data.spider_hold_lot %}
                          <input type="checkbox" class="hold-toggle-btn" checked />
                          <span class="hold-slider"></span>
                        {% else %}
                          <input type="checkbox" class="hold-toggle-btn" />
                          <span class="hold-slider"></span>
                        {% endif %}
                      </label>
                      <!-- Hold remark icon -->
                      <span class="hold-remark-icon" 
                            style="display:{% if data.spider_hold_lot or data.spider_release_lot or data.spider_holding_reason or data.spider_release_reason %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
                            title="{% if data.spider_holding_reason %}Holding Reason: {{ data.spider_holding_reason }}{% endif %}{% if data.spider_holding_reason and data.spider_release_reason %}&#10;{% endif %}{% if data.spider_release_reason %}Release Reason: {{ data.spider_release_reason }}{% endif %}">
                        {% if data.spider_hold_lot or data.spider_release_lot or data.spider_holding_reason or data.spider_release_reason %}
                          <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
                        {% endif %}
                      </span>
                    {% else %}
                      <!-- Non-admin: Only show view icon if there's a holding/release reason -->
                      {% if data.spider_hold_lot or data.spider_release_lot or data.spider_holding_reason or data.spider_release_reason %}
                        <span class="hold-remark-icon" 
                              style="display:inline-block; cursor:pointer;" 
                              title="{% if data.spider_holding_reason %}Holding Reason: {{ data.spider_holding_reason }}{% endif %}{% if data.spider_holding_reason and data.spider_release_reason %}&#10;{% endif %}{% if data.spider_release_reason %}Release Reason: {{ data.spider_release_reason }}{% endif %}">
                          <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
                        </span>
                      {% endif %}
                    {% endif %}
                    <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>

                  </span>

                  </td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                    {{ data.na_last_process_date_time|date:"d-M-y" }}<br>
                    <span style="display:inline-block; margin-top:4px;word-break: break-all;">{{ data.na_last_process_date_time|date:"h:i A" }}</span>
                  </td>
                  <!-- Model/Stock No - Image hover -->  
                <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
                        {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                        <div class="model-image-tooltip" style="position: absolute; left: 80%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s; min-width: 220px;">
                          
                          <!-- Header with Info and Close buttons -->
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <button class="info-btn" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Info
                            </button>
                            <button class="close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Close
                            </button>
                          </div>
                          
                          <!-- Image gallery section -->
                          <div style="display: flex; align-items: center; gap: 8px;">
                            <!-- Hide scroll buttons since only one image is shown -->
                            <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                              <img src="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                            </div>
                          </div>
                        </div>
                      </span>
                    </td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no }}</td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polish_finish }}</td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.version__version_internal }}</td>             
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.location__location_name }}</td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.tray_type }} {{ data.tray_capacity }}</td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.no_of_trays }}</td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                    <input type="number"
                          class="edit-qty-input"
                          value="{{ data.display_qty|default:0 }}"
                          data-batch-id="{{ data.batch_id }}"
                          style="width: 60px; padding: 2px 6px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;"
                          readonly />
                  </td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                      {{data.jig_type}} - {{data.jig_capacity}}
                  </td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="mobile-cross-icon" title="Item removed" style="cursor: pointer; display: inline-flex; align-items: center;">
                          <i class="fa fa-mobile" aria-hidden="true" style="font-size:25px; color: #028084; font-weight: 900;" data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Jig"></i>
                      </span>
                  </td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                    <div class="d-flex">
                      <div
                        title="Tray Scan"
                        class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                        style="
                          width: 20px;
                          height: 20px;
                          color: white;
                          font-weight: bold;
                          line-height: 20px;
                          text-align: center;
                          padding-top: 1px;
                          padding-right: 1px;
                          {% if data.batch_status.status == 'Yet to Start' %}
                            background: #bdbdbd; /* gray */
                          {% elif data.batch_status.status == 'Draft' %}
                            background: linear-gradient(90deg, #0c8249 50%, #bdbdbd 50%); /* half green, half gray */
                          {% elif data.batch_status.status == 'Yet to Release' or data.batch_status.status == 'Released' %}
                            background: #0c8249; /* full green */
                          {% else %}
                            background: #bdbdbd; /* default gray */
                          {% endif %}
                        "
                      >
                        L
                      </div>
                    </div>
                  </td>
                  <!-- Action buttons cell -->
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>

                    <a href="#" class="jig-delete-batch-btn" data-stock-lot-id="{{ data.stock_lot_id }}" title="Delete"
                      {% if data.batch_status.status == "Yet to Release" or data.batch_status.status == "Released" %}
                        style="pointer-events: none; opacity: 0.5;"
                        tabindex="-1"
                        aria-disabled="true"
                      {% endif %}
                    >
                      <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
                    </a>
                    
                    <!-- Add Jig button section -->
                    {% if data.batch_status.status == 'Yet to Release' %}
                        <button
                            type="button"
                            class="btn btn-social-icon-text btn-twitter"
                            style="background-color: #028084a8; cursor: not-allowed;"
                            disabled
                        >
                            <i class="fa fa-check"></i>Added
                        </button>
                    {% else %}
                        <a href="#rightSideModal" class="open-jig-modal-btn" data-stock-lot-id="{{ data.stock_lot_id }}">
                            <button
                                type="button"
                                class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #028084a8"
                            >
                                <i class="fa fa-plus"></i>Add Jig
                            </button>
                        </a>

                    {% endif %}
<!-- CORRECTED -->
<a href="#"
   title="View"
   class="text-primary tray-scan-btn-BQ-view tray-scan-btn-Jig"
   style="text-decoration: underline"
   data-stock-lot-id="{{ data.stock_lot_id }}"
   data-batch-id="{{ data.batch_id }}"
   data-model-no="{{ data.plating_stk_no }}"
   data-no-of-trays="{{ data.no_of_trays }}"
   data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
   data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
   data-model-image="{{ data.model_images.0|default:'' }}"
   data-total-batch-quantity="{{ data.display_qty|default:0 }}"
   data-physical-qty="{{ data.na_physical_qty|default:0 }}"
   data-missing-qty="{{ data.na_missing_qty|default:0 }}"
   data-na-qc-accptance="{{ data.na_qc_accptance|yesno:'true,false' }}"
   data-na-qc-rejection="{{ data.na_qc_rejection|yesno:'true,false' }}"
   data-na-qc-few-cases-accptance="{{ data.na_qc_few_cases_accptance|yesno:'true,false' }}">
   <img src="{% static 'assets/icons/view.png' %}"
        alt="View"
        style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;" />
</a>
                  </td>
                  <!-- Batch status cell -->
                    <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {% if not data.spider_hold_lot %}
                            <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                                style="border: 1px solid {{ data.batch_status.border_color }}; 
                                       background-color: {{ data.batch_status.bg_color }}; 
                                       color: {{ data.batch_status.color }}; 
                                       font-size: 13px; white-space: nowrap; padding: 5px;">
                              {{ data.batch_status.status }}
                            </div>
                        {% else %}
                            <div
                                class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                                style="
                                    border: 1px solid #dc3545;
                                    background-color: #f8d7da;
                                    color: #721c24;
                                    font-size: 13px;
                                    white-space: nowrap;
                                    padding: 5px;
                                ">
                              On Hold
                            </div>
                        {% endif %}
                    </td>
                    <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #d1edf3; background-color: #d1edf3; color: #033b5d; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                    </td>
                  <td {% if data.spider_hold_lot %} class="row-inactive-blur" {% endif %}>
                    <!-- VoiceRec with tooltip (audio remark) -->
                    <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                      <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                      <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
                        <!-- Audio recording UI placeholder -->
                        <div style="display: flex; align-items: center; gap: 10px;">
                          <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                            <i class="fa fa-microphone"></i>
                          </button>
                          <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                            <div style="text-align: right; margin-top: 10px;">
                          <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            <i class="fa fa-send"></i>
                          </button>
                        </div>
                        </div>
                      
                      </div>
                    </a>
                    <a
                      href="#"
                      title="Add Remark"
                      class="remark-tooltip-trigger"
                      style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; position: relative; cursor: pointer;"
                    >
                      <img
                        src="{% static 'assets/icons/chat_icon.png' %}"
                        alt="Chat"
                        style="width: 20px; height: 20px; {% if data.spider_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% endif %}"
                      />
                      <div
                        class="remark-tooltip"
                        style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 300px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                      >
                      
                        <textarea
                          placeholder="Type your remark..."
                          style="width: 85%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                          {% if data.spider_pick_remarks %}readonly{% endif %}
                        >{{ data.spider_pick_remarks|default_if_none:"" }}</textarea>
                        <div style="text-align: right; margin-top: -35px">
                          {% if not data.spider_pick_remarks %}
                          <button
                            type="button"
                            style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                          >
                            <i class="fa fa-send"></i>
                          </button>
                          {% else %}
                          <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                            <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                            Remark already saved and cannot be edited.
                          </div>
                          {% endif %}
                        </div>
                      </div>
                    </a>
                  </td>
                </tr>
              {% endfor %}
              </tbody>
              </table>

              <!-- Enhanced Right Slide-in Modal -->
              <div id="rightSideModal" class="right-slide-modal">
                <div class="right-slide-content">
                  
                  <!-- Header with close button -->
                  <div class="modal-header">
                    <h3 style="width: 100%; text-align: center;">
                      Jig Loading / Model No: <span class="highlight" id="rightModalModelNo">-</span>
                    </h3>
                    <a href="#" class="close-btn" title="Close Modal">&times;</a>
                  </div>

                  <!-- Top Actions -->
                  <div class="modal-actions">
                    <a class="nav-link btn-action blue" id="jig-composition-link" href="#">Jig Composition</a>
                    <button type="button" class="btn-action teal">Add Model</button>
                    <div class="cycle-status" id="cycleStatusDisplay">
                        No of Cycle: <strong id="cycleCount">-/-</strong>
                        <span id="cycleAlertMessage" style="display: none; margin-left: 8px;">
                            <span class="cycle-alert-badge">
                                <i class="fa fa-exclamation-triangle" style="margin-right: 3px; font-size: 10px;"></i>
                                <span id="cycleAlertText">Alert</span>
                            </span>
                        </span>
                    </div>
                  </div>

                  <!-- Form Fields -->
                  <div class="form-section" style="grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 20px;">
                    <div class="form-group">
                      <label>Jig QR ID</label>
                      <input type="text" placeholder="Enter Jig QR ID" id="modalJigQrId" />
                    </div>
                    <div class="form-group">
                      <label>Bath Type</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalBathType" />
                    </div>
                    <div class="form-group">
                      <label>Faulty Slots</label>
                      <input type="number" placeholder="Enter Faulty Slots" id="modalFaultySlots" min="0" />
                    </div>
                    <div class="form-group">
                      <label>Empty Slots</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalEmptySlots" />
                    </div>
                    <div class="form-group">
                      <label>Lot Qty</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalLotQty" />
                    </div>
                    <div class="form-group">
                      <label>Jig Capacity</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalJigCapacity" />
                    </div>
                  </div>

                  <!-- Model Slider Section -->
                  <h4>No of Model Loaded:</h4>
                  <div class="model-slider-wrapper" style="position: relative; margin-bottom: 20px;">
                    <button class="slider-btn prev-btn" style="position: absolute; top: 50%; transform: translateY(-50%); left: 4px; background: rgba(0,0,0,0.1); border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; color: #666; z-index: 10; display: none;">&#10094;</button>
                    <div class="model-slider-container" style="overflow: hidden; margin: 0 40px;">
                      <div class="model-slider" id="modelSliderDynamic" style="display: flex; transition: transform 0.3s ease; gap: 12px;">
                        <!-- Dynamic model items will be injected here -->
                      </div>
                    </div>
                    <button class="slider-btn next-btn" style="position: absolute; top: 50%; transform: translateY(-50%); right: 4px; background: rgba(0,0,0,0.1); border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; color: #666; z-index: 10; display: none;">&#10095;</button>
                  </div>

                  <!-- UPDATED: De-link Tray Section - Only 2 columns -->
                  <h4>De-link Tray:</h4>
                  <div class="tray-table" id="delinkTrayTable">
                    <!-- UPDATED: Only 2 column headers -->
                    <div style="background: #d1f2f3; font-weight: bold;">S.No</div>
                    <div style="background: #d1f2f3; font-weight: bold;">Tray ID</div>
                    <!-- Dynamic tray rows will be injected here -->
                  </div>

                  <div id="halfFilledTraySection" style="display: none;">
                    <h4>Half Filled Tray to be Scan:</h4>
                    <div class="tray-table" id="halfFilledTrayTable">
                      <div style="background: #d1f2f3; font-weight: bold;">Tray ID</div>
                      <div style="background: #d1f2f3; font-weight: bold;">Tray Quantity</div>
                      <!-- Dynamic rows will be injected by JavaScript -->
                    </div>
                  </div>
                  

                  <!-- Status indicator for selected items -->
                  <div id="selectedItemsStatus" style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 14px; color: #666; display: none;">
                    <strong>Selected Items:</strong> <span id="selectedCount">0</span> items selected
                  </div>

                  <!-- Footer Buttons -->
                  <div class="action-buttons">
                    <button class="btn-twitter">Add Jig</button>
                    <button class="btn-success">Submit</button>
                    <button class="btn-warning">Draft</button>
                    <button class="btn-danger">Cancel</button>
                  </div>
                </div>
              </div>

              <!-- Tray Scan Modal -->
                <div id="trayScanModal_DayPlanning" class="tray-scan-modal-DayPlanning"style="display:none"> 
                  <div class="tray-scan-modal-DayPlanning-content">
                    <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly">&times;</span>
                    
                    <div class="modal-top-header" style="display: flex; align-items: center; gap: 20px; padding-bottom: 10px;">
                      <div class="user-profile" style="display: flex; align-items: center; gap: 8px">
                        <img src="/static/assets/images/imagePlaceholder.png" alt="User Profile" style="border-radius: 50%; width: 50px; height: 50px; object-fit: cover;" />
                        <!-- Model No and Lot Qty in same line -->
                        <div style="display: flex; flex-direction: column; gap: 2px;">
                          <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                              <span style="font-weight: bold; color: #666;">Model No:</span>
                              <h6 id="modalModelNo_DayPlanning" style="margin: 0; color: #028084; font-weight: bold;">(Fetch Dynamically)</h6>
                            </div>
                          <h7 style="margin: 0; color: #666666; font-weight: bold;">
                              Lot Qty: <span id="modalLotQty_DayPlanning" style="font-weight:bold; color:#e67e22;"></span>
                          </h7>
                          </div>
                            
                        </div>
                      </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                      <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                        Spider Spindle - Tray Scan 
                      </h5>
                      <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
                        
                        Tray Validate
                      </button>
                      <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
                      <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="trayScanRedoBtn" style="width: 24px; height: 24px; cursor: pointer; margin-left: 8px;" title="Clear Tray IDs" />
                    </div>
                    <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
                      <span id="trayErrorText"></span>
                    </div>
                    <div id="trayScanDetails_DayPlanning" class="table-grid">
                      <!-- Headers and dynamic content will be injected here -->
                    </div>
                  </div>
                </div>           
            </div>
          </div>
            <!-- Pagination Section -->

            <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>â€¦</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>â€¦</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
     </div>
   </div>
</div>

  <!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
  <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
    <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
    <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
    <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
    <div style="text-align:right; margin-top:10px;">
      <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
    </div>
    <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
  </div>
</div>
</div>

{% block script %}

<!-- Active row to be highlighted & Restores the highlighted row to its original position and removes the highlight bg when the tray scan modal is closed. -->
<script nonce="{{ csp_nonce }}">
// Row highlight for Tray Scan (matches highlightWF.html logic) + Move active row to top and restore on close
document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('dp-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'dp-row-action-highlight-style';
    style.innerHTML = `
      .dp-row-action-highlight {
        transition: box-shadow 1.3s;
        background-color: #fff5bd !important;
        animation: highlightAnimation 2s ease-in-out;
      }
    `;
    document.head.appendChild(style);
  }

  // Use a single set of variables for both tray-scan-btn and tray-scan-btn-Jig and Add Jig
  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  // Highlight and move row for .tray-scan-btn, .tray-scan-btn-Jig, .open-jig-modal-btn, and checked checkboxes
  function highlightAndMoveRow(row) {
    // Remove highlight from all rows
    document.querySelectorAll('tbody tr').forEach(function(r) {
      r.classList.remove('dp-row-action-highlight');
    });
    if (row && row.parentNode) {
      const tbody = row.parentNode;
      // Only move if not already at top
      if (tbody.firstElementChild !== row) {
        // If a previous move exists, restore it first
        if (movedRow && placeholderRow && placeholderRow.parentNode) {
          placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
          placeholderRow.parentNode.removeChild(placeholderRow);
          movedRow.classList.remove('dp-row-action-highlight');
          movedRow = null;
          placeholderRow = null;
          originalRowIndex = null;
        }
        // Store original index and row
        originalRowIndex = Array.from(tbody.children).indexOf(row);
        movedRow = row;
        // Insert a placeholder at the original position
        placeholderRow = document.createElement('tr');
        placeholderRow.style.display = 'none';
        // Add same number of <td> as the moved row
        for (let i = 0; i < row.children.length; i++) {
          placeholderRow.appendChild(document.createElement('td'));
        }
        tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
        // Move row to top
        tbody.insertBefore(row, tbody.firstElementChild);
      }
      row.classList.add('dp-row-action-highlight');
    }
  }

  // For tray scan/view/add jig buttons
  document.querySelectorAll('.tray-scan-btn, .tray-scan-btn-Jig, .open-jig-modal-btn').forEach(function(link) {
    link.addEventListener('click', function(event) {
      var row = event.target.closest('tr');
      highlightAndMoveRow(row);
    });
  });

  // For checked checkboxes: highlight and move row to top
  document.querySelectorAll('.model-select-checkbox').forEach(function(checkbox) {
    checkbox.addEventListener('change', function() {
      setTimeout(() => {
      const lotId = getCurrentLotId();
      if (lotId) {
        console.log('Restoring auto-save after checkbox change');
      }
    }, 500);
      if (checkbox.checked) {
        var row = checkbox.closest('tr');
        highlightAndMoveRow(row);
      } else {
        // On uncheck, remove highlight but do not move row back (keep current active row)
        if (checkbox.closest('tr')) {
          checkbox.closest('tr').classList.remove('dp-row-action-highlight');
        }
      }
    });
  });

  // On modal close, restore row to original position and remove highlight for both modals
  function restoreRowAndClearHighlight() {
    if (movedRow && placeholderRow && placeholderRow.parentNode) {
      placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
      placeholderRow.parentNode.removeChild(placeholderRow);
      movedRow.classList.remove('dp-row-action-highlight');
      movedRow = null;
      placeholderRow = null;
      originalRowIndex = null;
    }
    // Also remove highlight from any row just in case
    document.querySelectorAll('tbody tr').forEach(function(row) {
      row.classList.remove('dp-row-action-highlight');
      row.classList.remove('highlighted-tray-scan');
    });
  }

  var closeBtn = document.getElementById('closeTrayScanModal');
  if (closeBtn) {
    closeBtn.addEventListener('click', restoreRowAndClearHighlight);
  }
  var jigCloseBtn = document.getElementById('closeTrayScanModal_DayPlanning');
  if (jigCloseBtn) {
    jigCloseBtn.addEventListener('click', restoreRowAndClearHighlight);
  }
});
</script>

<script nonce="{{ csp_nonce }}">
// âœ… FIXED: Store state globally so it persists across table refreshes
window.holdToggleState = {
  currentHoldCell: null,
  intendedState: null,
  currentBatchId: null,
  currentLotId: null
};

function attachHoldToggleListeners() {
  console.log('Attaching hold toggle listeners...');

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Remove existing listeners and attach new ones
  document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
    // Remove any existing click listeners
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    
    // Add new event listener
    newBtn.addEventListener('click', function (e) {
      e.preventDefault();
      
      const holdCell = newBtn.closest('td');
      const row = holdCell.closest('tr');
      
      // âœ… Store state globally with all needed data
      window.holdToggleState = {
        currentHoldCell: holdCell,
        intendedState: newBtn.checked,
        currentBatchId: row.getAttribute('data-batch-id'),
        currentLotId: row.getAttribute('data-stock-lot-id'),
        // Store identifiers that can help us find the row after refresh
        rowIdentifier: row.getAttribute('data-stock-lot-id') || row.getAttribute('data-batch-id')
      };
      
      console.log('Hold toggle clicked, state:', window.holdToggleState);
      
      document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
        window.holdToggleState.intendedState ? 'Unholding Reason' : 'Holding Reason';
      document.getElementById('holdRemarkInput').value = '';
      document.getElementById('holdRemarkError').textContent = '';
      document.getElementById('holdRemarkModal').style.display = 'flex';
      document.getElementById('holdRemarkInput').focus();
    });
  });

  // âœ… Attach save button handler (only once globally)
  const saveBtn = document.getElementById('saveHoldRemarkBtn');
  if (saveBtn && !window.holdSaveHandlerAttached) {
    window.holdSaveHandlerAttached = true;
    
    saveBtn.onclick = function () {
      console.log('Save button clicked, current state:', window.holdToggleState);
      
      const remark = document.getElementById('holdRemarkInput').value.trim();
      if (!remark) {
        document.getElementById('holdRemarkError').textContent = 'Remark required!';
        return;
      }
      
      // âœ… Use stored state instead of current variables
      if (!window.holdToggleState.currentLotId) {
        document.getElementById('holdRemarkError').textContent = 'Lot ID not found!';
        return;
      }
    
      const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
      
      console.log('Sending request:', {
        lot_id: window.holdToggleState.currentLotId,
        remark: remark,
        action: action
      });
    
      fetch('/spider_spindle/spider_save_hold_unhold_reason/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          lot_id: window.holdToggleState.currentLotId,
          remark: remark,
          action: action
        })
      })
      .then(res => res.json())
      .then(data => {
        console.log('Server response:', data);
        
        if (data.success) {
          // âœ… Close modal first
          document.getElementById('holdRemarkModal').style.display = 'none';
          
          // âœ… Update UI immediately before refresh
          const currentRow = document.querySelector(`tr[data-stock-lot-id="${window.holdToggleState.currentLotId}"]`);
          if (currentRow) {
            const toggle = currentRow.querySelector('.hold-toggle-btn');
            const icon = currentRow.querySelector('.hold-remark-icon');
            
            if (action === 'hold') {
              if (toggle) toggle.checked = false;
              currentRow.classList.add('row-inactive');
              currentRow.querySelectorAll('td').forEach((td, idx) => {
                if (idx > 0) {
                  td.classList.add('row-inactive-blur');
                } else {
                  td.classList.remove('row-inactive-blur');
                }
              });
              if (icon) {
                icon.style.display = 'inline-block';
                icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:18px; height:18px;" />`;
                icon.setAttribute('title', 'Holding Reason: ' + remark);
              }
            } else {
              if (toggle) toggle.checked = true;
              currentRow.classList.remove('row-inactive');
              currentRow.querySelectorAll('td').forEach(td => {
                td.classList.remove('row-inactive-blur');
              });
              if (icon) {
                icon.style.display = 'none';
              }
            }
          }
          
          // âœ… Then refresh the table data
          setTimeout(() => {
            if (typeof refreshTableData === 'function') {
              refreshTableData();
            } else {
              location.reload();
            }
          }, 500);
          
        } else {
          document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
        }
      })
      .catch((error) => {
        console.error('Request failed:', error);
        document.getElementById('holdRemarkError').textContent = 'Network error!';
      });
    };
  }

  // âœ… Attach close button handler (only once globally)
  const closeBtn = document.getElementById('closeHoldRemarkModal');
  if (closeBtn && !window.holdCloseHandlerAttached) {
    window.holdCloseHandlerAttached = true;
    closeBtn.onclick = function () {
      document.getElementById('holdRemarkModal').style.display = 'none';
      // Clear the state when modal is closed
      window.holdToggleState = {
        currentHoldCell: null,
        intendedState: null,
        currentBatchId: null,
        currentLotId: null
      };
    };
  }

  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
}

// âœ… Call on page load
document.addEventListener("DOMContentLoaded", function () {
  attachHoldToggleListeners();
});
</script>

<!--No of Cycle Dynamic-->

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  console.log("ðŸ”§ Enhanced Cycle Count with Alert Messages");
  
  // Function to show/hide and style alert message
  function updateCycleAlert(cycleData) {
    const alertMessage = document.getElementById('cycleAlertMessage');
    const alertText = document.getElementById('cycleAlertText');
    const alertBadge = alertMessage ? alertMessage.querySelector('.cycle-alert-badge') : null;
    
    if (!alertMessage || !alertText || !alertBadge) {
      console.warn("âš ï¸ Alert message elements not found in HTML");
      return;
    }
    
    const nextCycle = cycleData.next_cycle;
    const status = cycleData.status;
    
    console.log(`ðŸ” Updating alert for cycle ${nextCycle}, status: ${status}`);
    
    if (status === 'warning' && nextCycle >= 31 && nextCycle <= 35) {
      // Show warning alert for cycles 31-35
      alertMessage.style.display = 'block';
      alertMessage.className = 'cycle-alert-fade-in';
      
      // Set appropriate message based on cycle range
      let alertTextContent = '';
      if (nextCycle <= 32) {
        alertTextContent = 'Maintenance Soon';
      } else if (nextCycle <= 34) {
        alertTextContent = 'Maintenance Due';
      } else {
        alertTextContent = 'Maintenance Urgent';
      }
      
      alertText.textContent = alertTextContent;
      alertBadge.className = 'cycle-alert-badge'; // Normal warning style
      alertBadge.title = `JIG has completed ${nextCycle-1} cycles. Recommended maintenance at 30 cycles.`;
      
      console.log(`âš ï¸ Alert shown: "${alertTextContent}" for cycle ${nextCycle}`);
      
    } else if (status === 'blocked') {
      // Show critical alert for cycles 36+
      alertMessage.style.display = 'block';
      alertMessage.className = 'cycle-alert-fade-in';
      
      alertText.textContent = 'Max Cycles Reached';
      alertBadge.className = 'cycle-alert-badge critical';
      alertBadge.title = `JIG has reached maximum cycles (${nextCycle-1}). Cannot be used further.`;
      
      console.log(`âŒ Critical alert shown for cycle ${nextCycle}`);
      
    } else {
      // Hide alert for normal cycles (1-30)
      alertMessage.style.display = 'none';
      console.log(`âœ… Alert hidden for normal cycle ${nextCycle}`);
    }
  }
  
  // Function to fetch and display cycle count for a jig QR ID
window.fetchAndDisplayCycleCount = function(jigQrId) {
    const cycleDisplay = document.getElementById('cycleCount');
    const cycleStatusDiv = document.getElementById('cycleStatusDisplay');
    const alertMessage = document.getElementById('cycleAlertMessage');
    
    if (!jigQrId.trim()) {
      // Reset to default when no QR ID
      cycleDisplay.textContent = '-/-';
      cycleStatusDiv.className = 'cycle-status';
      cycleStatusDiv.title = '';
      
      // Hide alert message
      if (alertMessage) {
        alertMessage.style.display = 'none';
      }
      return;
    }
    
    // Show loading state
    cycleDisplay.textContent = '...';
    console.log("ðŸ” Fetching cycle count for:", jigQrId);
    
    fetch('/spider_spindle/get_cycle_count/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        jig_qr_id: jigQrId
      })
    })
    .then(response => {
      console.log("ðŸ“¡ API Response Status:", response.status);
      return response.json();
    })
    .then(data => {
      console.log("ðŸ“Š API Response Data:", data);
      
      if (data.success) {
        // Update cycle display
        cycleDisplay.textContent = data.display_text;
        console.log("âœ… Cycle updated to:", data.display_text);
        
        // Update alert message
        updateCycleAlert(data);
        
        // Apply styling based on status
        cycleStatusDiv.className = 'cycle-status';
        cycleStatusDiv.title = data.message;
        
        // Apply visual styling based on status
        if (data.status === 'warning') {
          cycleStatusDiv.style.background = '#fff3cd';
          cycleStatusDiv.style.borderColor = '#ffc107';
          cycleStatusDiv.style.color = '#856404';
          console.log("âš ï¸ Warning status applied");
        } else if (data.status === 'blocked') {
          cycleStatusDiv.style.background = '#f8d7da';
          cycleStatusDiv.style.borderColor = '#dc3545';
          cycleStatusDiv.style.color = '#721c24';
          console.log("âŒ Blocked status applied");
          
          // Disable save buttons
          document.querySelectorAll('.action-buttons button').forEach(btn => {
            if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
              btn.disabled = true;
              btn.style.opacity = '0.5';
              btn.title = 'Cannot save - Maximum cycles exceeded';
            }
          });
        } else {
          // Normal status - reset styling
          cycleStatusDiv.style.background = '#e6f9fa';
          cycleStatusDiv.style.borderColor = '#02b4a8';
          cycleStatusDiv.style.color = '#017d7a';
          console.log("âœ… Normal status applied");
          
          // Enable save buttons
          document.querySelectorAll('.action-buttons button').forEach(btn => {
            if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
              btn.disabled = false;
              btn.style.opacity = '1';
              btn.title = '';
            }
          });
        }
        
      } else {
        // Error case
        cycleDisplay.textContent = 'Error';
        cycleStatusDiv.title = data.error || 'Failed to get cycle count';
        
        // Hide alert on error
        if (alertMessage) {
          alertMessage.style.display = 'none';
        }
        
        console.error("âŒ API Error:", data.error);
      }
    })
    .catch(error => {
      console.error('âŒ Network Error:', error);
      cycleDisplay.textContent = 'Error';
      cycleStatusDiv.title = 'Network error while fetching cycle count';
      
      // Hide alert on error
      if (alertMessage) {
        alertMessage.style.display = 'none';
      }
    });
  }
  
  // Enhanced JIG QR ID validation with cycle count fetching
  const jigQrInput = document.getElementById('modalJigQrId');
  if (jigQrInput) {
    let cycleTimeout;
    
    jigQrInput.addEventListener('input', function() {
      const qrId = this.value.trim();
      
      // Clear previous timeout
      clearTimeout(cycleTimeout);
      
      // Debounce cycle count fetching
      cycleTimeout = setTimeout(() => {
        fetchAndDisplayCycleCount(qrId);
      }, 300);
    });
    
    // Also fetch cycle count when modal opens with existing QR ID
    if (jigQrInput.value.trim()) {
      fetchAndDisplayCycleCount(jigQrInput.value.trim());
    }
  }
  
  // Reset cycle display and alert when modal closes
  document.querySelectorAll('.close-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      const cycleDisplay = document.getElementById('cycleCount');
      const cycleStatusDiv = document.getElementById('cycleStatusDisplay');
      const alertMessage = document.getElementById('cycleAlertMessage');
      
      if (cycleDisplay) {
        cycleDisplay.textContent = '-/-';
      }
      if (cycleStatusDiv) {
        cycleStatusDiv.className = 'cycle-status';
        cycleStatusDiv.style.background = '';
        cycleStatusDiv.style.borderColor = '';
        cycleStatusDiv.style.color = '';
        cycleStatusDiv.title = '';
      }
      if (alertMessage) {
        alertMessage.style.display = 'none';
      }
    });
  });
  
  console.log("ðŸš€ Enhanced cycle count with alerts ready!");
});
</script>

<!-- Script for View Icon Tray validate -->

  <script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (redoBtn && validateInput && detailsDiv) {
    redoBtn.addEventListener("click", function () {
      // Hide and clear the input
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset Tray Validate button to normal state
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }

      // Reset all icons in the validation status column (read-only modal)
      // For table layout:
      const rows = detailsDiv.querySelectorAll("tbody tr");
      if (rows.length > 0) {
        rows.forEach(row => {
          const statusCell = row.querySelector("td:last-child");
          if (statusCell) {
            statusCell.innerHTML = `
              <div class="validation-status">
                <div class="status-icon fail">
                  <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                </div>
                <div class="status-icon pass">
                  <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                </div>
              </div>
            `;
          }
        });
      } else {
        // For grid layout (if used)
        detailsDiv.querySelectorAll('.tray-validation-status-header, .tray-validation-status-cell').forEach(cell => {
          cell.innerHTML = `
            Tray Validation Status
            <span style="margin-left: 10px;">
              <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
            </span>
          `;
        });
      }
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const validateBtn = document.getElementById("trayValidateBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (validateBtn && validateInput) {
    validateBtn.addEventListener("click", function () {
      validateInput.value = "";
      
      // Hide error message when starting new validation
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Change button to active state (green color)
      validateBtn.style.background = "#e8f5e8";
      validateBtn.style.borderColor = "#4caf50";
      validateBtn.style.color = "#2e7d32";
      
      // Add the 4th column to the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table with validation column
        detailsDiv.innerHTML = modal.buildTableHTML(true);
      }
      
      // Focus the hidden input so it can receive keystrokes
      validateInput.focus();
    });
  }
  
  if (redoBtn && validateInput) {
    redoBtn.addEventListener("click", function () {
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset button to normal state (original blue color)
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
      
      // Remove the 4th column from the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table without validation column
        detailsDiv.innerHTML = modal.buildTableHTML(false);
      }
      
      redoBtn.focus();
    });
  }
});
</script>


<script nonce="{{ csp_nonce }}">
// Updated Tray Validation Script with Stock Status Support and Enhanced Error Handling
document.addEventListener("DOMContentLoaded", function () {
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");
  const errorText = document.getElementById("trayErrorText");

  console.log("ðŸ” Tray validation script loaded");
  console.log("ðŸ“‹ Elements found:", {
    validateInput: !!validateInput,
    detailsDiv: !!detailsDiv,
    errorMessage: !!errorMessage,
    errorText: !!errorText
  });

  function getCurrentStockLotId() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.dataset.stockLotId) return modal.dataset.stockLotId;
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-stock-lot-id]');
    return lastBtn ? lastBtn.getAttribute('data-stock-lot-id') : '';
  }

  function getCurrentStockStatus() {
    // Get stock status from the last clicked button
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-stock-lot-id]');
    if (lastBtn) {
      return {
        accepted_ip_stock: lastBtn.getAttribute('data-accepted-ip-stock') === 'true',
        rejected_ip_stock: lastBtn.getAttribute('data-rejected-ip-stock') === 'true',
        few_cases_accepted_ip_stock: lastBtn.getAttribute('data-few-cases-accepted-ip-stock') === 'true'
      };
    }
    return {
      accepted_ip_stock: false,
      rejected_ip_stock: false,
      few_cases_accepted_ip_stock: false
    };
  }

  function showError(message) {
    console.log("ðŸš¨ Showing error:", message);
    if (errorMessage && errorText) {
      errorText.textContent = message;
      
      // Force display with important styles
      errorMessage.style.setProperty('display', 'block', 'important');
      errorMessage.style.setProperty('visibility', 'visible', 'important');
      errorMessage.style.setProperty('opacity', '1', 'important');
      errorMessage.style.setProperty('z-index', '99999', 'important');
      errorMessage.style.setProperty('position', 'relative', 'important');
      errorMessage.style.setProperty('background-color', '#ffebee', 'important');
      errorMessage.style.setProperty('border', '1px solid #f44336', 'important');
      errorMessage.style.setProperty('color', '#c62828', 'important');
      errorMessage.style.setProperty('padding', '8px 12px', 'important');
      errorMessage.style.setProperty('border-radius', '4px', 'important');
      errorMessage.style.setProperty('margin-bottom', '10px', 'important');
      errorMessage.style.setProperty('font-size', '12px', 'important');
      errorMessage.style.setProperty('text-align', 'center', 'important');
      errorMessage.style.setProperty('width', '100%', 'important');
      
      console.log("âœ… Error message styled");
      
      // Scroll to error message if it exists
      errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      // Flash the background to make it more noticeable
      let flashCount = 0;
      const flashInterval = setInterval(() => {
        if (flashCount < 6) {
          errorMessage.style.backgroundColor = flashCount % 2 === 0 ? '#ffcdd2' : '#ffebee';
          flashCount++;
        } else {
          clearInterval(flashInterval);
          errorMessage.style.backgroundColor = '#ffebee';
        }
      }, 200);
      
      console.log("âœ… Error message displayed");
      
      // Auto-hide after 8 seconds
      setTimeout(() => {
        errorMessage.style.display = "none";
        console.log("â° Auto-hiding error message after 8 seconds");
      }, 8000);
    } else {
      console.log("âŒ Error message elements not found!");
      // Fallback: show alert if error div not found
      alert(message);
    }
  }

  function hideError() {
    console.log("ðŸ«¥ Hiding error message");
    if (errorMessage) {
      errorMessage.style.display = "none";
    }
  }

  if (validateInput && detailsDiv) {
    console.log("ðŸŽ¯ Setting up tray validation event listener");
    
    // Add input event listener for real-time feedback
    validateInput.addEventListener("input", function(e) {
      console.log("âŒ¨ï¸ User typing:", e.target.value);
    });
    
    validateInput.addEventListener("keydown", function (e) {

      // Get brass QC status from the modal or last clicked tray-scan-btn-Jig
      const modal = document.getElementById("trayScanModal_DayPlanning");
      let brassQcAccptance = false;
      let brassQcRejection = false;
      let brassQcFewCasesAccptance = false;
      
      // Try to get from modal dataset if set
      if (modal) {
        brassQcAccptance = modal.getAttribute('data-brass-qc-accptance') === 'true';
        brassQcRejection = modal.getAttribute('data-brass-qc-rejection') === 'true';
        brassQcFewCasesAccptance = modal.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
      }
      
      // If not set, fallback to last clicked tray-scan-btn-Jig
      if (!brassQcAccptance && !brassQcRejection && !brassQcFewCasesAccptance) {
        const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-stock-lot-id]');
        if (lastBtn) {
          brassQcAccptance = lastBtn.getAttribute('data-brass-qc-accptance') === 'true';
          brassQcRejection = lastBtn.getAttribute('data-brass-qc-rejection') === 'true';
          brassQcFewCasesAccptance = lastBtn.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
        }
      }
      console.log("ðŸ”‘ Key pressed:", e.key, "Value:", validateInput.value.trim());
      
      if (e.key === "Enter") {
        const trayId = validateInput.value.trim();
        console.log("ðŸŽ¯ Enter pressed with tray ID:", trayId);
        
        if (!trayId) {
          console.log("âš ï¸ Empty tray ID, returning");
          return;
        }
        
        const stockLotId = getCurrentStockLotId();
        console.log("ðŸ“¦ Current stock lot ID:", stockLotId);
        
        if (!stockLotId) {
          console.log("âŒ No stock lot ID found");
          showError("Stock lot ID not found. Please refresh and try again.");
          return;
        }

        const stockStatus = getCurrentStockStatus();
        console.log("ðŸ“Š Stock status:", stockStatus);

        // Hide any existing error message
        hideError();
        console.log("ðŸ”„ Making API call to validate tray...");

        // Include stock status in the validation request
        const requestData = {
          stock_lot_id: stockLotId,
          tray_id: trayId,
          ...stockStatus
        };

        fetch("/spider_spindle/jig_tray_validate/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": getCookie('csrftoken')
          },
          body: JSON.stringify({
            stock_lot_id: stockLotId,
            tray_id: trayId,
            brass_audit_accptance: brassQcAccptance,
            brass_audit_rejection: brassQcRejection,
            brass_audit_few_cases_accptance: brassQcFewCasesAccptance
          })
        })
        .then(res => {
          console.log("ðŸ“¡ API Response status:", res.status);
          return res.json();
        })
        .then(data => {
          console.log("ðŸ“Š API Response data:", data);
          
          // Find the row in the table with this Tray ID
          const rows = detailsDiv.querySelectorAll("tbody tr");
          console.log("ðŸ“‹ Found", rows.length, "rows in modal table");
          
          let found = false;
          
          rows.forEach((row, index) => {
            const trayIdInput = row.querySelector('input[type="text"]');
            if (trayIdInput) {
              const rowTrayId = trayIdInput.value.trim();
              console.log(`ðŸ”Ž Row ${index + 1}: checking "${rowTrayId}" vs "${trayId}"`);
              
              if (rowTrayId === trayId) {
                found = true;
                console.log(`âœ… Found matching tray in row ${index + 1}`);
                
                const statusCell = row.querySelector("td:last-child");
                if (statusCell) {
                  if (data.success && data.exists) {
                    // Pass validation - show tick as active, cross as inactive
                    statusCell.innerHTML = `
                      <div class="validation-status">
                        <div class="status-icon fail inactive">
                          <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                        </div>
                        <div class="status-icon pass active">
                          <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                        </div>
                      </div>
                    `;
                    
                    // Add visual feedback for successful validation
                    row.style.backgroundColor = '#e8f5e8';
                    setTimeout(() => {
                      row.style.backgroundColor = '';
                    }, 100);
                    
                    console.log("âœ… Updated status cell to PASS");
                    
                  } else {
                    // Fail validation - show cross as active, tick as inactive
                    statusCell.innerHTML = `
                      <div class="validation-status">
                        <div class="status-icon fail active">
                          <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                        </div>
                        <div class="status-icon pass inactive">
                          <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                        </div>
                      </div>
                    `;
                    
                    // Add visual feedback for failed validation
                    row.style.backgroundColor = '#ffebee';
                    setTimeout(() => {
                      row.style.backgroundColor = '';
                    }, 100);
                    
                    console.log("âŒ Updated status cell to FAIL");
                  }
                }
              }
            }
          });
          
          if (!found) {
            console.log("âŒ Tray not found in table");
            
            // Enhanced error message with stock status context
            let filterContext = '';
            if (stockStatus.accepted_ip_stock && !stockStatus.few_cases_accepted_ip_stock) {
              filterContext = ' (searching in accepted trays only)';
            } else if (stockStatus.rejected_ip_stock && !stockStatus.few_cases_accepted_ip_stock) {
              filterContext = ' (searching in rejected trays only)';
            } else if (stockStatus.few_cases_accepted_ip_stock) {
              filterContext = ' (searching in both accepted and rejected trays)';
            }
            
            showError(`Tray ID "${trayId}" not found in table${filterContext}.`);
          } else {
            console.log("ðŸŽ‰ Validation successful!");
          }
          
          // Always clear and focus input for next scan
          validateInput.value = "";
          validateInput.focus();
        })
        .catch(error => {
          console.error('âŒ Network error:', error);
          showError('Network error occurred while validating the tray ID.');
          validateInput.value = "";
          validateInput.focus();
        });
      }
    });
    
    // Also add focus event to ensure input is ready
    validateInput.addEventListener("focus", function() {
      console.log("ðŸŽ¯ Validate input focused and ready");
    });
    
  } else {
    console.log("âŒ Required elements not found:", {
      validateInput: !!validateInput,
      detailsDiv: !!detailsDiv
    });
  }
  
  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
  
  console.log("ðŸŽ¯ Tray validation script setup complete");
});
</script>


<!--Update the tray list fetching endpoint in the modal script -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
        link.addEventListener('click', async function (e) {
          e.preventDefault();
    
          // Get modal elements
          const modal = document.getElementById("trayScanModal_DayPlanning");
          const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
          const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
          const modalLotQty = document.getElementById("modalLotQty_DayPlanning"); // âœ… NEW
          const modalMissingQty = document.getElementById("modalMissingQty_DayPlanning"); // âœ… NEW
          const modalPhysicalQty = document.getElementById("modalPhysicalQty_DayPlanning"); // âœ… NEW

          modal.dataset.batchId = link.getAttribute('data-batch-id');
    
          // Get data attributes
          const batchId = link.getAttribute('data-batch-id');
          const modelNo = link.getAttribute('data-model-no');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
          const trayCapacity = link.getAttribute('data-tray-capacity') || "";
          const totalBatchQuantity = link.getAttribute('data-total-batch-quantity') || "0";
          const physicalQty = link.getAttribute('data-physical-qty') || "0";
          const missingQty = link.getAttribute('data-missing-qty') || "0";

          // âœ… UPDATED: Get brass QC specific stock status data
          const brassQcAccptance = link.getAttribute('data-brass-qc-accptance') === 'true';
          const brassQcRejection = link.getAttribute('data-brass-qc-rejection') === 'true';
          const brassQcFewCasesAccptance = link.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
    
          // Set model number in modal
          if (modalModelNo && modelNo) {
            modalModelNo.textContent = modelNo;
          }

          if (modalLotQty) {
            modalLotQty.textContent = totalBatchQuantity;
            console.log("âœ… Set Lot Qty to:", totalBatchQuantity);
          }
          if (modalMissingQty) {
            modalMissingQty.textContent = missingQty;
            console.log("âœ… Set Missing Qty to:", missingQty);
          }
          if (modalPhysicalQty) {
            modalPhysicalQty.textContent = physicalQty;
            console.log("âœ… Set Physical Qty to:", physicalQty);
          }
    
          // Set model image
          const modalUserImg = modal.querySelector('.user-profile img');
          const modelImage = link.getAttribute('data-model-image');
          if (modalUserImg) {
            modalUserImg.src = modelImage || "/static/assets/images/imagePlaceholder.png";
          }
    
          // âœ… UPDATED: Fetch tray data with rejection information using correct endpoint
          let traysData = [];
          let rejectionSummary = {};
          try {
            const params = new URLSearchParams({
              batch_id: batchId,
              stock_lot_id: stockLotId,
              lot_id: stockLotId,
              brass_audit_accptance: brassQcAccptance,
              brass_audit_rejection: brassQcRejection,
              brass_audit_few_cases_accptance: brassQcFewCasesAccptance
            });
            
            // âœ… UPDATED: Use correct endpoint name
            const resp = await fetch(`/spider_spindle/jig_tray_id_list/?${params}`);
            const result = await resp.json();
            if (result.success) {
              traysData = result.trays || [];
              rejectionSummary = result.rejection_summary || {};
              console.log('âœ… Fetched trays with rejection data:', traysData);
              console.log('ðŸ“Š Rejection summary:', rejectionSummary);
            }
          } catch (e) {
            console.error('âŒ Error fetching tray data:', e);
          }
    
          // âœ… FIXED: Build modal content - Only show section headers when trays exist
          function buildTableHTML(showValidationColumn = false) {
            let html = `
              <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
                <thead>
                  <tr>
                    <th style="width:50px;">S.no</th>
                    <th>Tray ID</th>
                    <th>Tray Qty</th>
                    ${showValidationColumn ? '<th>Tray Validation Status</th>' : ''}
                  </tr>
                </thead>
                <tbody>
            `;
          
            let rowCounter = 1;
            let topTrayShown = false;
          
            // âœ… SECTION 1: ACCEPTED TRAYS ONLY - Only show if there are accepted trays
            if (traysData && traysData.length > 0) {
              const acceptedTrays = traysData.filter(tray => !tray.rejected_tray && !tray.delink_tray);
              
              // âœ… FIXED: Only add header if there are accepted trays
              if (acceptedTrays.length > 0) {
                html += `

                `;
                
                acceptedTrays.forEach((tray) => {
                  let displaySNo;
                  if (!topTrayShown && (tray.ip_top_tray || tray.top_tray)) {
                    displaySNo = `${rowCounter} (Top Tray)`;
                    topTrayShown = true;
                  } else {
                    displaySNo = rowCounter;
                  }
                  
                  let displayQuantity;
                  if (brassQcAccptance && tray.top_tray) {
                    displayQuantity = tray.tray_quantity;
                  } else if (tray.ip_top_tray && tray.ip_top_tray_qty !== null) {
                    displayQuantity = tray.ip_top_tray_qty;
                  } else {
                    displayQuantity = tray.tray_quantity;
                  }
          
                  const rowClass = (tray.ip_top_tray || tray.top_tray) ? 'top-tray-row' : '';
                  
                  html += `
                    <tr class="${rowClass}">
                      <td>${displaySNo}</td>
                      <td>
                        <input type="text" class="form-control" value="${tray.tray_id || ''}" readonly style="width: 100%;" />
                      </td>
                      <td>
                        <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
                      </td>
                      ${showValidationColumn ? `
                        <td>
                          <div class="validation-status">
                            <div class="status-icon fail">
                              <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                            </div>
                            <div class="status-icon pass">
                              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                            </div>
                          </div>
                        </td>
                      ` : ''}
                    </tr>
                  `;
                  rowCounter++;
                });
              }
          
              // âœ… SECTION 2: REJECTED/DELINKED/SHORTAGE TRAYS - Dynamic Header Based on Content
              // Sort rejected/delinked trays by tray quantity ascending
              const rejectedTrays = traysData
                .filter(tray => tray.rejected_tray || tray.delink_tray)
                .sort((a, b) => {
                  // Use ip_top_tray_qty if present, else tray_quantity
                  const qtyA = a.ip_top_tray && a.ip_top_tray_qty !== null ? a.ip_top_tray_qty : a.tray_quantity;
                  const qtyB = b.ip_top_tray && b.ip_top_tray_qty !== null ? b.ip_top_tray_qty : b.tray_quantity;
                  return (qtyA || 0) - (qtyB || 0);
                });              
              const hasShortage = rejectionSummary.shortage_rejections > 0;
              
              if (rejectedTrays.length > 0 || hasShortage) {
                // Determine what types are present
                const hasRejected = rejectedTrays.some(tray => tray.rejected_tray && !tray.delink_tray);
                const hasDelinked = rejectedTrays.some(tray => tray.delink_tray);
                
                let headerText = '';
                let headerColor = '';
                let bgColor = '';
                
                // âœ… Dynamic header based on combinations
                if (hasRejected && hasDelinked && hasShortage) {
                  headerText = 'âŒ REJECTED, DELINKED & SHORTAGE';
                  headerColor = '#c62828';
                  bgColor = '#ffebee';
                } else if (hasRejected && hasShortage && !hasDelinked) {
                  headerText = 'âŒ REJECTED & SHORTAGE';
                  headerColor = '#c62828';
                  bgColor = '#ffebee';
                } else if (hasDelinked && hasShortage && !hasRejected) {
                  headerText = 'ðŸ”— DELINKED & SHORTAGE';
                  headerColor = '#6c757d';
                  bgColor = '#f8f9fa';
                } else if (hasRejected && hasDelinked && !hasShortage) {
                  headerText = 'âŒ REJECTED & DELINKED TRAYS';
                  headerColor = '#c62828';
                  bgColor = '#ffebee';
                } else if (hasShortage && !hasRejected && !hasDelinked) {
                  headerText = 'ðŸ“¦ SHORTAGE';
                  headerColor = '#ff9800';
                  bgColor = '#fff3e0';
                } else if (hasDelinked && !hasRejected && !hasShortage) {
                  headerText = 'ðŸ”— DELINKED TRAYS';
                  headerColor = '#6c757d';
                  bgColor = '#f8f9fa';
                } else if (hasRejected && !hasDelinked && !hasShortage) {
                  headerText = 'âŒ REJECTED TRAYS';
                  headerColor = '#c62828';
                  bgColor = '#ffebee';
                }
                
                html += `
                  <tr style="background-color: ${bgColor}; font-weight: bold;">
                    <td colspan="${showValidationColumn ? '4' : '3'}" style="text-align: center; color: ${headerColor}; padding: 8px;">
                      ${headerText}
                    </td>
                  </tr>
                `;
          
                // Add rejected/delinked trays with tray IDs
                rejectedTrays.forEach((tray) => {
                  let displayQuantity;
                  if (tray.ip_top_tray && tray.ip_top_tray_qty !== null) {
                    displayQuantity = tray.ip_top_tray_qty;
                  } else {
                    displayQuantity = tray.tray_quantity;
                  }
          
                  let statusTag = '';
                  if (tray.delink_tray) {
                    statusTag = '<span style="background: #6c757d; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">DELINKED</span>';
                  } else {
                    statusTag = '<span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">REJECTED</span>';
                  }
                  
                  html += `
                    <tr>
                      <td>${rowCounter}</td>
                      <td>
                        <input type="text" class="form-control" value="${tray.tray_id || ''}" readonly style="width: 100%;" />
                        ${statusTag}
                      </td>
                      <td>
                        <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
                      </td>
                      ${showValidationColumn ? `
                        <td>
                          <div class="validation-status">
                            <div class="status-icon fail">
                              <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                            </div>
                            <div class="status-icon pass">
                              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                            </div>
                          </div>
                        </td>
                      ` : ''}
                    </tr>
                  `;
                  rowCounter++;
                });
          
                // âœ… Handle SHORTAGE entries (if any)
                if (hasShortage) {
                  // âœ… UPDATED: Use correct endpoint name for shortage data
                  fetch(`/brass_audit/get_shortage_rejections/?lot_id=${encodeURIComponent(stockLotId)}`)
                    .then(res => res.json())
                    .then(data => {
                      if (data.success && data.shortage_rejections.length > 0) {
                        data.shortage_rejections.forEach(shortage => {
                          html += `
                            <tr class="shortage-row">
                              <td>${rowCounter}</td>
                              <td>
                                <input type="text" class="form-control" value="SHORTAGE" readonly style="width: 100%; font-weight: bold;" />
                                <span style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">No Tray-ID</span>
                              </td>
                              <td>
                                <input type="number" class="form-control" value="${shortage.quantity}" readonly style="width: 100%;" />
                              </td>
                              ${showValidationColumn ? `
                                <td>
                                  <span style="color: #666; font-size: 11px;">N/A for SHORTAGE</span>
                                </td>
                              ` : ''}
                            </tr>
                          `;
                          rowCounter++;
                        });
                        
                        // Update the table content
                        html += '</tbody></table>';
                        detailsDiv.innerHTML = html;
                      }
                    })
                    .catch(e => {
                      console.error('Error fetching SHORTAGE details:', e);
                      // Fallback: Add basic SHORTAGE row
                      for (let i = 0; i < rejectionSummary.shortage_rejections; i++) {
                        html += `
                          <tr class="shortage-row">
                            <td>${rowCounter}</td>
                            <td>
                              <input type="text" class="form-control" value="SHORTAGE" readonly style="width: 100%; font-weight: bold;" />
                              <span style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">No Tray-ID</span>
                            </td>
                            <td>
                              <input type="number" class="form-control" value="?" readonly style="width: 100%;" />
                            </td>
                            ${showValidationColumn ? `
                              <td>
                                <span style="color: #666; font-size: 11px;">N/A for SHORTAGE</span>
                              </td>
                            ` : ''}
                          </tr>
                        `;
                        rowCounter++;
                      }
                      html += '</tbody></table>';
                      detailsDiv.innerHTML = html;
                    });
                  
                  // Return early since we're handling async update
                  return html;
                }
              }
            }
            
            html += '</tbody></table>';
            return html;
          }

          // Show table 
          detailsDiv.innerHTML = buildTableHTML(false);
    
          // Store data for later use
          modal.buildTableHTML = buildTableHTML;
          modal.traysData = traysData;
          modal.rejectionSummary = rejectionSummary;
    
          // Show the modal
          modal.style.display = "block";
          modal.classList.add("open");
        });
      });
    

      
      // Close handler remains the same
      const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
      if (closeBtn) {
        closeBtn.addEventListener("click", function () {
          const modal = document.getElementById("trayScanModal_DayPlanning");
          if (modal) {
            modal.classList.remove("open");
            modal.style.display = "none";
          }
        });
      }
    });
    
    
    </script>
<!--end of script view icon-->

<script nonce="{{ csp_nonce }}">
  // Example: currentLotIds = ['LOT123', 'LOT456'];
  // You should set this variable dynamically based on your modal's data.
  var currentLotIds = window.currentLotIds || [];

  document.getElementById('jig-composition-link').addEventListener('click', function(e) {
    e.preventDefault();
    if (currentLotIds.length > 0) {
      // Join lot IDs as comma-separated string
      var lotIdsParam = encodeURIComponent(currentLotIds.join(','));
      window.location.href = "{% url 'spider_composition' %}?lot_ids=" + lotIdsParam;
    } else {
      window.location.href = "{% url 'spider_composition' %}";
    }
  });
</script>

  <!-- Script for Text Remarks (unchanged) -->
  <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", hideTooltip);
        }
      });
    });
  </script>
  
    <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var textarea = tooltip.querySelector("textarea");
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the batch_id from the row (tr) data attribute or from a hidden field
            var row = trigger.closest("tr");
            var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
            var lotId = row ? row.getAttribute('data-stock-lot-id') : null;
            if (!lotId) {
              Swal.fire('Error', 'Lot ID not found.', 'error');
              return;
            }
            fetch('/spider_spindle/spider_save_ip_pick_remark/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                stock_lot_id: lotId,
                remark: remark
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire({
                  icon: 'success',
                  title: 'Remark saved!',
                  timer: 100,
                  showConfirmButton: false
                }).then(() => {
                  // Make the textarea readonly
                  if (textarea) {
                    textarea.setAttribute("readonly", true);
                  }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }
                                    // Change chat icon color immediately
                  const chatIcon = trigger.querySelector('img[alt="Chat"]');
                  if (chatIcon) {
                    chatIcon.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                    chatIcon.style.opacity = "1";
                  }

                  hideTooltip(); // optional if you still want to hide the tooltip
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });
    });
  </script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  let openTooltip = null;

  // Helper function to completely close a tooltip
  function closeTooltip(tooltip, trigger) {
    if (tooltip) {
      console.log('ðŸ”´ Closing tooltip completely');
      
      // Remove pinned class
      tooltip.classList.remove("pinned");
      
      // Hide the entire tooltip completely
      tooltip.style.opacity = "0";
      tooltip.style.pointerEvents = "none";
      tooltip.style.visibility = "hidden";
      tooltip.style.display = "none"; // âœ… ADDED: Force display none
      
      // Hide buttons
      const infoBtn = tooltip.querySelector('.info-btn');
      const closeBtn = tooltip.querySelector('.close-btn');
      if (infoBtn) infoBtn.style.display = 'none';
      if (closeBtn) closeBtn.style.display = 'none';
      
      // Remove visual indicator from trigger
      if (trigger) {
        trigger.style.backgroundColor = '';
        trigger.style.borderRadius = '';
      }
      
      // Clear global reference
      openTooltip = null;
      
      console.log('âœ… Tooltip completely closed');
    }
  }

document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let modelNo = null;
    
    if (row) {
      // Get the plating stock number from the 3rd column (index 2)
      const cells = row.querySelectorAll('td');
      if (cells.length > 2) {
        const platingStockCell = cells[2];
        
        // Get the model-hover-trigger span content
        const modelTrigger = platingStockCell.querySelector('.model-hover-trigger');
        if (modelTrigger) {
          // Clone and remove tooltip to get clean text
          const clonedElement = modelTrigger.cloneNode(true);
          const tooltip = clonedElement.querySelector('.model-image-tooltip');
          if (tooltip) {
            tooltip.remove();
          }
          
          // Get clean text and extract first 4 characters
          const fullText = clonedElement.textContent.trim();
          if (fullText.length >= 4) {
            modelNo = fullText.substring(0, 4); // Extract only "2648"
          }
        }
        
        console.log('Extracted model no:', modelNo);
      }
    }
    
    // Build the URL with model_no parameter
    let url = "/adminportal/other_visualaid/";
    if (modelNo) {
      url += "?model_no=" + encodeURIComponent(modelNo);
    }
    
    console.log('Navigating to:', url);
    window.location.href = url;
  });
});
  // Tooltip show/hide logic
  document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
    const tooltip = trigger.querySelector(".model-image-tooltip");

    trigger.addEventListener("mouseenter", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.display = "flex"; // âœ… ADDED: Reset display
        tooltip.style.visibility = "visible"; // âœ… ADDED: Reset visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Show Info and Close buttons on hover
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      }
    });

    trigger.addEventListener("mouseleave", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.opacity = "0";
        tooltip.style.pointerEvents = "none";
        
        // Hide Info and Close buttons when not hovering and not pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'none';
        if (closeBtn) closeBtn.style.display = 'none';
      }
    });

    // Keep tooltip visible when hovering over it
    if (tooltip) {
      tooltip.addEventListener("mouseenter", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.display = "flex"; // âœ… ADDED: Reset display
          tooltip.style.visibility = "visible"; // âœ… ADDED: Reset visibility
        }
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Keep buttons visible when hovering over tooltip
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      });

      tooltip.addEventListener("mouseleave", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.opacity = "0";
          tooltip.style.pointerEvents = "none";
          
          // Hide buttons when leaving tooltip and not pinned
          const infoBtn = tooltip.querySelector('.info-btn');
          const closeBtn = tooltip.querySelector('.close-btn');
          if (infoBtn) infoBtn.style.display = 'none';
          if (closeBtn) closeBtn.style.display = 'none';
        }
      });
    }

    trigger.addEventListener("click", function (e) {
      e.stopPropagation();

      if (tooltip) {
        // Close any previously opened tooltip
        if (openTooltip && openTooltip !== tooltip) {
          const prevTrigger = openTooltip.closest('.model-hover-trigger');
          closeTooltip(openTooltip, prevTrigger);
        }

        tooltip.classList.add("pinned");
        tooltip.style.display = "flex"; // âœ… ADDED: Ensure display
        tooltip.style.visibility = "visible"; // âœ… ADDED: Ensure visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        openTooltip = tooltip;
        
        // Keep buttons visible when pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';

        // Add visual indicator that tooltip is pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      }
    });

    // âœ… FIXED: Handle Close button click - Complete tooltip closure
    const closeBtn = tooltip?.querySelector('.close-btn');
    if (closeBtn) {
      // Initially hide the button
      closeBtn.style.display = 'none';
      
      closeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        console.log('ðŸ”´ Close button clicked');
        
        // Use the helper function to completely close tooltip
        closeTooltip(tooltip, trigger);
        
        // Feedback animation for close button
        closeBtn.style.transform = 'scale(0.9)';
        setTimeout(() => {
          if (closeBtn.style) {
            closeBtn.style.transform = 'scale(1)';
          }
        }, 150);
      });
      
      // âœ… Add hover effect for close button
      closeBtn.addEventListener('mouseenter', function() {
        closeBtn.style.backgroundColor = '#c82333';
        closeBtn.style.transform = 'scale(1.05)';
      });
      
      closeBtn.addEventListener('mouseleave', function() {
        closeBtn.style.backgroundColor = '#dc3545';
        closeBtn.style.transform = 'scale(1)';
      });
    }
  });

  // âœ… ENHANCED: Close tooltip when clicking outside
  document.addEventListener("click", function (e) {
    if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
    }
  });

  // âœ… Close tooltip with ESC key
  document.addEventListener("keydown", function (e) {
    if (e.key === "Escape" && openTooltip) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
      console.log('âœ… Tooltip closed with ESC key');
    }
  });

  // Prevent tooltip from closing when clicking inside it
  document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
    tooltip.addEventListener("click", function (e) {
      e.stopPropagation();
    });
  });
});
</script>


<!-- Script for Model / Stock No - Image Mouse Hover -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.model-hover-trigger').forEach(function(trigger) {
      const tooltip = trigger.querySelector('.model-image-tooltip');
      let currentIndex = 0;
      let tooltipPinned = false;
      let hoverTimeout = null;
      const images = Array.from(tooltip.querySelectorAll('.img-gallery img'));

      function showImages(start) {
        images.forEach((img, i) => {
          img.style.display = (i >= start && i < start + 3) ? 'block' : 'none';
        });
      }
      showImages(currentIndex);

      // Show immediately on mouseenter
      trigger.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving trigger (unless pinned)
      trigger.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            if (!tooltip.matches(':hover')) {
              tooltip.style.opacity = '0';
              tooltip.style.pointerEvents = 'none';
            }
          }, 300);
        }
      });

      // Keep visible when hovering over tooltip
      tooltip.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving tooltip (unless pinned)
      tooltip.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            tooltip.style.opacity = '0';
            tooltip.style.pointerEvents = 'none';
          }, 300);
        }
      });

      // Pin tooltip on click (make it sticky)
      trigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipPinned = true;
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
        clearTimeout(hoverTimeout);
        
        // Add visual indicator that it's pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      });

      // Unpin tooltip if user clicks outside
      document.addEventListener('mousedown', function(e) {
        if (!trigger.contains(e.target) && !tooltip.contains(e.target)) {
          tooltipPinned = false;
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
          
          // Remove visual indicator
          trigger.style.backgroundColor = '';
          trigger.style.borderRadius = '';
        }
      });

      // Handle scroll buttons with error handling
      const leftBtn = tooltip.querySelector('.img-scroll-left');
      const rightBtn = tooltip.querySelector('.img-scroll-right');
      
      if (leftBtn) {
        leftBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex > 0) {
            currentIndex--;
            showImages(currentIndex);
          }
        });
      }
      
      if (rightBtn) {
        rightBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex < images.length - 3) {
            currentIndex++;
            showImages(currentIndex);
          }
        });
      }

      // Add click event to images for modal slider
      images.forEach(function(img, idx) {
        img.style.cursor = 'pointer';
        img.addEventListener('click', function(e) {
          e.stopPropagation();
          openImageSlider(images.map(i => i.src), idx);
        });
      });
    });

    // Modal slider functions
    const modal = document.getElementById("imageSliderModal");
    const closeModal = document.getElementById("closeImageSliderModal");
    const slidesContainer = modal ? modal.querySelector(".slides") : null;
    let sliderImages = [];
    let currentSlide = 0;

    function openImageSlider(srcArray, startIdx) {
      if (!modal || !slidesContainer) return;
      
      sliderImages = srcArray;
      slidesContainer.innerHTML = '';
      sliderImages.forEach(src => {
        const slide = document.createElement('div');
        slide.className = 'slide';
        const img = document.createElement('img');
        img.src = src;
        slide.appendChild(img);
        slidesContainer.appendChild(slide);
      });
      currentSlide = startIdx;
      showSlide(currentSlide);
      modal.classList.add('open');
    }

    function showSlide(n) {
      const slides = slidesContainer ? slidesContainer.querySelectorAll('.slide') : [];
      if (!slides.length) return;
      currentSlide = (n + slides.length) % slides.length;
      slides.forEach((slide, idx) => {
        slide.classList.toggle('active', idx === currentSlide);
      });
    }

    if (modal) {
      const prevBtn = modal.querySelector("#prevBtn");
      const nextBtn = modal.querySelector("#nextBtn");
      
      if (prevBtn) {
        prevBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide - 1);
        });
      }
      
      if (nextBtn) {
        nextBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide + 1);
        });
      }
      
      if (closeModal) {
        closeModal.addEventListener("click", function() {
          modal.classList.remove("open");
        });
      }
      
      modal.addEventListener("click", function(e) {
        if (e.target === modal) modal.classList.remove("open");
      });
    }
  });
</script>
<!-- Enhanced Checkbox and Modal Handling Script -->

<script nonce="{{ csp_nonce }}">
// Enhanced script for handling checkbox selections and modal functionality with Half Filled Tray
document.addEventListener("DOMContentLoaded", function() {
  let originalModalData = null;
  let currentModalLotId = null;
  let currentSlideIndex = 0;
  const itemWidth = 172; // 160px + 12px gap

  // Keep a map of debounce timers for each input
  const trayInputTimers = new WeakMap();
  
  document.addEventListener('input', function(e) {
    const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
    if (trayInput) {
      // Remove all previous errors
      trayInput.parentNode.querySelectorAll('.tray-id-error').forEach(div => div.remove());
  
      // Debounce logic...
      const timer = setTimeout(() => {
        const trayId = trayInput.value.trim();
        const lotId = trayInput.getAttribute('data-lot-id') || '';
        if (trayId.length > 0) {
            console.log('Validating tray:', trayId, 'for lot:', lotId);

          const currentValue = trayInput.value;
          fetch('/spider_spindle/validate_spider_tray_id/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ tray_id: trayId, lot_id: lotId }) // <-- Send lot_id
          })
          .then(res => res.json())
          .then(data => {
            if (trayInput.value === currentValue && (!data.exists || !data.lot_match)) {
              trayInput.parentNode.querySelectorAll('.tray-id-error').forEach(div => div.remove());
              const errorDiv = document.createElement('div');
              errorDiv.className = 'tray-id-error';
              errorDiv.style = 'color:red;font-size:12px;margin-top:2px;';
              errorDiv.textContent = !data.exists
                ? 'Tray ID not found!'
                : 'Tray ID does not belong to this lot!';
              trayInput.parentNode.appendChild(errorDiv);
            } else if (trayInput.value === currentValue && data.exists && data.lot_match) {
              // Success: show "Available (can Rearrange)"
              trayInput.parentNode.querySelectorAll('.tray-id-success').forEach(div => div.remove());
              const successDiv = document.createElement('div');
              successDiv.className = 'tray-id-success';
              successDiv.style = 'color:green;font-size:12px;margin-top:2px;';
              successDiv.textContent = 'Available for De-Link';
              trayInput.parentNode.appendChild(successDiv);
            }

             // === Duplicate Tray ID Validation ===
            const allTrayInputs = Array.from(document.querySelectorAll('#delinkTrayTable input[type="text"]'));
            const trayValues = allTrayInputs.map(input => input.value.trim()).filter(val => val);
            const duplicates = trayValues.filter((val, idx, arr) => arr.indexOf(val) !== idx && val === trayInput.value.trim());
            // Remove previous duplicate error
            trayInput.parentNode.querySelectorAll('.tray-id-error-duplicate').forEach(div => div.remove());
            if (duplicates.length > 0) {
              const dupDiv = document.createElement('div');
              dupDiv.className = 'tray-id-error tray-id-error-duplicate';
              dupDiv.style = 'color:red;font-size:12px;margin-top:2px;';
              dupDiv.textContent = 'Duplicate Tray ID not allowed!';
              trayInput.parentNode.appendChild(dupDiv);
            }
                    });
        }
      }, 400);
      trayInputTimers.set(trayInput, timer);
    }
  });
  
  // Function to show toast notifications
  function showToast(type, message, duration = 3000) {
    // Remove any existing toast
    const existingToast = document.getElementById('toastMessage');
    if (existingToast) {
      existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.id = 'toastMessage';
    
    let bgColor, textColor, borderColor, icon;
    switch(type) {
      case 'success':
        bgColor = '#d4f7d4';
        textColor = '#218838';
        borderColor = '#28a745';
        icon = 'âœ“';
        break;
      case 'error':
        bgColor = '#ffd6d6';
        textColor = '#b30000';
        borderColor = '#dc3545';
        icon = 'âœ—';
        break;
      case 'warning':
        bgColor = '#fff3cd';
        textColor = '#856404';
        borderColor = '#ffc107';
        icon = 'âš ';
        break;
      case 'info':
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
        break;
      default:
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
    }
    
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${bgColor};
      color: ${textColor};
      border: 1px solid ${borderColor};
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 10000;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      animation: slideInToast 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 350px;
    `;
    
    toast.innerHTML = `
      <span style="font-weight: bold; font-size: 16px;">${icon}</span>
      <span>${message}</span>
    `;
    
    document.body.appendChild(toast);
    
    if (duration > 0) {
      setTimeout(() => {
        toast.style.animation = 'slideOutToast 0.3s ease';
        setTimeout(() => {
          if (toast.parentNode) {
            toast.remove();
          }
        }, 300);
      }, duration);
    }
    
    return toast;
  }

  // Function to show messages inside the modal instead of SweetAlert
  function showModalMessage(type, title, message, options = {}) {
    // Remove any existing message
    const existingMsg = document.getElementById('modalMessage');
    if (existingMsg) {
      existingMsg.remove();
    }

    // Create message element
    const msgDiv = document.createElement('div');
    msgDiv.id = 'modalMessage';
    
    // Style based on message type
    let bgColor, textColor, borderColor, icon;
    switch(type) {
      case 'success':
        bgColor = '#d4f7d4';
        textColor = '#218838';
        borderColor = '#28a745';
        icon = 'âœ“';
        break;
      case 'error':
        bgColor = '#ffd6d6';
        textColor = '#b30000';
        borderColor = '#dc3545';
        icon = 'âœ—';
        break;
      case 'warning':
        bgColor = '#fff3cd';
        textColor = '#856404';
        borderColor = '#ffc107';
        icon = 'âš ';
        break;
      case 'info':
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
        break;
      default:
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
    }
    
    msgDiv.style.cssText = `
      margin: 15px 0;
      padding: 12px 16px;
      background: ${bgColor};
      color: ${textColor};
      border: 1px solid ${borderColor};
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideInMessage 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    `;
    
    msgDiv.innerHTML = `
      <span style="font-weight: bold; font-size: 16px;">${icon}</span>
      <div style="flex: 1;">
        <div style="font-weight: bold; margin-bottom: 2px;">${title}</div>
        <div style="font-size: 13px; line-height: 1.4;">${message}</div>
      </div>
    `;
    
    // Insert message at the top of modal content
    const modalContent = document.querySelector('#rightSideModal .right-slide-content');
    const modalHeader = modalContent.querySelector('.modal-header');
    modalContent.insertBefore(msgDiv, modalHeader.nextSibling);
    
    // Auto-hide after specified duration
    const duration = options.duration || 5000;
    if (duration > 0) {
      setTimeout(() => {
        if (msgDiv && msgDiv.parentNode) {
          msgDiv.style.animation = 'slideOutMessage 0.3s ease';
          setTimeout(() => {
            if (msgDiv && msgDiv.parentNode) {
              msgDiv.remove();
            }
          }, 300);
        }
      }, duration);
    }
    
    return msgDiv;
  }

  // Function to validate JIG QR ID in real-time
  function validateJigQrId(qrId) {
    if (!qrId.trim()) return;
    
    fetch('/spider_spindle/validate_jig_qr/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        jig_qr_id: qrId
      })
    })
    .then(response => response.json())
    .then(data => {
      const input = document.getElementById('modalJigQrId');
      const existingError = input.parentNode.querySelector('.qr-validation-error');
      
      if (existingError) {
        existingError.remove();
      }
      
      if (data.exists) {
        // Show error for existing QR ID using modal message
        showModalMessage('error', 'QR ID Already Exists', data.message, { duration: 5000 });
        
        // Also show inline error
        const errorDiv = document.createElement('div');
        errorDiv.className = 'qr-validation-error';
        errorDiv.style.color = 'red';
        errorDiv.style.fontSize = '12px';
        errorDiv.style.marginTop = '4px';
        errorDiv.textContent = data.message;
        input.parentNode.appendChild(errorDiv);
        
        // Disable submit buttons
        document.querySelectorAll('.action-buttons button').forEach(btn => {
          if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
            btn.disabled = true;
            btn.style.opacity = '0.5';
          }
        });
      } else {
        // Enable submit buttons
        document.querySelectorAll('.action-buttons button').forEach(btn => {
          if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
            btn.disabled = false;
            btn.style.opacity = '1';
          }
        });
      }
    })
    .catch(error => {
      console.error('QR validation error:', error);
      showModalMessage('error', 'Validation Error', 'Failed to validate QR ID. Please try again.', { duration: 4000 });
    });
  }

// *** UPDATED: Multi-model optimal distribution using backend API ***
async function calculateMultiModelOptimalDistribution(lotQuantities) {
  try {
    console.log('Calculating multi-model optimal distribution using backend:', lotQuantities);
    
    const response = await fetch('/spider_spindle/get_multi_model_distribution/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        lot_quantities: lotQuantities
      })
    });
    
    const result = await response.json();
    
    if (result.success && result.distribution) {
      console.log('âœ… Backend distribution result:', result.distribution);
      return result.distribution;
    } else {
      console.error('âŒ Backend distribution failed:', result.error);
      return { delink_trays: [], half_filled_trays: [], total_delink_qty: 0, lot_distributions: {} };
    }
  } catch (error) {
    console.error('âŒ Error calling backend distribution:', error);
    return { delink_trays: [], half_filled_trays: [], total_delink_qty: 0, lot_distributions: {} };
  }
}

// *** UPDATED: Populate delink tray table using backend distribution ***
async function populateDelinkTrayTableMultiModel(lotQuantities, trayTable) {
  try {
    console.log('Populating multi-model delink tray table');
    
    // Get optimal distribution from backend
    const distribution = await calculateMultiModelOptimalDistribution(lotQuantities);
    
    if (!distribution || !distribution.delink_trays || distribution.delink_trays.length === 0) {
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 20px; color: #666;">
          No optimal delink distribution found for selected quantities
        </div>
      `;
      return { distribution, adjustedTraysData: [] };
    }
    
    // Preserve existing tray data if any
    const existingTrayData = preserveExistingTrayData();
    
    // Populate table with backend distribution results
    distribution.delink_trays.forEach((tray, index) => {
      // Try to preserve existing tray ID at this index
      let existingTrayId = '';
      if (index < existingTrayData.length) {
        existingTrayId = existingTrayData[index].tray_id || '';
      }
      
      // Get model info for placeholder
      const modelForPlaceholder = tray.model_no || getModelForLot(tray.lot_id) || 'Model';
      
      // Create usage hint
      const usageHint = tray.is_complete 
       // ? `Complete: ${tray.used_quantity} pieces (full tray)`
       // : `Partial: ${tray.used_quantity}/${tray.original_tray_quantity} pieces`;
      
      trayTable.innerHTML += `
        <div>${index + 1}</div>
        <div>
          <input type="text"
            value="${existingTrayId}"
            placeholder="${modelForPlaceholder} - Scan Tray ID"
            data-lot-id="${tray.lot_id || ''}"
            data-expected-usage="${tray.used_quantity}"
            data-is-top-tray="${tray.is_top_tray || false}"
            data-original-tray-qty="${tray.original_tray_quantity || tray.tray_quantity}"
            data-backend-optimal="true"
            title="Backend optimal distribution: ${usageHint}"
            style="width:100%; border:none; background:transparent;" />
          <div class="usage-hint" style="font-size: 10px; color: #666; margin-top: 2px;">
            ${usageHint}
          </div>
          <div class="constraint-note" style="font-size: 9px; color: #007bff; margin-top: 1px; font-style: italic;">
            âœ“ Backend optimal distribution
          </div>
        </div>
      `;
    });
    
    // Add summary info
    if (distribution.total_delink_qty > 0) {
      const totalLots = Object.keys(distribution.lot_distributions).length;
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 10px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
          â„¹ï¸ Multi-model distribution: ${distribution.total_delink_qty} pieces across ${totalLots} lots in ${distribution.delink_trays.length} trays
        </div>
      `;
    }
    
    console.log(`âœ… Populated ${distribution.delink_trays.length} delink tray entries from backend`);
    
    return { 
      distribution, 
      adjustedTraysData: distribution.delink_trays.map(tray => ({
        tray_id: tray.tray_id,
        tray_quantity: tray.used_quantity,
        lot_id: tray.lot_id,
        model_no: tray.model_no || getModelForLot(tray.lot_id),
        original_qty: tray.original_tray_quantity || tray.tray_quantity,
        is_complete: tray.is_complete || false
      }))
    };
    
  } catch (error) {
    console.error('âŒ Error populating multi-model delink table:', error);
    trayTable.innerHTML += `
      <div style="grid-column: span 2; text-align:center; padding: 20px; color: #dc3545;">
        Error loading multi-model distribution
      </div>
    `;
    return { distribution: null, adjustedTraysData: [] };
  }
}

// *** UPDATED: Populate half-filled tray table for multi-model ***
function populateHalfFilledTrayTableMultiModel(distribution) {
  const table = document.getElementById('halfFilledTrayTable');
  const halfFilledSection = document.getElementById('halfFilledTraySection');
  
  console.log('Populating multi-model half-filled tray table:', distribution);
  
  if (!distribution || !distribution.half_filled_trays || distribution.half_filled_trays.length === 0) {
    console.log('No half-filled trays for multi-model - hiding table');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }
  
  // Filter to only show top trays for verification (consistency with single model)
  const topTraysOnly = distribution.half_filled_trays.filter(tray => tray.is_top_tray || tray.remaining_type === 'partial');
  
  if (topTraysOnly.length === 0) {
    console.log('No top trays to show for verification - hiding table');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }
  
  console.log(`Showing ${topTraysOnly.length} top trays for verification`);
  if (halfFilledSection) halfFilledSection.style.display = 'block';
  
  // Table headers
  table.innerHTML = `
    <div style="background: #d1f2f3; font-weight: bold;">Tray ID</div>
    <div style="background: #d1f2f3; font-weight: bold;">Tray Quantity</div>
  `;
  
  topTraysOnly.forEach((tray, idx) => {
    const verificationLabel = '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Multi-Model Verification</span>';
    const modelInfo = tray.model_no ? `<div style="font-size:10px;color:#007bff;margin-top:1px;font-style:italic;">Model: ${tray.model_no}</div>` : '';
    
    table.innerHTML += `
      <div>
        <input type="text"
          value=""
          placeholder="Scan remaining tray (${tray.model_no || 'Model'})"
          data-expected-tray-id="${tray.tray_id}"
          data-qty="${tray.tray_quantity}"
          data-original-qty="${tray.original_tray_quantity || tray.tray_quantity}"
          data-top-tray="true"
          data-lot-id="${tray.lot_id || ''}"
          data-model-no="${tray.model_no || ''}"
          data-verification="true"
          data-multi-model="true"
          style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;"
        />
        ${modelInfo}
      </div>
      <div>
        <input type="number"
          value="${tray.tray_quantity}"
          readonly
          style="background: #f9f9f9; border: 1px solid #ddd; width: 80px; text-align: center; padding: 4px; border-radius: 4px;"
        />
        ${verificationLabel}
        <div style="font-size:9px;color:#666;margin-top:1px;">
          Available: ${tray.original_tray_quantity || tray.tray_quantity}
        </div>
      </div>
    `;
  });
  
  console.log(`âœ… Populated ${topTraysOnly.length} multi-model half-filled tray entries`);
}

// *** UPDATED: Enhanced faulty slots calculation for multi-model ***
function setupFaultySlotHandlerMultiModel(validResults, calculatedLotIdQuantities, distribution) {
  const faultySlotInput = document.getElementById('modalFaultySlots');
  const emptySlotInput = document.getElementById('modalEmptySlots');
  const lotQtyInput = document.getElementById('modalLotQty');
  
  if (!faultySlotInput) return;
  
  // Store original values for calculation
  const originalEmptySlots = parseInt(emptySlotInput.value) || 0;
  const originalLotQty = parseInt(lotQtyInput.value) || 0;
  
  // Remove any existing event listeners
  faultySlotInput.replaceWith(faultySlotInput.cloneNode(true));
  const newFaultySlotInput = document.getElementById('modalFaultySlots');
  
  newFaultySlotInput.addEventListener('input', async function() {
    const faultySlots = parseInt(newFaultySlotInput.value) || 0;
    
    if (faultySlots <= 0) {
      // Reset to original values
      emptySlotInput.value = originalEmptySlots;
      lotQtyInput.value = originalLotQty;
      
      // Reset delink tray table with original distribution
      const trayTable = document.getElementById('delinkTrayTable');
      trayTable.innerHTML = `
        <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
        <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
      `;
      
      await populateDelinkTrayTableMultiModel(calculatedLotIdQuantities, trayTable);
      
      // Reset half-filled tray table with original distribution
      if (distribution && distribution.half_filled_trays) {
        populateHalfFilledTrayTableMultiModel(distribution);
      }
      
    } else {
      // Apply faulty slots logic
      let remainingFaultySlots = faultySlots;
      let newEmptySlots = originalEmptySlots;
      let newLotQty = originalLotQty;
      
      // First, reduce from empty slots
      if (remainingFaultySlots > 0 && newEmptySlots > 0) {
        const reductionFromEmpty = Math.min(remainingFaultySlots, newEmptySlots);
        newEmptySlots -= reductionFromEmpty;
        remainingFaultySlots -= reductionFromEmpty;
      }
      
      // Then, reduce from LOT qty if faulty slots still remain
      if (remainingFaultySlots > 0 && newLotQty > 0) {
        const reductionFromLot = Math.min(remainingFaultySlots, newLotQty);
        newLotQty -= reductionFromLot;
        remainingFaultySlots -= reductionFromLot;
      }
      
      // Update the fields
      emptySlotInput.value = Math.max(0, newEmptySlots);
      lotQtyInput.value = Math.max(0, newLotQty);
      
      // Show warning if faulty slots exceed total capacity
      if (remainingFaultySlots > 0) {
        showModalMessage('warning', 'Faulty Slots Exceed Capacity', 
          `${remainingFaultySlots} faulty slots cannot be accommodated.`, 
          { duration: 4000 });
        newFaultySlotInput.value = faultySlots - remainingFaultySlots;
      }
      
      // Recalculate distribution with adjusted quantity
      if (newLotQty !== originalLotQty) {
        console.log('Recalculating multi-model distribution due to faulty slots');
        
        // Use original lot quantities without proportional reduction
        const adjustedLotQuantities = { ...calculatedLotIdQuantities };
        
        console.log('Using original lot quantities without proportional reduction:', adjustedLotQuantities);
        
        // Update delink tray table with original quantities
        const trayTable = document.getElementById('delinkTrayTable');
        trayTable.innerHTML = `
          <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
          <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
        `;
        
        const adjustedResult = await populateDelinkTrayTableMultiModel(adjustedLotQuantities, trayTable);
        
        // Update half-filled tray table with adjusted distribution
        if (adjustedResult && adjustedResult.distribution) {
          populateHalfFilledTrayTableMultiModel(adjustedResult.distribution);
        } else {
          // Hide half-filled if no remaining quantity
          populateHalfFilledTrayTable([]);
        }
      }
    }
    
    // Update Add Model button state
    const currentEmptySlots = parseInt(emptySlotInput.value) || 0;
    updateAddModelButtonState(currentEmptySlots);
  });
}

// *** UPDATED: Helper function to get model number for a lot ***
function getModelForLot(lotId) {
  try {
    // Try to find from checkbox data
    const checkbox = document.querySelector(`.model-select-checkbox[data-stock-lot-id="${lotId}"]`);
    if (checkbox) {
      const modelNo = checkbox.getAttribute('data-model-no');
      if (modelNo) return modelNo;
    }
    
    // Try to find from table row
    const row = document.querySelector(`tr[data-batch-id="${lotId}"]`);
    if (row) {
      const cells = row.querySelectorAll('td');
      if (cells.length > 2) {
        const modelText = cells[2]?.textContent?.trim();
        if (modelText) return modelText.split(' ')[0]; // Get first part before any spaces
      }
    }
    
    return `LOT-${lotId}`;
  } catch (error) {
    console.error('Error getting model for lot:', error);
    return `LOT-${lotId}`;
  }
}

// ENHANCED: clearModalFieldsAfterAddJig function with proper remaining quantity calculation for all selected lots
async function clearModalFieldsAfterAddJig() {
  // Clear Jig QR ID
  document.getElementById('modalJigQrId').value = '';

  // Clear any QR validation errors
  const qrInput = document.getElementById('modalJigQrId');
  const existingError = qrInput.parentNode.querySelector('.qr-validation-error');
  if (existingError) {
    existingError.remove();
  }

  // Clear Faulty Slots
  document.getElementById('modalFaultySlots').value = '';

  // Clear all Delink Tray inputs (keep the structure but clear values)
  const trayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
  trayInputs.forEach(input => {
    input.value = '';
    // Remove any tray validation errors
    const trayErrors = input.parentNode.querySelectorAll('.tray-id-error');
    trayErrors.forEach(error => error.remove());
    input.style.border = ''; // Reset border styling
  });

  // Clear Half Filled Tray inputs
  const halfFilledInputs = document.querySelectorAll('#halfFilledTrayTable input[type="text"]');
  halfFilledInputs.forEach(input => {
    input.value = '';
    // Remove any validation messages
    const validationMsgs = input.parentNode.querySelectorAll('.half-tray-validation');
    validationMsgs.forEach(msg => msg.remove());
    input.style.background = '';
    input.style.borderColor = '';
  });

  // === ENHANCED: REFRESH DATA WITH REMAINING QUANTITY FOR ALL SELECTED LOTS ===
  // Gather all selected lot IDs (including the current modal lot)
  let selectedLotIds = [];
  document.querySelectorAll('.model-select-checkbox:checked').forEach(cb => {
    const lotId = cb.getAttribute('data-stock-lot-id');
    if (lotId) selectedLotIds.push(lotId);
  });
  if (currentModalLotId && !selectedLotIds.includes(currentModalLotId)) {
    selectedLotIds.unshift(currentModalLotId);
  }

  // === UPDATED: Handle both single and multi-model scenarios ===
  const isMultiModel = selectedLotIds.length > 1;
  
  if (isMultiModel) {
    console.log('ðŸ”„ Multi-model refresh after Add Jig');
    
    // Filter out fully processed lots (remaining_quantity <= 0)
    let validLotIds = [];
    let lotDataMap = {};
    
    for (const lotId of selectedLotIds) {
      try {
        const response = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
        const data = await response.json();
        const remainingQty = data.remaining_quantity || 0;
        if (remainingQty > 0) {
          validLotIds.push(lotId);
          lotDataMap[lotId] = data;
        }
      } catch (error) {
        console.error(`Error fetching data for lot ${lotId}:`, error);
      }
    }
    
    if (validLotIds.length > 0) {
      // Calculate new lot quantities for remaining lots
      const newLotQuantities = {};
      let totalNewQty = 0;
      
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        
        if (displayQty > 0) {
          newLotQuantities[lotId] = displayQty;
          totalNewQty += displayQty;
        }
      }
      
      // Update modal fields
      document.getElementById('modalLotQty').value = totalNewQty;
      const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
      const newEmptySlots = Math.max(0, jigCapacity - totalNewQty);
      document.getElementById('modalEmptySlots').value = newEmptySlots;
      updateAddModelButtonState(newEmptySlots);
      
      // Update global lot quantities
      window.currentLotIdQuantities = newLotQuantities;
      
      // Refresh delink tray table with multi-model backend API
      const trayTable = document.getElementById('delinkTrayTable');
      trayTable.innerHTML = `
        <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
        <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
      `;
      
      const populationResult = await populateDelinkTrayTableMultiModel(newLotQuantities, trayTable);
      
      // Refresh half-filled tray table
      if (populationResult && populationResult.distribution) {
        populateHalfFilledTrayTableMultiModel(populationResult.distribution);
      }
      
      // Show multi-model success message
      let remainingMessages = [];
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        remainingMessages.push(`Lot ${lotId}: ${remainingQty} remaining`);
      }
      
      const successMessage = `Multi-model jig added successfully!<br>${remainingMessages.join('<br>')}<br>You can continue adding more jigs or submit when done.`;
      showModalMessage('success', 'Multi-Model Jig Added!', successMessage, { duration: 5000 });
      
    } else {
      showModalMessage('info', 'All Lots Processed', 'All selected lots have been fully processed.', { duration: 4000 });
    }
    
  } else {
    // === SINGLE MODEL LOGIC (EXISTING) ===
    // Filter out fully processed lots (remaining_quantity <= 0)
    let validLotIds = [];
    let lotDataMap = {};
    for (const lotId of selectedLotIds) {
      try {
        // eslint-disable-next-line no-await-in-loop
        const response = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
        // eslint-disable-next-line no-await-in-loop
        const data = await response.json();
        const remainingQty = data.remaining_quantity || 0;
        if (remainingQty > 0) {
          validLotIds.push(lotId);
          lotDataMap[lotId] = data;
        }
      } catch (error) {
        // skip this lot if error
      }
    }

    // If there are valid lots, show remaining for all; else fallback to original logic
    if (validLotIds.length > 0) {
      let remainingMessages = [];
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        if (remainingQty > displayQty) {
          remainingMessages.push(
            `Lot ${lotId}: Remaining quantity: ${remainingQty} (${remainingQty - displayQty} more than jig capacity).`
          );
        } else if (remainingQty > 0) {
          remainingMessages.push(
            `Lot ${lotId}: Remaining quantity: ${remainingQty}.`
          );
        }
      }

      let successMessage = `Jig added successfully!<br>${remainingMessages.join('<br>')}<br>You can continue adding more jigs or submit when done.`;
      showModalMessage('success', 'Jig Added Successfully!', successMessage, { duration: 5000 });

      // Update modal fields for the next lot with available quantity
      let nextLotId = null;
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        if (remainingQty > 0) {
          nextLotId = lotId;
          document.getElementById('modalLotQty').value = displayQty;
          const newEmptySlots = Math.max(0, jigCapacity - displayQty);
          document.getElementById('modalEmptySlots').value = newEmptySlots;
          updateAddModelButtonState(newEmptySlots);

          // Update De-link Tray table and Half Filled Tray table for the next lot
          try {
            const trayTable = document.getElementById('delinkTrayTable');
            trayTable.innerHTML = `
              <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
              <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
            `;
            populateDelinkTrayTableFromCalculation(data, trayTable, displayQty);
            
            // Update Half Filled Tray table (only top tray)
            const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
            populateHalfFilledTrayTable(topTrayOnly);
          } catch (error) {
            // fallback: do nothing
          }
          break;
        }
      }
    } else if (currentModalLotId) {
      // Fallback: single lot logic
      try {
        const response = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
        const data = await response.json();
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        document.getElementById('modalLotQty').value = displayQty;
        const newEmptySlots = Math.max(0, jigCapacity - displayQty);
        document.getElementById('modalEmptySlots').value = newEmptySlots;
        updateAddModelButtonState(newEmptySlots);

        let successMessage = `Jig added successfully! `;
        if (remainingQty > displayQty) {
          successMessage += `Remaining quantity: ${remainingQty} (${remainingQty - displayQty} more than jig capacity). `;
        } else if (remainingQty > 0) {
          successMessage += `Remaining quantity: ${remainingQty}. `;
        } else {
          successMessage += `Lot fully processed. `;
        }
        successMessage += `You can continue adding more jigs or submit when done.`;
        showModalMessage('success', 'Jig Added Successfully!', successMessage, { duration: 5000 });

        // Update De-link Tray table and Half Filled Tray table for the current lot
        const trayTable = document.getElementById('delinkTrayTable');
        trayTable.innerHTML = `
          <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
          <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
        `;
        populateDelinkTrayTableFromCalculation(data, trayTable, displayQty);
        
        // Update Half Filled Tray table (only top tray)
        const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
        populateHalfFilledTrayTable(topTrayOnly);
      } catch (error) {
        showModalMessage('success', 'Jig Added Successfully!',
          'The jig has been added. Please refresh the page to see updated quantities.',
          { duration: 4000 });
      }
    } else {
      // No current modal lot ID - fallback to original behavior
      if (originalModalData) {
        const originalLotQty = parseInt(originalModalData.lotQty) || 0;
        const jigCapacity = parseInt(originalModalData.jigCapacity) || 0;
        const emptySlots = Math.max(0, jigCapacity - originalLotQty);

        document.getElementById('modalLotQty').value = originalLotQty;
        document.getElementById('modalEmptySlots').value = emptySlots;

        updateAddModelButtonState(emptySlots);

        // Update De-link Tray table with original data
        const trayTable = document.getElementById('delinkTrayTable');
        trayTable.innerHTML = originalModalData.trayTableContent || '';
        
        // Hide Half Filled Tray table for original data
        populateHalfFilledTrayTable([]);
      }
      showModalMessage('success', 'Jig Added Successfully!',
        'The jig has been added. You can continue adding more jigs or submit when done.',
        { duration: 3000 });
    }
  }

  // Focus on Jig QR ID for next entry (only if not disabled)
  setTimeout(() => {
    const jigQrInput = document.getElementById('modalJigQrId');
    if (jigQrInput && !jigQrInput.disabled) {
      jigQrInput.focus();
    }
  }, 100);
}




//Half Filled tray id Validation
document.addEventListener('input', function(e) {
  const trayInput = e.target.closest('#halfFilledTrayTable input[type="text"]');
  if (trayInput) {
    // Remove previous validation messages
    trayInput.parentNode.querySelectorAll('.half-tray-validation').forEach(div => div.remove());

    // Debounce validation
    clearTimeout(trayInput.validationTimeout);
    trayInput.validationTimeout = setTimeout(() => {
      const trayId = trayInput.value.trim();
      const lotId = trayInput.getAttribute('data-lot-id') || '';
      if (!trayId) return;

      // Check against De-link Tray IDs
      const delinkTrayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
      const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);

      if (delinkTrayIds.includes(trayId)) {
        const msg = document.createElement('div');
        msg.className = 'half-tray-validation';
        msg.style.cssText = 'font-size: 11px; margin-top: 2px; color: red;';
        msg.textContent = 'âœ— Tray ID already used in De-link Tray. Please enter a different Tray ID.';
        trayInput.style.borderColor = '#dc3545';
        trayInput.parentNode.appendChild(msg);
        return;
      }

      // Call your tray validation API
      fetch('/spider_spindle/validate_spider_tray_id/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          tray_id: trayId,
          lot_id: lotId
        })
      })
      .then(res => res.json())
      .then(data => {
        const msg = document.createElement('div');
        msg.className = 'half-tray-validation';
        msg.style.cssText = 'font-size: 11px; margin-top: 2px;';
        if (data.exists && data.lot_match) {
          msg.textContent = 'âœ“ Tray ID valid';
          msg.style.color = 'green';
          trayInput.style.borderColor = '#28a745';
        } else {
          msg.textContent = !data.exists
            ? 'âœ— Tray ID not found'
            : 'âœ— Tray ID does not belong to this lot';
          msg.style.color = 'red';
          trayInput.style.borderColor = '#dc3545';
        }
        trayInput.parentNode.appendChild(msg);
      })
      .catch(() => {
        const msg = document.createElement('div');
        msg.className = 'half-tray-validation';
        msg.textContent = 'Network error validating tray ID';
        msg.style.color = 'red';
        trayInput.parentNode.appendChild(msg);
      });
    }, 400);
  }
});

// ENHANCED: Function to save JIG details with modal messages
async function saveJigDetails(options = {}) {
  try {
    const modalData = collectModalData();
    const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
    const faultySlots = modalData.faulty_slots;
    const emptySlots = modalData.empty_slots;
    const trayRows = document.querySelectorAll('#delinkTrayTable input[type="text"]');
    let delinkTrayError = false;
    
    trayRows.forEach(input => {
      const trayId = input.value.trim();
      const errorDiv = input.parentNode.querySelector('.tray-id-error');
      if (!trayId || (errorDiv && errorDiv.textContent.includes('Tray ID not found'))) {
        delinkTrayError = true;
        // Highlight the input if not already
        input.style.border = '1px solid #dc3545';
      } else {
        input.style.border = '';
      }
    });
    
    if (trayRows.length > 0 && delinkTrayError) {
      showModalMessage('error', 'Validation Error', 'Please fill all De-link Tray IDs correctly. Remove or correct any invalid Tray IDs before saving.');
      return false;
    }

    // Validation with modal messages instead of Swal
    if (!modalData.jig_qr_id) {
      showModalMessage('error', 'Validation Error', 'Jig QR ID is required');
      return false;
    }
    if (modalData.model_numbers.length === 0) {
      showModalMessage('error', 'Validation Error', 'At least one model is required');
      return false;
    }
    if (modalData.lot_ids.length === 0) {
      showModalMessage('error', 'Validation Error', 'At least one lot ID is required');
      return false;
    }

    // Show loading message instead of Swal loading
    const loadingMsg = showModalMessage('info', 'Saving...', 'Please wait while we save the jig details', { duration: 0 });

    // Send data to API
    const response = await fetch('/spider_spindle/save_jig_details/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify(modalData)
    });

    const result = await response.json();

    // Remove loading message
    if (loadingMsg && loadingMsg.parentNode) {
      loadingMsg.remove();
    }

    if (result.success) {
      // Check for alert message (cycle warning)
      if (result.alert) {
        showModalMessage('warning', 'Cycle Warning', result.alert, { duration: 8000 });
      }
      
      // Handle modal behavior based on options
      if (options.keepModalOpen) {
        // For "Add Jig" - keep modal open, clear fields, update with remaining data
        await clearModalFieldsAfterAddJig();

        // --- NEW: Reload modal data from backend to sync lot_id_quantities and other fields ---
        let lotId = window.currentLotIds && window.currentLotIds.length > 0 ? window.currentLotIds[0] : null;
        if (lotId) {
          fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`)
            .then(res => res.json())
            .then(data => {
              // Update modal fields and in-memory variables with fresh data
              // Example: update lot quantities and any other fields as needed
              if (data.lot_id_quantities) {
                window.currentLotIdQuantities = data.lot_id_quantities;
              }
              // Update modal fields if needed
              if (data.display_qty !== undefined) {
                document.getElementById('modalLotQty').value = data.display_qty;
              }
              if (data.jig_capacity !== undefined) {
                document.getElementById('modalJigCapacity').value = data.jig_capacity;
              }
              // Update Half Filled Tray table with fresh data (only top tray)
              const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
              populateHalfFilledTrayTable(topTrayOnly);
            });
        }
        return true;
      } else {
        // For "Submit" - show success message, close modal and refresh after delay
        showModalMessage('success', 'Success!', result.message, { duration: 3000 });
        setTimeout(() => {
          const modal = document.getElementById('rightSideModal');
          if (modal) {
            modal.classList.remove('open');
            modal.style.display = 'none';
          }
          window.location.reload();
        }, 3500);
        return true;
      }
    } else {
      // Show error message in modal
      showModalMessage('error', 'Save Failed', result.error || 'An error occurred while saving', { duration: 500 });
      return false;
    }
  } catch (error) {
    // Remove any loading message
    const loadingMsg = document.getElementById('modalMessage');
    if (loadingMsg) loadingMsg.remove();
    
    console.error('Save jig details error:', error);
    showModalMessage('error', 'Network Error', 'Failed to connect to server. Please try again.', { duration: 500 });
    return false;
  }
}

  // Add QR ID validation on input
  const jigQrInput = document.getElementById('modalJigQrId');
  if (jigQrInput) {
    let validationTimeout;
    jigQrInput.addEventListener('input', function() {
      clearTimeout(validationTimeout);
      validationTimeout = setTimeout(() => {
        validateJigQrId(this.value);
      }, 500); // Debounce for 500ms
    });
  }

  // Function to update Add Model button and checkbox states
  function updateAddModelButtonState(emptySlots) {
    const addModelBtn = document.querySelector('.btn-action.teal');
    if (addModelBtn) {
      if (emptySlots <= 0) {
        addModelBtn.disabled = true;
        addModelBtn.style.opacity = '0.5';
        addModelBtn.style.cursor = 'not-allowed';
        addModelBtn.style.pointerEvents = 'none';
        addModelBtn.title = 'Cannot add more models - No empty slots available';
      } else {
        addModelBtn.disabled = false;
        addModelBtn.style.opacity = '1';
        addModelBtn.style.cursor = 'pointer';
        addModelBtn.style.pointerEvents = 'auto';
        addModelBtn.title = `${emptySlots} slots available`;
      }
    }
    
    // Also update checkbox states
    if (emptySlots <= 0) {
      document.querySelectorAll('.model-select-checkbox').forEach(function(cb) {
        if (cb.style.display !== 'none') {
          cb.disabled = true;
          cb.style.opacity = '0.5';
          cb.style.cursor = 'not-allowed';
          cb.title = 'Cannot select - No slots available';
          
          const row = cb.closest('tr');
          if (row) {
            row.style.opacity = '0.7';
            row.style.pointerEvents = 'none';
          }
        }
      });
    } else {
      document.querySelectorAll('.model-select-checkbox').forEach(function(cb) {
        if (cb.style.display !== 'none') {
          cb.disabled = false;
          cb.style.opacity = '1';
          cb.style.cursor = 'pointer';
          cb.title = '';
          
          const row = cb.closest('tr');
          if (row) {
            row.style.opacity = '1';
            row.style.pointerEvents = 'auto';
          }
        }
      });
    }
  }

  // Function to create model item for slider
  function createModelItem(modelData) {
    const item = document.createElement('div');
    item.className = 'model-loaded-item';
    item.style = 'min-width: 160px; flex: 0 0 auto; margin-right: 12px; display: flex; align-items: center; background: linear-gradient(135deg, #e8f5e8 0%, #fff5bd 100%); border: 2px solid #28a745; border-radius: 12px; padding: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);';
    
    // Determine status text - only show "Active" for original model
    const statusText = modelData.isOriginal !== false ? 'Active' : 'Added';
    const statusColor = modelData.isOriginal !== false ? '#666' : '#28a745';
    
    item.innerHTML = `
      <img src="${modelData.image}" alt="Model Image" style="width: 50px; height: 50px; object-fit: cover; border-radius: 8px; margin-right: 12px; border: 2px solid #28a745;">
      <div style="flex: 1;">
        <div style="font-size: 14px; font-weight: bold; color: #333; margin-bottom: 2px;">Model No: ${modelData.modelNo}</div>
        <div style="font-size: 12px; color: ${statusColor};">${statusText}</div>
      </div>
    `;
    
    return item;
  }

  // Function to update slider position
  function updateSliderPosition() {
    const slider = document.getElementById('modelSliderDynamic');
    const container = document.querySelector('.model-slider-container');
    if (!slider || !container) return;
    
    const containerWidth = container.offsetWidth;
    const visibleItems = Math.floor(containerWidth / itemWidth);
    const totalItems = slider.children.length;
    
    // Update button visibility
    const prevBtn = document.querySelector('.prev-btn');
    const nextBtn = document.querySelector('.next-btn');
    
    if (prevBtn) prevBtn.style.display = currentSlideIndex > 0 ? 'block' : 'none';
    if (nextBtn) nextBtn.style.display = (currentSlideIndex + visibleItems < totalItems) ? 'block' : 'none';
    
    // Update slider position
    slider.style.transform = `translateX(-${currentSlideIndex * itemWidth}px)`;
  }

  // Function to store original modal data
  function storeOriginalModalData() {
    if (!originalModalData) {
      originalModalData = {
        modelNo: document.getElementById('rightModalModelNo').textContent,
        bathType: document.getElementById('modalBathType').value,
        jigCapacity: document.getElementById('modalJigCapacity').value,
        lotQty: document.getElementById('modalLotQty').value,
        trayTableContent: document.getElementById('delinkTrayTable').innerHTML
      };
      console.log('Original modal data stored:', originalModalData);
    }
  }

  // Function to update selected items status
  function updateSelectedItemsStatus() {
    const checkedBoxes = document.querySelectorAll('.model-select-checkbox:checked');
    const statusDiv = document.getElementById('selectedItemsStatus');
    const countSpan = document.getElementById('selectedCount');
    
    if (checkedBoxes.length > 0) {
      if (statusDiv) {
        statusDiv.style.display = 'block';
        if (countSpan) countSpan.textContent = checkedBoxes.length;
      }
    } else {
      if (statusDiv) statusDiv.style.display = 'none';
    }
    
    // Highlight selected rows
    document.querySelectorAll('tbody tr').forEach(row => {
      const checkbox = row.querySelector('.model-select-checkbox');
      if (checkbox && checkbox.checked) {
        row.classList.add('checkbox-selected');
      } else {
        row.classList.remove('checkbox-selected');
      }
    });
  }

// Function to preserve existing tray data before rebuilding the table
function preserveExistingTrayData() {
  const existingTrayData = [];
  const trayTable = document.getElementById('delinkTrayTable');
  const trayRows = trayTable.querySelectorAll('div');
  
  // UPDATED: Process tray table in groups of 2 (S.No, Tray ID input) instead of 3
  for (let i = 2; i < trayRows.length; i += 2) { // Start from index 2 to skip headers
    const sNoDiv = trayRows[i];
    const trayIdDiv = trayRows[i + 1];

    if (sNoDiv && trayIdDiv) {
      const trayInput = trayIdDiv.querySelector('input[type="text"]');
      const trayId = trayInput ? trayInput.value.trim() : '';
      const lotId = trayInput ? trayInput.getAttribute('data-lot-id') || '' : '';

      // Store without tray_quantity since we removed that column
      existingTrayData.push({
        tray_id: trayId,
        lot_id: lotId
      });
    }
  }
  
  return existingTrayData;
}

// Handle opening of individual jig modal (enhanced with draft delink tray support)
document.querySelectorAll('.open-jig-modal-btn').forEach(function(btn) {
  btn.addEventListener('click', async function(e) {
    e.preventDefault();
    const lotId = btn.getAttribute('data-stock-lot-id');
    if (!lotId) return;
    window.initialLotId = lotId; 
    window.currentLotIds = [lotId];

    currentModalLotId = lotId;
    originalModalData = null; // Reset for new modal
    currentSlideIndex = 0; // Reset slider

    // Show modal
    const modal = document.getElementById('rightSideModal');
    if (modal) {
      modal.classList.add('open');
      modal.classList.remove('minimized');
    }

    // Fetch data from API
    try {
      const res = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
      const data = await res.json();
      console.log("API response:", data);

      // Fill basic modal fields first
      document.getElementById('rightModalModelNo').textContent = data.model_no || '-';
      document.getElementById('modalBathType').value = data.ep_bath_type || '';
      document.getElementById('modalJigCapacity').value = data.jig_capacity || '';

      let finalDisplayQty, finalEmptySlots, finalFaultySlots;
      let isDraftMode = false;

      // === ENHANCED: HANDLE DRAFT DATA INCLUDING DELINK TRAYS ===
      if (data.draft_data && data.draft_data.has_draft) {
        console.log("Loading draft data:", data.draft_data);
        isDraftMode = true;
        
        // Fill form fields with draft data
        document.getElementById('modalJigQrId').value = data.draft_data.jig_qr_id || '';
        document.getElementById('modalFaultySlots').value = data.draft_data.faulty_slots || 0;
        document.getElementById('modalEmptySlots').value = data.draft_data.empty_slots || 0;
        document.getElementById('modalLotQty').value = data.draft_data.total_cases_loaded || 0;
        
        // Store draft ID for updates
        window.currentDraftId = data.draft_data.draft_id;
        
        // === NEW: UPDATE HEADER WITH ALL MODELS FROM DRAFT ===
        if (data.draft_data.no_of_model_cases && data.draft_data.no_of_model_cases.length > 0) {
          const allDraftModels = data.draft_data.no_of_model_cases;
          document.getElementById('rightModalModelNo').textContent = allDraftModels.join(', ');
          console.log("Updated header with draft models:", allDraftModels.join(', '));
        }
        
        // === NEW: SET CURRENT LOT IDS FROM DRAFT ===
        if (data.draft_data.new_lot_ids && data.draft_data.new_lot_ids.length > 0) {
          window.currentLotIds = data.draft_data.new_lot_ids;
          console.log("Set currentLotIds from draft:", window.currentLotIds);
        }
        
        // === NEW: FETCH AND DISPLAY CYCLE COUNT FOR DRAFT JIG QR ID ===
        if (data.draft_data.jig_qr_id) {
          setTimeout(() => {
            fetchAndDisplayCycleCount(data.draft_data.jig_qr_id);
          }, 500);
        }
        
        // === NEW: STORE DRAFT LOT ID QUANTITIES FOR MODAL DATA COLLECTION ===
        if (data.draft_data.lot_id_quantities) {
          window.currentLotIdQuantities = data.draft_data.lot_id_quantities;
          console.log("Stored draft lot_id_quantities:", window.currentLotIdQuantities);
        }
        
        // Use draft values for calculations
        finalDisplayQty = parseInt(data.draft_data.total_cases_loaded) || 0;
        finalEmptySlots = parseInt(data.draft_data.empty_slots) || 0;
        finalFaultySlots = parseInt(data.draft_data.faulty_slots) || 0;

        // *** FIXED: Handle Half Filled Tray Data from Draft ***
        console.log("ðŸ” Checking for draft half_filled_tray_data...");
        
        // Check if draft has saved half_filled_tray_data
        let draftHalfFilledData = data.draft_data.half_filled_tray_data || [];
        
        console.log("ðŸ“„ Draft half_filled_tray_data:", draftHalfFilledData);
        
        if (draftHalfFilledData && draftHalfFilledData.length > 0) {
          console.log("âœ… Found saved draft half_filled_tray_data - using it instead of calculated");
          populateHalfFilledTrayTableFromDraft(draftHalfFilledData);
        } else {
          console.log("ðŸ“Š No saved draft half_filled_tray_data - using calculated");
          // Fall back to calculated half filled trays if no draft data
          const shouldShowHalfFilled = data.half_filled_trays && data.show_half_filled_table && 
            finalDisplayQty < (data.original_quantity || 0) && !data.jig_fully_utilized;
            
          if (shouldShowHalfFilled) {
            const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
            populateHalfFilledTrayTable(topTrayOnly);
          } else {
            populateHalfFilledTrayTable([]);
          }
        }

      } else {
        console.log("No draft data, using fresh calculation");
        window.currentDraftId = null;

        // Use display_qty from the enhanced API response
        finalDisplayQty = (data.edited_quantity > 0 ? data.edited_quantity : (data.display_qty || 0));
        document.getElementById('modalLotQty').value = finalDisplayQty;        
        // Calculate Empty Slots automatically: Jig Capacity - Display LOT Qty
        const jigCapacity = parseInt(data.jig_capacity) || 0;
        finalEmptySlots = Math.max(0, jigCapacity - finalDisplayQty);
        document.getElementById('modalEmptySlots').value = finalEmptySlots;
        finalFaultySlots = 0;
        
        // FIXED: Enhanced Half Filled Tray Table logic for fresh data
        console.log("Half filled trays data:", data.half_filled_trays);
        console.log("Show half filled table:", data.show_half_filled_table);
        console.log("Final display qty:", finalDisplayQty);
        console.log("Original quantity:", data.original_quantity);
        console.log("Jig fully utilized:", data.jig_fully_utilized);
        
        const shouldShowHalfFilled = data.half_filled_trays && data.show_half_filled_table && 
          finalDisplayQty < (data.original_quantity || 0) && !data.jig_fully_utilized;
          
        console.log("Should show half filled table (fresh):", shouldShowHalfFilled);
        
        if (shouldShowHalfFilled) {
          // FIXED: Filter to only show top tray for verification
          const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
          populateHalfFilledTrayTable(topTrayOnly);
        } else {
          // Hide the half filled tray table if conditions not met
          populateHalfFilledTrayTable([]);
        }
      }

      // === POPULATE DELINK TRAY TABLE ===
      const trayTable = document.getElementById('delinkTrayTable');
      trayTable.innerHTML = `
        <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
        <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
      `;

      if (isDraftMode && data.draft_data.delink_tray_data && data.draft_data.delink_tray_data.length > 0) {
        // === USE SAVED DRAFT DELINK TRAY DATA WITH PROPER MODEL PLACEHOLDERS ===
        console.log("Populating delink trays from draft data:", data.draft_data.delink_tray_data);
        
        // Create a map of lot_id to model_no for proper placeholders
        const lotIdToModelMap = {};
        
        // Build the mapping from draft data
        if (data.draft_data.new_lot_ids && data.draft_data.no_of_model_cases) {
          for (let i = 0; i < data.draft_data.new_lot_ids.length; i++) {
            const lotId = data.draft_data.new_lot_ids[i];
            const modelNo = data.draft_data.no_of_model_cases[i] || data.draft_data.no_of_model_cases[0] || data.model_no;
            lotIdToModelMap[lotId] = modelNo;
            console.log(`Mapped lot ${lotId} to model ${modelNo}`);
          }
        }
        
        // Populate the tray table with correct model placeholders
        data.draft_data.delink_tray_data.forEach((trayEntry, index) => {
          const trayId = trayEntry.tray_id || '';
          const lotId = trayEntry.lot_id || '';
          const trayQuantity = trayEntry.tray_quantity || trayEntry.delink_qty || 0;
          
          // Get correct model number for this lot_id
          const modelForPlaceholder = lotIdToModelMap[lotId] || data.model_no || 'Unknown';
          
          console.log(`Loading draft tray ${index + 1}: ID="${trayId}", Lot="${lotId}", Model="${modelForPlaceholder}", Qty=${trayQuantity}`);
          
          trayTable.innerHTML += `
            <div>${index + 1}</div>
            <div>
              <input type="text"
                value="${trayId}"
                placeholder="${modelForPlaceholder} - Tray ID"
                data-lot-id="${lotId}"
                style="width:100%; border:none; background:transparent;" />
            </div>
          `;
        });
        
        console.log(`Loaded ${data.draft_data.delink_tray_data.length} saved delink tray entries from draft with correct model placeholders`);
        
      } else {
        // === USE CALCULATED TRAY DISTRIBUTION (FRESH OR DRAFT WITHOUT SAVED TRAY DATA) ===
        console.log("Using calculated tray distribution");
        populateDelinkTrayTableFromCalculation(data, trayTable, finalDisplayQty);
      }

      // === ADD EVENT LISTENER FOR FAULTY SLOTS CALCULATION ===
      const faultySlotInput = document.getElementById('modalFaultySlots');
      const emptySlotInput = document.getElementById('modalEmptySlots');
      const lotQtyInput = document.getElementById('modalLotQty');
      
      // Store original values for calculation (use final values, not just API response)
      const originalEmptySlots = finalEmptySlots;
      const originalDisplayQty = finalDisplayQty;
      
      if (faultySlotInput) {
        // Remove any existing event listeners to prevent duplicates
        faultySlotInput.replaceWith(faultySlotInput.cloneNode(true));
        const newFaultySlotInput = document.getElementById('modalFaultySlots');
        
        // Set the value again after cloning
        if (isDraftMode) {
          newFaultySlotInput.value = finalFaultySlots;
        }
        
      // === UPDATED: FAULTY SLOTS EVENT LISTENER WITH OPTIMAL CALCULATION ===
      newFaultySlotInput.addEventListener('input', function() {
        const faultySlots = parseInt(newFaultySlotInput.value) || 0;

        let newEmptySlots = originalEmptySlots;
        let newLotQty = originalDisplayQty;
        let remainingFaultySlots = faultySlots;

        if (faultySlots <= 0) {
          emptySlotInput.value = originalEmptySlots;
          lotQtyInput.value = originalDisplayQty;
          
          // Reset half filled trays to original optimal distribution
          if (data.half_filled_trays && data.show_half_filled_table) {
            const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
            populateHalfFilledTrayTable(topTrayOnly);
          } else {
            populateHalfFilledTrayTable([]);
          }
        } else {
          // Reduce from empty slots first
          if (remainingFaultySlots > 0 && newEmptySlots > 0) {
            const reductionFromEmpty = Math.min(remainingFaultySlots, newEmptySlots);
            newEmptySlots -= reductionFromEmpty;
            remainingFaultySlots -= reductionFromEmpty;
          }
          // Then reduce from LOT qty
          if (remainingFaultySlots > 0 && newLotQty > 0) {
            const reductionFromLot = Math.min(remainingFaultySlots, newLotQty);
            newLotQty -= reductionFromLot;
            remainingFaultySlots -= reductionFromLot;
          }
          emptySlotInput.value = Math.max(0, newEmptySlots);
          lotQtyInput.value = Math.max(0, newLotQty);

          if (remainingFaultySlots > 0) {
            showModalMessage('warning', 'Faulty Slots Exceed Capacity', 
              `${remainingFaultySlots} faulty slots cannot be accommodated.`, 
              { duration: 4000 });
            newFaultySlotInput.value = faultySlots - remainingFaultySlots;
          }
          
          // *** UPDATED: Use optimal half filled tray calculation ***
          calculateAndPopulateHalfFilledTraysOptimal(data, Math.max(0, newLotQty));
        }
          // Update Add Model button state
          const currentEmptySlots = parseInt(emptySlotInput.value) || 0;
          updateAddModelButtonState(currentEmptySlots);
          
          // === UPDATE DE-LINK TRAY TABLE WITH OPTIMAL DISTRIBUTION ===
          if (!isDraftMode || !data.draft_data.delink_tray_data || data.draft_data.delink_tray_data.length === 0) {
            // Generate optimal distribution for the adjusted quantity
            const trayCapacity = data.tray_capacity || 12;
            const adjustedQty = Math.max(0, newLotQty);
          
            // Create theoretical optimal distribution
            const completeTrays = Math.floor(adjustedQty / trayCapacity);
            const remainder = adjustedQty % trayCapacity;
          
            console.log(`Recalculating optimal distribution for ${adjustedQty}: ${completeTrays} complete + ${remainder} remainder`);
          
            // Rebuild tray table with optimal distribution
            const recalculatedTrayTable = document.getElementById('delinkTrayTable');
            recalculatedTrayTable.innerHTML = `
              <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
              <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
            `;
          
            let trayIndex = 1;
          
            // Add complete trays
            for (let i = 0; i < completeTrays; i++) {
              recalculatedTrayTable.innerHTML += `
                <div>${trayIndex}</div>
                <div>
                  <input type="text"
                    value=""
                    placeholder="Scan any valid tray ID"
                    data-lot-id="${data.stock_lot_id || ''}"
                    data-expected-usage="${trayCapacity}"
                    data-is-top-tray="false"
                    data-original-tray-qty="${trayCapacity}"
                    data-theoretical="true"
                    style="width:100%; border:none; background:transparent;"
                  />
          
                </div>
              `;
              trayIndex++;
            }
          
            // Add partial tray if remainder exists
            if (remainder > 0) {
              recalculatedTrayTable.innerHTML += `
                <div>${trayIndex}</div>
                <div>
                  <input type="text"
                    value=""
                    placeholder="Scan any valid tray ID"
                    data-lot-id="${data.stock_lot_id || ''}"
                    data-expected-usage="${remainder}"
                    data-is-top-tray="true"
                    data-original-tray-qty="${trayCapacity}"
                    data-theoretical="true"
                    style="width:100%; border:none; background:transparent;"
                  />
                  <div class="usage-hint" style="font-size: 10px; color: #666; margin-top: 2px;">
                    Top Tray: ${remainder} pieces (partial tray)
                  </div>
                </div>
              `;
            }
          }
        });
     
     
      }

      // Update Add Model button state
      updateAddModelButtonState(finalEmptySlots);

      // Populate model slider
      const slider = document.getElementById('modelSliderDynamic');
      slider.innerHTML = '';
      
      let lotIdsToShow = [];
      if (isDraftMode && data.draft_data && data.draft_data.new_lot_ids && data.draft_data.new_lot_ids.length > 0) {
        lotIdsToShow = data.draft_data.new_lot_ids;
      } else if (window.currentLotIds && window.currentLotIds.length > 0) {
        lotIdsToShow = window.currentLotIds;
      } else if (currentModalLotId) {
        lotIdsToShow = [currentModalLotId];
      }
      
      // For each lot_id, fetch model info and add to slider
      await Promise.all(lotIdsToShow.map(async (lotId, idx) => {
        try {
          const resp = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
          const lotData = await resp.json();
          const modelData = {
            modelNo: lotData.model_no || '-',
            image: (lotData.model_images && lotData.model_images.length > 0) ? lotData.model_images[0] : '/static/assets/images/imagePlaceholder.png',
            isOriginal: idx === 0 // Mark first as original
          };
          const item = createModelItem(modelData);
          slider.appendChild(item);
        } catch (err) {
          // fallback if error
          const item = createModelItem({ modelNo: 'Unknown', image: '/static/assets/images/imagePlaceholder.png', isOriginal: idx === 0 });
          slider.appendChild(item);
        }
      }));
      
      // Update slider position
      setTimeout(updateSliderPosition, 100);

      // Store original data after modal is populated
      setTimeout(() => {
        storeOriginalModalData();
      }, 200);
    } catch (error) {
      console.error('Error fetching jig data:', error);
      showModalMessage('error', 'Data Loading Error', 'Failed to load jig data. Please try again.', { duration: 5000 });
    }
  });
});

// === HELPER FUNCTION: FILTER TO SHOW ONLY TOP TRAY FOR VERIFICATION ===
function filterToTopTrayOnly(halfFilledTrays) {
  if (!halfFilledTrays || halfFilledTrays.length === 0) {
    return [];
  }
  
  console.log('Filtering half filled trays to show only top tray for verification');
  
  // Only show the top tray (the one that's actually partial/needs verification)
  // or if all trays are complete, show only the last one
  const topTray = halfFilledTrays.find(tray => tray.is_top_tray) || halfFilledTrays[halfFilledTrays.length - 1];
  
  if (topTray) {
    console.log(`Showing only top tray for verification: ${topTray.tray_id} with qty ${topTray.tray_quantity}`);
    return [topTray];
  }
  
  return [];
}

// === ENHANCED: HELPER FUNCTION TO CALCULATE AND POPULATE HALF FILLED TRAYS ===
function calculateAndPopulateHalfFilledTrays(data, adjustedDisplayQty) {
  const originalQty = data.original_quantity || data.brass_audit_accepted_qty || 0;
  let qtyToDistribute = adjustedDisplayQty;
  const allTrays = data.original_trays || data.trays || [];
  let usedTrays = [];
  let topTray = null;

  for (let i = 0; i < allTrays.length; i++) {
    const tray = allTrays[i];
    const trayQty = parseInt(tray.tray_quantity) || 0;
    if (qtyToDistribute >= trayQty) {
      qtyToDistribute -= trayQty;
      usedTrays.push(tray.tray_id);
    }else if (qtyToDistribute > 0) {
      // This is the top tray, partially used
      topTray = {
        tray_id: tray.tray_id,
        tray_quantity: qtyToDistribute, // <-- FIX: show used pieces, not remaining
        original_tray_quantity: trayQty,
        is_top_tray: true,
        lot_id: tray.lot_id || data.stock_lot_id || currentModalLotId
      };
      qtyToDistribute = 0;
      break;
    }
  }

  if (topTray && topTray.tray_quantity > 0) {
    populateHalfFilledTrayTable([topTray]);
  } else {
    populateHalfFilledTrayTable([]);
  }
}

// Update the populateHalfFilledTrayTable function to show the correct remaining quantity:

function populateHalfFilledTrayTable(halfFilledTrays) {
  const table = document.getElementById('halfFilledTrayTable');
  const halfFilledSection = document.getElementById('halfFilledTraySection');

  console.log('Populating half filled tray table with physical constraints:', halfFilledTrays);

  // Hide table if no valid trays
  const shouldHideTable = (
    !halfFilledTrays ||
    halfFilledTrays.length === 0 ||
    (Array.isArray(halfFilledTrays) && halfFilledTrays.every(tray => !tray || tray.tray_quantity <= 0))
  );

  if (shouldHideTable) {
    console.log('Hiding half filled tray table - no remaining quantity');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }

  console.log('Showing half filled tray table with remaining quantity');
  if (halfFilledSection) halfFilledSection.style.display = 'block';

  // Table headers
  table.innerHTML = `
    <div style="background: #d1f2f3; font-weight: bold;">Tray ID</div>
    <div style="background: #d1f2f3; font-weight: bold;">Tray Quantity</div>
  `;

  halfFilledTrays.forEach((tray, idx) => {
    if (!tray || !tray.tray_id || tray.tray_quantity <= 0) return;

    const verificationLabel = '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Verification Required</span>';

    // Enhanced info for remaining quantity
    const constraintInfo = `<div style="font-size:10px;color:#007bff;margin-top:1px;font-style:italic;">Remaining after optimal delink distribution</div>`;

    table.innerHTML += `
      <div>
        <input type="text"
          value=""
          placeholder="Scan remaining tray ID"
          data-expected-tray-id="${tray.tray_id}"
          data-qty="${tray.tray_quantity}"
          data-original-qty="${tray.original_tray_quantity || tray.tray_quantity}"
          data-top-tray="true"
          data-lot-id="${tray.lot_id || ''}"
          data-verification="true"
          style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;"
        />
        ${constraintInfo}
      </div>
      <div>
        <input type="number"
          value="${tray.tray_quantity}"
          readonly
          style="background: #f9f9f9; border: 1px solid #ddd; width: 80px; text-align: center; padding: 4px; border-radius: 4px;"
        />
        ${verificationLabel}
        <div style="font-size:9px;color:#666;margin-top:1px;">
          Total available: ${tray.original_tray_quantity || tray.tray_quantity}
        </div>
      </div>
    `;
  });

  console.log(`Populated ${halfFilledTrays.length} half filled tray entries with physical constraints`);
}

// *** NEW: Function to populate half filled tray table from draft data ***
function populateHalfFilledTrayTableFromDraft(draftHalfFilledData) {
  const table = document.getElementById('halfFilledTrayTable');
  const halfFilledSection = document.getElementById('halfFilledTraySection');
  
  console.log('ðŸ”„ Populating half filled tray table from draft data:', draftHalfFilledData);
  
  if (!draftHalfFilledData || draftHalfFilledData.length === 0) {
    console.log('âŒ No draft half filled data - hiding table');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }
  
  console.log('âœ… Showing half filled tray table with draft data');
  if (halfFilledSection) halfFilledSection.style.display = 'block';
  
  // Table headers
  table.innerHTML = `
    <div style="background: #d1f2f3; font-weight: bold;">Tray ID</div>
    <div style="background: #d1f2f3; font-weight: bold;">Tray Quantity</div>
  `;
  
  draftHalfFilledData.forEach((item, idx) => {
    if (!item || !item.tray_id || item.tray_quantity <= 0) return;
    
    const verificationLabel = item.is_multi_model 
      ? '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Multi-Model Draft</span>'
      : '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Draft Data</span>';
    
    const modelInfo = item.model_no 
      ? `<div style="font-size:10px;color:#007bff;margin-top:1px;font-style:italic;">Model: ${item.model_no}</div>`
      : '';
    
    table.innerHTML += `
      <div>
        <input type="text"
          value="${item.tray_id}"
          placeholder="Scan tray ID"
          data-expected-tray-id="${item.tray_id}"
          data-qty="${item.tray_quantity}"
          data-original-qty="${item.original_tray_quantity || item.tray_quantity}"
          data-top-tray="${item.is_top_tray}"
          data-lot-id="${item.lot_id || ''}"
          data-model-no="${item.model_no || ''}"
          data-verification="true"
          data-multi-model="${item.is_multi_model || false}"
          data-from-draft="true"
          style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px; background: #fff5bd;"
        />
        ${modelInfo}
      </div>
      <div>
        <input type="number"
          value="${item.tray_quantity}"
          readonly
          style="background: #f9f9f9; border: 1px solid #ddd; width: 80px; text-align: center; padding: 4px; border-radius: 4px;"
        />
        ${verificationLabel}
        <div style="font-size:9px;color:#666;margin-top:1px;">
          Available: ${item.original_tray_quantity || item.tray_quantity}
        </div>
      </div>
    `;
  });
  
  console.log(`âœ… Populated ${draftHalfFilledData.length} draft half filled tray entries`);
}


// FIXED: Enhanced logic for checking when to show half filled table
function shouldShowHalfFilledTable(data, displayQty, originalQty, jigCapacity) {
  // Don't show if no half filled trays data
  if (!data.half_filled_trays || data.half_filled_trays.length === 0) {
    console.log("No half filled trays data - hiding table");
    return false;
  }
  
  // Don't show if jig is fully utilized (display qty equals original qty)
  if (displayQty >= originalQty) {
    console.log(`Jig fully utilized (${displayQty} >= ${originalQty}) - hiding half filled table`);
    return false;
  }
  
  // Don't show if display qty equals jig capacity and original qty
  if (displayQty === jigCapacity && displayQty === originalQty) {
    console.log(`Jig fully utilized with all available quantity (${displayQty} = ${jigCapacity} = ${originalQty}) - hiding half filled table`);
    return false;
  }
  
  // Don't show if backend explicitly says not to show
  if (data.show_half_filled_table === false) {
    console.log("Backend says don't show half filled table");
    return false;
  }
  
  // Don't show if jig_fully_utilized flag is set
  if (data.jig_fully_utilized === true) {
    console.log("Jig fully utilized flag is true - hiding half filled table");
    return false;
  }
  
  console.log("Half filled table should be shown");
  return true;
}
// *** ENHANCED: Auto-fill function for half filled trays ***
function autoFillTrayQty(input) {
  const enteredTrayId = input.value.trim();
  const usedQty = parseInt(input.getAttribute('data-qty')) || 0;
  const originalQty = parseInt(input.getAttribute('data-original-qty')) || usedQty;
  const isTop = input.getAttribute('data-top-tray') === 'true';
  const lotId = input.getAttribute('data-lot-id') || '';
  const isTheoretical = input.getAttribute('data-theoretical') === 'true';
  
  // Remove any existing validation messages
  const existingMsg = input.parentNode.querySelector('.half-tray-validation');
  if (existingMsg) {
    existingMsg.remove();
  }
  
  // Reset styling
  input.style.background = '';
  input.style.borderColor = '';
  
  if (!enteredTrayId) {
    // Empty input - reset to default used quantity
    const qtyInput = input.parentNode.nextElementSibling?.querySelector('input[type="number"]');
    if (qtyInput) {
      qtyInput.value = usedQty;
    }
    return;
  }
  
  // *** NEW: Set the lot_id data attribute for backend processing ***
  input.setAttribute('data-lot-id', lotId);
  
  // Accept any tray ID since this is optimal/theoretical distribution
  const qtyInput = input.parentNode.nextElementSibling?.querySelector('input[type="number"]');
  if (qtyInput) {
    qtyInput.value = usedQty;  // Show the optimal used quantity
  }
  
  // Visual feedback for theoretical distribution
  input.style.background = isTheoretical ? '#e8f5e8' : '#fff3cd';
  input.style.borderColor = isTheoretical ? '#28a745' : '#ffc107';
  
  // Mark as top tray visually if applicable
  if (isTop) {
    input.style.fontWeight = 'bold';
  }
  
  // Add success message with optimal distribution info
  const successMsg = document.createElement('div');
  successMsg.className = 'half-tray-validation';
  successMsg.style.cssText = 'color: green; font-size: 11px; margin-top: 2px;';
  
  if (isTop) {
    successMsg.textContent = `âœ“ Optimal Top Tray: ${usedQty}/${originalQty} pieces (users can shuffle manually)`;
  } else {
    successMsg.textContent = `âœ“ Optimal Complete Tray: ${usedQty} pieces (users can shuffle manually)`;
  }
  
  input.parentNode.appendChild(successMsg);
  
  console.log(`Auto-filled optimal tray ${enteredTrayId} - Used: ${usedQty}/${originalQty}${isTop ? ' (Top)' : ' (Complete)'} for lot: ${lotId}`);
}

function populateDelinkTrayTableFromCalculation(data, trayTable, displayQty) {
  // Clear previous rows except headers
  trayTable.innerHTML = `
    <div style="background: #d1f2f3; font-weight: bold;">S.No</div>
    <div style="background: #d1f2f3; font-weight: bold;">Tray ID</div>
  `;

  if (data.trays && data.trays.length > 0) {
    // Show optimal tray distribution based on physical constraints
    data.trays.forEach((tray, idx) => {
      // Create usage description
      const usageDescription = `Complete: ${tray.used_quantity} pieces (full tray)`;
      
      // Create hint for expected usage
      const usageHint = `Expected: ${tray.used_quantity} pieces (Complete)`;
      
      trayTable.innerHTML += `
        <div>${idx + 1}</div>
        <div>
          <input type="text"
            value=""
            placeholder="Scan any valid tray ID"
            data-lot-id="${tray.lot_id || ''}"
            data-expected-usage="${tray.used_quantity}"
            data-is-top-tray="false"
            data-original-tray-qty="${tray.original_tray_quantity || tray.tray_quantity}"
            data-theoretical="true"
            title="${usageHint}"
            style="width:100%; border:none; background:transparent;"
          />


        </div>
      `;
    });
    
    // Add info about remaining quantity if any
    const totalUsedInDelink = data.trays.reduce((sum, tray) => sum + (tray.used_quantity || 0), 0);
    const remainingQty = displayQty - totalUsedInDelink;
    
    if (remainingQty > 0) {
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 10px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
          â„¹ï¸ ${remainingQty} pieces will be handled in Half Filled Tray section
        </div>
      `;
    }
  } else {
    trayTable.innerHTML += `
      <div style="grid-column: span 2; text-align:center; padding: 20px; color: #666;">
        No optimal distribution found for quantity ${displayQty}
      </div>
    `;
  }
} 

// === COMPLETELY FIXED: CALCULATE HALF FILLED TRAYS FOR FAULTY SLOTS (OPTIMAL) ===
function calculateAndPopulateHalfFilledTraysOptimal(data, adjustedDisplayQty) {
  const originalQty = data.original_quantity || data.brass_audit_accepted_qty || 0;
  const trayCapacity = data.tray_capacity; // Get tray capacity
  
  // FIXED: Calculate remaining quantity after this jig (direct calculation)
  const remainingQtyAfterJig = originalQty - adjustedDisplayQty;
  
  console.log(`HALF FILLED OPTIMAL CALCULATION (COMPLETELY FIXED):`);
  console.log(`  Original qty: ${originalQty}`);
  console.log(`  Adjusted display qty: ${adjustedDisplayQty}`);
  console.log(`  DIRECT CALCULATION: Remaining = ${originalQty} - ${adjustedDisplayQty} = ${remainingQtyAfterJig}`);
  console.log(`  Tray capacity: ${trayCapacity}`);
  
  if (remainingQtyAfterJig <= 0) {
    console.log(`  No remaining quantity, hiding half filled table`);
    populateHalfFilledTrayTable([]);
    return;
  }
  
  // FIXED: Generate optimal distribution for remaining quantity
  const completeTrays = Math.floor(remainingQtyAfterJig / trayCapacity);
  const remainder = remainingQtyAfterJig % trayCapacity;
  
  console.log(`  Distribution: ${remainingQtyAfterJig} Ã· ${trayCapacity} = ${completeTrays} complete + ${remainder} remainder`);
  
  let halfFilledTrays = [];
  
  // FIXED: ONLY show the top tray (remainder) for verification, not complete trays
  if (remainder > 0) {
    halfFilledTrays.push({
      tray_id: `TOP-TRAY`,
      tray_quantity: remainder,  // FIXED: Only the remainder portion
      original_tray_quantity: trayCapacity,
      is_top_tray: true,  // This is the top tray
      lot_id: data.stock_lot_id || currentModalLotId,
      theoretical: true
    });
    
    console.log(`  âœ“ TOP TRAY: ${remainder} pieces (remainder only)`);
  } else if (completeTrays > 0) {
    // If only complete trays remain, show one for verification
    halfFilledTrays.push({
      tray_id: `COMPLETE-TRAY`,
      tray_quantity: trayCapacity,
      original_tray_quantity: trayCapacity,
      is_top_tray: false,
      lot_id: data.stock_lot_id || currentModalLotId,
      theoretical: true
    });
    
    console.log(`  âœ“ COMPLETE TRAY: ${trayCapacity} pieces`);
  }
  
  console.log(`  Result: ${halfFilledTrays.length} half filled trays`);
  populateHalfFilledTrayTable(halfFilledTrays);
}


// *** ENHANCED: Calculate Half Filled Trays for Multi-Model Selection ***
async function calculateMultiModelHalfFilledTrays(validResults, calculatedLotIdQuantities) {
  const combinedHalfFilledTrays = [];
  
  console.log('Calculating half filled trays for multi-model selection');
  console.log('Calculated lot quantities:', calculatedLotIdQuantities);
  
  // For each lot, calculate if it has remaining quantity after this jig
  for (const result of validResults) {
    const lotId = result.original_lot_id;
    const originalQty = result.original_quantity || result.brass_audit_accepted_qty || 0;
    const usedQtyForJig = calculatedLotIdQuantities[lotId] || 0;
    const remainingQtyAfterJig = originalQty - usedQtyForJig;
    
    console.log(`Lot ${lotId}:`);
    console.log(`  Original qty: ${originalQty}`);
    console.log(`  Used for this jig: ${usedQtyForJig}`);
    console.log(`  Remaining after jig: ${remainingQtyAfterJig}`);
    
    if (remainingQtyAfterJig > 0) {
      // This lot has remaining quantity, calculate its half filled trays
      const trayCapacity = result.tray_capacity || 12;
      
      // Calculate optimal distribution for remaining quantity
      const completeTrays = Math.floor(remainingQtyAfterJig / trayCapacity);
      const remainder = remainingQtyAfterJig % trayCapacity;
      
      console.log(`  Optimal distribution: ${completeTrays} complete + ${remainder} remainder`);
      
      let lotTrayIndex = 1;
      
      // Add complete trays
      for (let i = 0; i < completeTrays; i++) {
        combinedHalfFilledTrays.push({
          tray_id: `${result.model_no}-TRAY-${lotTrayIndex}`,
          tray_quantity: trayCapacity,
          original_tray_quantity: trayCapacity,
          is_top_tray: false,
          lot_id: lotId,
          model_no: result.model_no,
          theoretical: true
        });
        
        console.log(`    Complete tray ${lotTrayIndex}: ${trayCapacity}/${trayCapacity} pieces`);
        lotTrayIndex++;
      }
      
      // Add partial tray if remainder exists
      if (remainder > 0) {
        combinedHalfFilledTrays.push({
          tray_id: `${result.model_no}-TRAY-${lotTrayIndex}`,
          tray_quantity: remainder,
          original_tray_quantity: trayCapacity,
          is_top_tray: true,
          lot_id: lotId,
          model_no: result.model_no,
          theoretical: true
        });
        
        console.log(`    Top tray ${lotTrayIndex}: ${remainder}/${trayCapacity} pieces`);
      }
    } else {
      console.log(`  No remaining quantity for lot ${lotId}`);
    }
  }
  
  console.log(`Total combined half filled trays: ${combinedHalfFilledTrays.length}`);
  return combinedHalfFilledTrays;
}

// UPDATED: Event listener for flexible tray validation
document.addEventListener('input', function(e) {
  const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
  if (trayInput && trayInput.hasAttribute('data-available-trays')) {
    clearTimeout(trayInput.validationTimeout);
    trayInput.validationTimeout = setTimeout(() => {
      validateFlexibleTrayId(trayInput);
    }, 300);
  }
});

// Add event listener for real-time tray validation
document.addEventListener('input', function(e) {
  const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
  if (trayInput && trayInput.hasAttribute('data-expected-tray-id')) {
    validateExpectedTrayId(trayInput);
  }
});

// *** UPDATED: Enhanced modal data collection for multi-model ***
function collectModalData() {
  const jigQrId = document.getElementById('modalJigQrId').value.trim();
  const faultySlots = parseInt(document.getElementById('modalFaultySlots').value) || 0;
  const emptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
  const totalCasesLoaded = parseInt(document.getElementById('modalLotQty').value) || 0;

  const modelNumbers = [];
  document.querySelectorAll('#modelSliderDynamic .model-loaded-item').forEach(item => {
    const modelText = item.textContent;
    const modelMatch = modelText.match(/Model No:\s*([^\s]+)/);
    if (modelMatch) {
      modelNumbers.push(modelMatch[1]);
    }
  });

  const lotIds = (window.currentLotIds && Array.isArray(window.currentLotIds)) ? window.currentLotIds.slice() : [];
  
  const lotIdQuantities = {};
  
  const hasMultipleModels = document.querySelectorAll('.model-select-checkbox:checked').length > 0;
  
  if (hasMultipleModels && window.currentLotIdQuantities) {
    console.log('Using calculated lot_id_quantities from modal:', window.currentLotIdQuantities);
    Object.assign(lotIdQuantities, window.currentLotIdQuantities);
  } else {
    console.log('Single model - using table row quantities');
    
    if (currentModalLotId) {
      const row = document.querySelector(`.open-jig-modal-btn[data-stock-lot-id="${currentModalLotId}"]`)?.closest('tr');
      let originalQty = 0;
      if (row) {
        const qtyInput = row.querySelector('.edit-qty-input');
        originalQty = qtyInput ? parseInt(qtyInput.value) || 0 : 0;
      }
      if (originalQty > 0) {
        if (!lotIds.includes(currentModalLotId)) {
          lotIds.push(currentModalLotId);
        }
        lotIdQuantities[currentModalLotId] = originalQty;
      }
    }

    document.querySelectorAll('.model-select-checkbox:checked').forEach(checkbox => {
      const stockLotId = checkbox.getAttribute('data-stock-lot-id');
      if (stockLotId && !lotIds.includes(stockLotId)) {
        const row = checkbox.closest('tr');
        const qtyInput = row.querySelector('.edit-qty-input');
        const qty = qtyInput ? parseInt(qtyInput.value) || 0 : 0;
        if (qty > 0) {
          lotIds.push(stockLotId);
          lotIdQuantities[stockLotId] = qty;
        }
      }
    });
  }

  // *** ENHANCED: Better delink tray data collection for multi-model ***
  const delinkTrayData = [];
  const trayTable = document.getElementById('delinkTrayTable');
  
  console.log('=== ENHANCED DELINK TRAY COLLECTION ===');
  
  if (trayTable) {
    const trayInputs = trayTable.querySelectorAll('input[type="text"]');
    console.log('Found tray inputs:', trayInputs.length);
    
    trayInputs.forEach((trayInput, index) => {
      const trayId = trayInput.value.trim();
      const lotId = trayInput.getAttribute('data-lot-id') || '';
      const expectedUsage = parseInt(trayInput.getAttribute('data-expected-usage')) || 0;
      const isBackendOptimal = trayInput.getAttribute('data-backend-optimal') === 'true';
      
      console.log(`Delink Tray ${index + 1}: ID="${trayId}", Lot="${lotId}", Expected=${expectedUsage}, BackendOptimal=${isBackendOptimal}`);
      
      // Include all tray entries for backend processing
      delinkTrayData.push({
        tray_id: trayId,
        lot_id: lotId,
        expected_usage: expectedUsage,
        is_backend_optimal: isBackendOptimal,
        row_index: index + 1
      });
    });
  }

  // *** ENHANCED: Better half-filled tray data collection for multi-model ***
  const halfFilledTrayData = [];
  const halfFilledTable = document.getElementById('halfFilledTrayTable');
  
  console.log('=== ENHANCED HALF-FILLED TRAY COLLECTION (WITH DRAFT SUPPORT) ===');
  
  if (halfFilledTable) {
    const trayIdInputs = halfFilledTable.querySelectorAll('input[type="text"]');
    const qtyInputs = halfFilledTable.querySelectorAll('input[type="number"]');
    
    console.log('Found half-filled inputs:', trayIdInputs.length, 'qty inputs:', qtyInputs.length);
    
    for (let i = 0; i < Math.min(trayIdInputs.length, qtyInputs.length); i++) {
      const trayInput = trayIdInputs[i];
      const qtyInput = qtyInputs[i];
      
      const trayId = trayInput.value.trim();
      const qty = parseInt(qtyInput.value) || 0;
      const lotId = trayInput.getAttribute('data-lot-id') || '';
      const modelNo = trayInput.getAttribute('data-model-no') || '';
      const isTopTray = trayInput.getAttribute('data-top-tray') === 'true';
      const isMultiModel = trayInput.getAttribute('data-multi-model') === 'true';
      const fromDraft = trayInput.getAttribute('data-from-draft') === 'true';
      const originalQty = parseInt(trayInput.getAttribute('data-original-qty')) || qty;
      
      console.log(`Half-Filled ${i + 1}: ID="${trayId}", Qty=${qty}, Lot="${lotId}", Model="${modelNo}", MultiModel=${isMultiModel}, FromDraft=${fromDraft}`);
      
      if (trayId || qty > 0) {
        halfFilledTrayData.push({
          tray_id: trayId,
          tray_quantity: qty,
          original_tray_quantity: originalQty,
          lot_id: lotId,
          model_no: modelNo,
          is_top_tray: isTopTray,
          is_multi_model: isMultiModel,
          from_draft: fromDraft,
          row_index: i + 1
        });
      }
    }
  }
  console.log('=== ENHANCED COLLECTION RESULTS ===');
  console.log('delinkTrayData:', delinkTrayData);
  console.log('halfFilledTrayData:', halfFilledTrayData);

  return {
    jig_qr_id: jigQrId,
    faulty_slots: faultySlots,
    empty_slots: emptySlots,
    total_cases_loaded: totalCasesLoaded,
    model_numbers: modelNumbers,
    lot_ids: lotIds,
    lot_id_quantities: lotIdQuantities,
    delink_tray_data: delinkTrayData, 
    half_filled_tray_data: halfFilledTrayData,
    primary_lot_id: lotIds.length > 0 ? lotIds[0] : '',
    draft_id: window.currentDraftId || null,
    is_multi_model: hasMultipleModels,
    multi_model_distribution: window.currentMultiModelDistribution || null
  };
}

// *** NEW: Function to validate if half filled section should be shown ***
function shouldShowHalfFilledSectionForDraft(draftData, calculatedData) {
  // If draft has saved half_filled_tray_data, always show it
  if (draftData && draftData.half_filled_tray_data && draftData.half_filled_tray_data.length > 0) {
    console.log("âœ… Showing half filled section: Draft has saved data");
    return true;
  }
  
  // Otherwise use the normal calculation logic
  if (calculatedData && calculatedData.half_filled_trays && calculatedData.show_half_filled_table) {
    const displayQty = parseInt(draftData?.total_cases_loaded || calculatedData.display_qty || 0);
    const originalQty = calculatedData.original_quantity || 0;
    const jigFullyUtilized = calculatedData.jig_fully_utilized || false;
    
    const shouldShow = displayQty < originalQty && !jigFullyUtilized;
    console.log(`ðŸ“Š Showing half filled section: ${shouldShow} (displayQty: ${displayQty}, originalQty: ${originalQty}, jigFullyUtilized: ${jigFullyUtilized})`);
    return shouldShow;
  }
  
  console.log("âŒ Not showing half filled section: No data");
  return false;
}

// Add this at the top of your script to track checkbox selection order
let checkboxSelectionOrder = [];

// *** UPDATED: Enhanced multi-model checkbox change handler ***
document.querySelectorAll('.model-select-checkbox').forEach(function(checkbox) {
  checkbox.addEventListener('change', async function() {
    // Check if checkbox is disabled due to full jig
    if (checkbox.disabled) {
      showModalMessage('warning', 'Cannot Select', 'Jig is full. Cannot add more models.', { duration: 3000 });
      checkbox.checked = false;
      return;
    }
    
    // Update checkbox selection order tracking
    const stockLotId = checkbox.getAttribute('data-stock-lot-id') || checkbox.closest('tr').querySelector('.open-jig-modal-btn')?.getAttribute('data-stock-lot-id');
    
    if (checkbox.checked && stockLotId) {
      // Add to selection order if not already present
      if (!checkboxSelectionOrder.includes(stockLotId)) {
        checkboxSelectionOrder.push(stockLotId);
        console.log('Added to selection order:', stockLotId, 'Order:', checkboxSelectionOrder);
      }
    } else if (!checkbox.checked && stockLotId) {
      // Remove from selection order if unchecked
      const index = checkboxSelectionOrder.indexOf(stockLotId);
      if (index > -1) {
        checkboxSelectionOrder.splice(index, 1);
        console.log('Removed from selection order:', stockLotId, 'Order:', checkboxSelectionOrder);
      }
    }
    const allLotIds = [window.initialLotId, ...checkboxSelectionOrder.filter(id => id !== window.initialLotId)];
    window.currentLotIds = allLotIds;

    
    const checked = Array.from(document.querySelectorAll('.model-select-checkbox:checked'));
    
    // Update status indicator
    updateSelectedItemsStatus();
    
    if (checked.length === 0) {
      // Reset selection order when no checkboxes are selected
      checkboxSelectionOrder = [];
      console.log('Reset selection order');
      
      // If no checkboxes are selected, restore original data and rebuild slider
      if (originalModalData) {
        document.getElementById('rightModalModelNo').textContent = originalModalData.modelNo;
        document.getElementById('modalBathType').value = originalModalData.bathType;
        document.getElementById('modalJigCapacity').value = originalModalData.jigCapacity;
        document.getElementById('modalLotQty').value = originalModalData.lotQty;
        
        // Recalculate Empty Slots for original data
        const jigCapacity = parseInt(originalModalData.jigCapacity) || 0;
        const lotQty = parseInt(originalModalData.lotQty) || 0;
        const emptySlots = Math.max(0, jigCapacity - lotQty);
        document.getElementById('modalEmptySlots').value = emptySlots;

        updateAddModelButtonState(emptySlots);
        
        document.getElementById('delinkTrayTable').innerHTML = originalModalData.trayTableContent;
        
        // Hide half filled tray table when returning to original
        populateHalfFilledTrayTable([]);
        
        // Rebuild slider with original model only
        const slider = document.getElementById('modelSliderDynamic');
        slider.innerHTML = '';
        
        if (currentModalLotId) {
          try {
            const response = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
            const data = await response.json();
            
            const modelData = {
              modelNo: data.model_no || originalModalData.modelNo,
              image: (data.model_images && data.model_images.length > 0) ? data.model_images[0] : '/static/assets/images/imagePlaceholder.png',
              isOriginal: true
            };
            const item = createModelItem(modelData);
            slider.appendChild(item);
            
            // Show half filled tray table for original data if applicable (only top tray)
            const shouldShowHalfFilled = data.half_filled_trays && data.show_half_filled_table && 
              data.display_qty < (data.original_quantity || 0) && !data.jig_fully_utilized;
            if (shouldShowHalfFilled) {
              const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
              populateHalfFilledTrayTable(topTrayOnly);
            }
          } catch (error) {
            console.error('Error rebuilding original slider:', error);
            const modelData = {
              modelNo: originalModalData.modelNo,
              image: '/static/assets/images/imagePlaceholder.png',
              isOriginal: true
            };
            const item = createModelItem(modelData);
            slider.appendChild(item);
          }
        }
        
        setTimeout(updateSliderPosition, 100);
      }
      return;
    }

    // SHOW the modal again when checkbox is selected
    const modal = document.getElementById('rightSideModal');
    if (modal) {
      modal.style.display = 'block';
      modal.classList.add('open');
      modal.classList.remove('minimized');
      
      // Reset any forced styling
      modal.style.width = '';
      modal.style.height = '';
      modal.style.top = '';
      modal.style.right = '';
    }

    // Fetch details for all selected lots IN SELECTION ORDER
    const stockLotIds = checkboxSelectionOrder.filter(lotId => {
      // Only include lot IDs that are still checked
      const checkbox = document.querySelector(`.model-select-checkbox[data-stock-lot-id="${lotId}"]`);
      return checkbox && checkbox.checked;
    });

    console.log('Processing selected lot IDs in order:', stockLotIds);

    // Fetch all data in parallel but maintain selection order
    const results = await Promise.all(stockLotIds.map(lotId =>
      fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(data => ({ ...data, original_lot_id: lotId })) // Preserve original lot_id for ordering
        .catch(error => {
          console.error(`Error fetching data for lot ${lotId}:`, error);
          return null;
        })
    ));

    const validResults = results.filter(r => r && !r.error);
    console.log('Valid results in selection order:', validResults.map(r => r.original_lot_id));

    if (validResults.length === 0) {
      console.warn('No valid results from checkbox selections');
      return;
    }

    // Combine data - ALLOW DUPLICATE MODEL NUMBERS
    let combinedModelNos = [];
    let combinedLotQtys = [];
    let combinedBathTypes = [];
    let combinedJigCapacities = [];
    let combinedTraysData = []; // Store all tray data for later processing
    let combinedHalfFilledTrays = []; // Store all half filled tray data

    // Add original data if available
    if (originalModalData && originalModalData.modelNo !== '-') {
      combinedModelNos.push(originalModalData.modelNo);
      if (originalModalData.lotQty) combinedLotQtys.push(parseInt(originalModalData.lotQty));
      if (originalModalData.bathType) combinedBathTypes.push(originalModalData.bathType);
      if (originalModalData.jigCapacity) combinedJigCapacities.push(originalModalData.jigCapacity);
      
      // Get original tray data
      if (currentModalLotId) {
        try {
          const originalResponse = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
          const originalData = await originalResponse.json();
          if (originalData.trays) {
            combinedTraysData.push({
              lot_id: currentModalLotId,
              model_no: originalModalData.modelNo,
              trays: originalData.trays,
              isOriginal: true
            });
          }
          // Add original half filled trays
          if (originalData.half_filled_trays && originalData.show_half_filled_table) {
            combinedHalfFilledTrays.push(...originalData.half_filled_trays);
          }
        } catch (error) {
          console.error('Error fetching original tray data:', error);
        }
      }
    }

    // Add checkbox data IN SELECTION ORDER - ALLOW DUPLICATES
    validResults.forEach((r, index) => {
      // ALWAYS ADD THE MODEL NUMBER (even if it's duplicate)
      if (r.model_no) combinedModelNos.push(r.model_no);
      
      if (r.trays && Array.isArray(r.trays)) {
        const lotQty = r.trays.reduce((sum, t) => sum + (parseInt(t.tray_quantity) || 0), 0);
        if (lotQty > 0) combinedLotQtys.push(lotQty);
        
        // Store tray data with associated lot_id IN SELECTION ORDER
        combinedTraysData.push({
          lot_id: r.original_lot_id, // Use the preserved original lot_id
          model_no: r.model_no,
          trays: r.trays,
          isOriginal: false,
          selectionIndex: index // Track selection order
        });
      }
      
      // Add half filled trays from each selected lot
      if (r.half_filled_trays && r.show_half_filled_table) {
        combinedHalfFilledTrays.push(...r.half_filled_trays);
      }
      
      if (r.ep_bath_type) combinedBathTypes.push(r.ep_bath_type);
      if (r.jig_capacity) combinedJigCapacities.push(r.jig_capacity);
    });

    // Update modal fields with combined data
    document.getElementById('rightModalModelNo').textContent = combinedModelNos.join(', ') || '-';
    
    // === APPLY LOT QTY CAPPING LOGIC ===
    const originalJigCapacity = originalModalData ? (parseInt(originalModalData.jigCapacity) || 0) : 0;
    const uncappedTotalLotQty = combinedLotQtys.reduce((sum, qty) => sum + qty, 0);
    
    console.log(`Original Jig Capacity: ${originalJigCapacity}`);
    console.log(`Uncapped Total LOT Qty: ${uncappedTotalLotQty}`);
    
    // Cap the total LOT Qty to not exceed Jig Capacity
    const cappedTotalLotQty = Math.min(uncappedTotalLotQty, originalJigCapacity);
    
    console.log(`Capped Total LOT Qty: ${cappedTotalLotQty}`);
    
    // Show warning if we had to cap the quantity
    if (uncappedTotalLotQty > originalJigCapacity) {
      const excessQty = uncappedTotalLotQty - originalJigCapacity;
      showModalMessage('warning', 'LOT Quantity Capped', 
        `Total LOT quantity (${uncappedTotalLotQty}) exceeds Jig capacity (${originalJigCapacity}). Reduced by ${excessQty} to fit jig capacity.`, 
        { duration: 500 });
    }
    
    // Set the capped LOT Qty
    document.getElementById('modalLotQty').value = cappedTotalLotQty;
    
    // Bath Type: Only show if all are the same
    const uniqueBathTypes = [...new Set(combinedBathTypes)];
    if (uniqueBathTypes.length === 1) {
      document.getElementById('modalBathType').value = uniqueBathTypes[0];
    } else if (uniqueBathTypes.length > 1) {
      document.getElementById('modalBathType').value = 'Mixed Types';
    } else {
      document.getElementById('modalBathType').value = '';
    }
    
    // Jig Capacity: Always use the original/initial jig capacity
    document.getElementById('modalJigCapacity').value = originalJigCapacity;

    // Calculate Empty Slots: Original Jig Capacity - Capped LOT Qty
    const emptySlots = Math.max(0, originalJigCapacity - cappedTotalLotQty);
    document.getElementById('modalEmptySlots').value = emptySlots;

    // Store values for faulty slots calculation
    window.originalCombinedEmptySlots = emptySlots;
    window.originalCombinedLotQty = cappedTotalLotQty; // Use capped value

    // === Calculate Adjusted Tray Quantities ===
    function calculateAdjustedTrayQuantities(combinedTraysData, cappedTotalLotQty) {
      const adjustedTraysData = [];
      let remainingQtyToDistribute = cappedTotalLotQty;
      
      console.log(`Starting distribution with ${remainingQtyToDistribute} total quantity`);
      
      // Sort tray data to prioritize original lot first, then by selection order
      const sortedTraysData = [...combinedTraysData].sort((a, b) => {
        if (a.isOriginal && !b.isOriginal) return -1;
        if (!a.isOriginal && b.isOriginal) return 1;
        if (!a.isOriginal && !b.isOriginal) {
          return (a.selectionIndex || 0) - (b.selectionIndex || 0);
        }
        return 0;
      });
      
      // Distribute quantity across lots using complete-tray-only approach
      for (const trayGroup of sortedTraysData) {
        if (remainingQtyToDistribute <= 0) break;
        
        const { lot_id, model_no, trays } = trayGroup;
        let remainingForThisLot = remainingQtyToDistribute;
        
        console.log(`Processing lot ${lot_id} (${model_no}) with ${remainingForThisLot} remaining to distribute`);
        
        // FIXED: Distribute only complete trays within this lot
        for (const tray of trays) {
          if (remainingForThisLot <= 0) break;
          
          const originalTrayQty = parseInt(tray.tray_quantity) || 0;
          
          // FIXED LOGIC: Only use tray if we can take it completely
          if (remainingForThisLot >= originalTrayQty) {
            adjustedTraysData.push({
              tray_id: tray.tray_id,
              tray_quantity: originalTrayQty, // Use complete tray quantity
              lot_id: tray.lot_id,
              model_no: model_no,
              original_qty: originalTrayQty,
              is_complete: true
            });
            
            remainingForThisLot -= originalTrayQty;
            remainingQtyToDistribute -= originalTrayQty;
            
            console.log(`  Complete Tray ${tray.tray_id}: using ${originalTrayQty}/${originalTrayQty}, remaining: ${remainingForThisLot}`);
          } else {
            // This tray would be partially filled - skip it
            console.log(`  Skipping partial tray ${tray.tray_id}: would need ${remainingForThisLot} out of ${originalTrayQty}`);
          }
        }
      }
      
      console.log(`Final adjusted trays data (complete trays only):`, adjustedTraysData);
      return adjustedTraysData;
    }

    // === ENHANCED: CALCULATE AND STORE LOT ID QUANTITIES FOR MODAL DATA COLLECTION ===
    function calculateLotIdQuantitiesForModal(combinedTraysData, cappedTotalLotQty) {
      const calculatedLotIdQuantities = {};
      let remainingQtyToDistribute = cappedTotalLotQty;
      
      // Sort tray data to prioritize original lot first, then by selection order (same as tray calculation)
      const sortedTraysData = [...combinedTraysData].sort((a, b) => {
        if (a.isOriginal && !b.isOriginal) return -1;
        if (!a.isOriginal && b.isOriginal) return 1;
        if (!a.isOriginal && !b.isOriginal) {
          return (a.selectionIndex || 0) - (b.selectionIndex || 0);
        }
        return 0;
      });
      
      // Distribute quantity across lots using first-fill approach (same logic as tray distribution)
      for (const trayGroup of sortedTraysData) {
        if (remainingQtyToDistribute <= 0) break;
        
        const { lot_id, trays } = trayGroup;
        
        // Calculate total available quantity for this lot
        const totalLotCapacity = trays.reduce((sum, tray) => sum + (parseInt(tray.tray_quantity) || 0), 0);
        
        // Use the minimum of what's available in this lot or what we still need to distribute
        const usedQtyForThisLot = Math.min(totalLotCapacity, remainingQtyToDistribute);
        
        if (usedQtyForThisLot > 0) {
          calculatedLotIdQuantities[lot_id] = usedQtyForThisLot;
          remainingQtyToDistribute -= usedQtyForThisLot;
          
          console.log(`Calculated lot_id_quantities: ${lot_id} = ${usedQtyForThisLot}, remaining to distribute: ${remainingQtyToDistribute}`);
        }
      }
      
      console.log('Final calculated lot_id_quantities:', calculatedLotIdQuantities);
      return calculatedLotIdQuantities;
    }
    
    // Calculate adjusted tray quantities
    const adjustedTraysData = calculateAdjustedTrayQuantities(combinedTraysData, cappedTotalLotQty);

    // === ENHANCED: CALCULATE AND STORE LOT ID QUANTITIES FOR MODAL DATA COLLECTION ===
    const calculatedLotIdQuantities = calculateLotIdQuantitiesForModal(combinedTraysData, cappedTotalLotQty);
    
    // Store in global variable for collectModalData to use
    window.currentLotIdQuantities = calculatedLotIdQuantities;
    
    console.log('Stored window.currentLotIdQuantities:', window.currentLotIdQuantities);

    // *** MODIFIED: Preserve existing tray data when rebuilding table ***
    const existingTrayData = preserveExistingTrayData(); // Capture existing data first

    // === UPDATED: Use backend API for multi-model tray distribution ===
    console.log('ðŸš€ Using backend API for multi-model optimal distribution');
    
    const trayTable = document.getElementById('delinkTrayTable');
    trayTable.innerHTML = `
      <div style="background: #d1f2f3; font-weight: bold; color: #028084;">S.No</div>
      <div style="background: #d1f2f3; font-weight: bold; color: #028084;">Tray ID</div>
    `;

    // Use multi-model backend API
    const populationResult = await populateDelinkTrayTableMultiModel(calculatedLotIdQuantities, trayTable);
    
    // Store multi-model distribution for later use
    window.currentMultiModelDistribution = populationResult.distribution;
    
    // === UPDATED: Populate half-filled tray table using backend distribution ===
    if (populationResult && populationResult.distribution) {
      populateHalfFilledTrayTableMultiModel(populationResult.distribution);
    } else {
      populateHalfFilledTrayTable([]); // Hide if no distribution
    }
    
    // === UPDATED: Setup faulty slots handler for multi-model ===
    if (validResults.length > 1) {
      setupFaultySlotHandlerMultiModel(validResults, calculatedLotIdQuantities, populationResult.distribution);
    } else {
      // Use single model logic for single selection
      const faultySlotInput = document.getElementById('modalFaultySlots');
      const emptySlotInput = document.getElementById('modalEmptySlots');
      const lotQtyInput = document.getElementById('modalLotQty');
      
      if (faultySlotInput) {
        // Remove any existing event listeners
        faultySlotInput.replaceWith(faultySlotInput.cloneNode(true));
        const newFaultySlotInput = document.getElementById('modalFaultySlots');
        
        newFaultySlotInput.addEventListener('input', function() {
        const faultySlots = parseInt(newFaultySlotInput.value) || 0;
        
        if (faultySlots <= 0) {
          // Reset to original values
          emptySlotInput.value = window.originalCombinedEmptySlots;
          lotQtyInput.value = window.originalCombinedLotQty;
          
          // *** ENHANCED: Reset half filled trays for single model ***
          const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
          populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
        } else {
            // Apply faulty slots logic
            let remainingFaultySlots = faultySlots;
            let newEmptySlots = window.originalCombinedEmptySlots;
            let newLotQty = window.originalCombinedLotQty;
            
            // First, reduce from empty slots
            if (remainingFaultySlots > 0 && newEmptySlots > 0) {
              const reductionFromEmpty = Math.min(remainingFaultySlots, newEmptySlots);
              newEmptySlots -= reductionFromEmpty;
              remainingFaultySlots -= reductionFromEmpty;
            }
            
            // Then, reduce from LOT qty if faulty slots still remain
            if (remainingFaultySlots > 0 && newLotQty > 0) {
              const reductionFromLot = Math.min(remainingFaultySlots, newLotQty);
              newLotQty -= reductionFromLot;
              remainingFaultySlots -= reductionFromLot;
            }
            
            // Update the fields
            emptySlotInput.value = Math.max(0, newEmptySlots);
            lotQtyInput.value = Math.max(0, newLotQty);
            
            // Show warning if faulty slots exceed total capacity
            if (remainingFaultySlots > 0) {
              showModalMessage('warning', 'Faulty Slots Exceed Capacity', 
                `${remainingFaultySlots} faulty slots cannot be accommodated.`, 
                { duration: 4000 });
              newFaultySlotInput.value = faultySlots - remainingFaultySlots;
            }
            
            // Recalculate half filled trays based on adjusted LOT qty
            // For single model, we need to distribute the reduced quantity
            if (newLotQty !== window.originalCombinedLotQty) {
              // Hide half filled trays when quantity is reduced due to faulty slots
              populateHalfFilledTrayTable([]);
            } else {
              const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
              populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
            }
          }
          
          // Update Add Model button state
          const currentEmptySlots = parseInt(emptySlotInput.value) || 0;
          updateAddModelButtonState(currentEmptySlots);
        });
      }
    }

    // Disable/Enable "Add Model" button based on empty slots
    updateAddModelButtonState(emptySlots);

    // Update slider with all models (original + selected) - ALLOW DUPLICATES
    const slider = document.getElementById('modelSliderDynamic');
    slider.innerHTML = ''; // Clear all content first
    
    // First, add the original model if available
    if (originalModalData && originalModalData.modelNo && originalModalData.modelNo !== '-') {
      // Re-fetch original model image data to ensure we have the image
      try {
        const originalResponse = await fetch(`/spider_spindle/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
        const originalData = await originalResponse.json();
        
        const originalModelData = {
          modelNo: originalData.model_no || originalModalData.modelNo,
          image: (originalData.model_images && originalData.model_images.length > 0) ? originalData.model_images[0] : '/static/assets/images/imagePlaceholder.png',
          isOriginal: true
        };
        const originalItem = createModelItem(originalModelData);
        slider.appendChild(originalItem);
      } catch (error) {
        console.error('Error fetching original model data:', error);
        // Fallback to stored data without image
        const originalModelData = {
          modelNo: originalModalData.modelNo,
          image: '/static/assets/images/imagePlaceholder.png',
          isOriginal: true
        };
        const originalItem = createModelItem(originalModelData);
        slider.appendChild(originalItem);
      }
    }

    // Add checkbox models to slider IN SELECTION ORDER - INCLUDE DUPLICATES
    console.log(`Adding ${validResults.length} models to slider (allowing duplicates)`);
    
    // Process validResults in the order they were selected (maintained by stockLotIds order)
    validResults.forEach((r, index) => {
      if (r.model_no) {
        // ADD EVERY MODEL (including duplicates)
        const modelData = {
          modelNo: r.model_no || '-',
          image: (r.model_images && r.model_images.length > 0) ? r.model_images[0] : '/static/assets/images/imagePlaceholder.png',
          isOriginal: false, // Mark as added model (not original)
          lotId: r.original_lot_id // Store lot ID for reference
        };
        const item = createModelItem(modelData);
        slider.appendChild(item);
        
        console.log(`Added model ${r.model_no} (lot: ${r.original_lot_id}) to slider at position ${index + 1}`);
      }
    });
    
    // Update slider position
    setTimeout(updateSliderPosition, 100);
    
    // Log the final model count
    console.log(`Final model count in slider: ${slider.children.length}`);
    console.log(`Combined model numbers (with duplicates): [${combinedModelNos.join(', ')}]`);
  });
});

// Handle "Add Model" button click with modal messages and batch status filtering
document.querySelectorAll('.btn-action.teal').forEach(function(btn) {
  btn.addEventListener('click', function(e) {
    e.preventDefault();
    
    // Check if button is disabled
    if (btn.disabled) {
      showModalMessage('warning', 'Jig is Full', 'Cannot add more models. The jig has reached its maximum capacity.', { duration: 3000 });
      return;
    }
    
    // Check if empty slots is zero or negative
    const emptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
    if (emptySlots <= 0) {
      showModalMessage('warning', 'No Available Slots', 'Cannot add more models. The jig capacity is full.', { duration: 3000 });
      return;
    }
    
    // Get the current lot ID from the modal
    const currentLotId = currentModalLotId;
    if (!currentLotId) return;

    // Get original model details for filtering
    const originalPlatingColor = document.getElementById('modalBathType').value || '';
    const originalModelNo = document.getElementById('rightModalModelNo').textContent || '';
    const originalPolishFinish = ''; // We'll get this from the table row

    // HIDE the modal completely
    const modal = document.getElementById('rightSideModal');
    if (modal) {
      modal.classList.remove('open');
      modal.classList.remove('minimized');
      modal.style.display = 'none'; // Completely hide
    }

    // Get original row data for comparison
    let originalRowData = {};
    const tbody = document.querySelector('#order-listing tbody');
    
    // First pass: find the original row and get its data
// First pass: find the original row and get its data
tbody.querySelectorAll('tr').forEach(function(row) {
  const actionCell = row.querySelector('a[data-stock-lot-id], button[data-stock-lot-id]');
  if (actionCell && actionCell.getAttribute('data-stock-lot-id') === currentLotId) {
    const cells = row.querySelectorAll('td');
    originalRowData = {
      modelNo: cells[2]?.textContent?.trim() || '',
      platingColor: cells[4]?.textContent?.trim() || '',
      polishFinish: cells[5]?.textContent?.trim() || '',
      version: cells[6]?.textContent?.trim() || '',
      trayType: cells[8]?.textContent?.trim() || '', // NEW: Extract tray type
      jigType: cells[11]?.textContent?.trim().split(' - ')[0] || ''
    };
  }
});

    console.log('Original row data for filtering (with jig type):', originalRowData);

    // Helper function to get batch status from row
    function getBatchStatusFromRow(row) {
      const batchStatusCell = row.cells[15]; // Lot Status is the 16th column (index 15)
      if (batchStatusCell) {
        const statusElement = batchStatusCell.querySelector('.d-inline-block');
        if (statusElement) {
          return statusElement.textContent.trim();
        }
      }
      return '';
    }

    /// Second pass: filter the table based on criteria AND batch status
let visibleRowCount = 0;
let excludedByBatchStatus = 0;
let excludedByJigType = 0;
let excludedByTrayType = 0; // NEW: Track tray type exclusions

tbody.querySelectorAll('tr').forEach(function(row) {
  const actionCell = row.querySelector('a[data-stock-lot-id], button[data-stock-lot-id]');
  const checkbox = row.querySelector('.model-select-checkbox');
  
  if (actionCell && actionCell.getAttribute('data-stock-lot-id') === currentLotId) {
    // Hide the current lot_id row completely
    row.style.display = 'none';
  } else {
    // Check batch status first
    const batchStatus = getBatchStatusFromRow(row);
    const isExcludedStatus = batchStatus === 'Yet to Release' || batchStatus === 'Released';
    
    if (isExcludedStatus) {
      // Hide rows with excluded batch statuses
      row.style.display = 'none';
      if (checkbox) {
        checkbox.style.display = 'none';
      }
      excludedByBatchStatus++;
      return; // Skip further processing for this row
    }

    // Check if this row matches the filtering criteria
    const cells = row.querySelectorAll('td');
    const rowData = {
      modelNo: cells[2]?.textContent?.trim() || '',
      platingColor: cells[4]?.textContent?.trim() || '',
      polishFinish: cells[5]?.textContent?.trim() || '',
      version: cells[6]?.textContent?.trim() || '',
      trayType: cells[8]?.textContent?.trim() || '', // NEW: Extract tray type
      jigType: cells[11]?.textContent?.trim().split(' - ')[0] || ''
    };

    // Apply filtering criteria with priority order
    let shouldShow = false;
    let matchType = '';
    let isVersionMismatch = false;

    // NEW: Check tray type first - this is now a mandatory requirement
    const trayTypeMatches = rowData.trayType === originalRowData.trayType && originalRowData.trayType !== '';
    
    // NEW: Check jig type - this is also mandatory
    const jigTypeMatches = rowData.jigType === originalRowData.jigType && originalRowData.jigType !== '';
    
    // Only proceed with other criteria if both tray type AND jig type match
    if (trayTypeMatches && jigTypeMatches) {
      // 1. Same model number (exact match) - highest priority
      if (rowData.modelNo === originalRowData.modelNo) {
        shouldShow = true;
        // Check for version mismatch within same model
        if (rowData.version !== originalRowData.version && originalRowData.version !== '') {
          matchType = 'Same Model + Tray Type + Jig Type (Version Mismatch)';
          isVersionMismatch = true;
        } else {
          matchType = 'Same Model + Tray Type + Jig Type';
        }
      }
      // 2. Same plating color with version mismatch check (only if not same model)
      else if (rowData.platingColor === originalRowData.platingColor && originalRowData.platingColor !== '') {
        shouldShow = true;
        // Check for version mismatch within same plating color
        if (rowData.version !== originalRowData.version && originalRowData.version !== '') {
          matchType = 'Same Plating Color + Tray Type + Jig Type (Version Mismatch)';
          isVersionMismatch = true;
        } else {
          matchType = 'Same Plating Color + Tray Type + Jig Type';
        }
      }
      // 3. Same polish finish (only if not same model or plating color)
      else if (rowData.polishFinish === originalRowData.polishFinish && originalRowData.polishFinish !== '') {
        shouldShow = true;
        matchType = 'Same Polish Finish + Tray Type + Jig Type';
      }
      // 4. Only tray type and jig type match (fallback)
      else {
        shouldShow = true;
        matchType = 'Same Tray Type + Jig Type Only';
      }
    }
    // If tray type doesn't match, don't show the row at all
    else if (!trayTypeMatches && jigTypeMatches) {
      shouldShow = false;
      excludedByTrayType++; // NEW: Count tray type exclusions
    }
    // If jig type doesn't match, don't show the row at all
    else if (!jigTypeMatches) {
      shouldShow = false;
      excludedByJigType++; // Count jig type exclusions
    }
    // If neither matches
    else {
      shouldShow = false;
      if (!trayTypeMatches) excludedByTrayType++;
      if (!jigTypeMatches) excludedByJigType++;
    }

    // Show/hide based on criteria
    if (shouldShow) {
      row.style.display = '';
      if (checkbox) {
        checkbox.style.display = 'inline-block';
      }
      
      // Add a visual indicator for the match type
      if (!row.querySelector('.match-indicator')) {
        const indicator = document.createElement('span');
        indicator.className = 'match-indicator';
        
        // Special styling for version mismatch
        if (isVersionMismatch) {
          indicator.style.cssText = `
            background: #d1ecf1;
            color: #0c5460;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: bold;
            border: 1px solid #bee5eb;
            animation: pulse 2s infinite;
          `;
        } else {
          indicator.style.cssText = `
            background: #e8f5e8;
            color: #155724;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: bold;
          `;
        }
        
        indicator.textContent = matchType;
        cells[2]?.appendChild(indicator); // Add to model number cell
      }
      
      visibleRowCount++;
    } else {
      row.style.display = 'none';
      if (checkbox) {
        checkbox.style.display = 'none';
      }
    }
  }
});

    // Add a visual indicator that filtering is active
    let filterIndicator = document.getElementById('filterIndicator');
    if (!filterIndicator) {
      filterIndicator = document.createElement('div');
      filterIndicator.id = 'filterIndicator';
      filterIndicator.style.cssText = `
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: #e8f5e8;
        border: 2px solid #28a745;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        color: #155724;
        z-index: 9999;
        animation: slideDown 0.3s ease;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      `;
      
      // NEW: Enhanced message to show jig type filtering
// NEW: Enhanced message to show both tray type and jig type filtering
let filterMessage = `
  <i class="fa fa-filter" style="margin-right: 8px;"></i>
  Filtered view - <strong>${visibleRowCount}</strong> compatible models found for <strong>${originalRowData.modelNo}</strong>
  <br><small>Required: <strong>Tray Type: ${originalRowData.trayType}</strong> + <strong>Jig Type: ${originalRowData.jigType}</strong></small>
  <br><small>Showing: Same Tray Type + Same Jig Type + (Same Model OR Same Plating Color OR Same Polish Finish)</small>
`;

// Add batch status exclusion info if any were excluded
if (excludedByBatchStatus > 0) {
  filterMessage += `<br><small style="color: #dc3545;"><strong>Note:</strong> ${excludedByBatchStatus} items excluded (Yet to Release/Released status)</small>`;
}

// NEW: Add tray type exclusion info if any were excluded
if (excludedByTrayType > 0) {
  filterMessage += `<br><small style="color: #ff6b35;"><strong>Note:</strong> ${excludedByTrayType} items excluded (Different Tray Type)</small>`;
}

// Add jig type exclusion info if any were excluded
if (excludedByJigType > 0) {
  filterMessage += `<br><small style="color: #ff9800;"><strong>Note:</strong> ${excludedByJigType} items excluded (Different Jig Type)</small>`;
}
      filterMessage += `
        <button type="button" id="resetFilterBtn" style="margin-left: 10px; background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset & Close</button>
      `;
      
      filterIndicator.innerHTML = filterMessage;
      document.body.appendChild(filterIndicator);
      
      // Add event listener to the reset button
      const resetBtn = document.getElementById('resetFilterBtn');
      if (resetBtn) {
        resetBtn.addEventListener('click', function() {
          window.location.reload();
        });
      }
    }

    // Show toast with enhanced message
// Show toast with enhanced message
if (visibleRowCount === 0) {
  // NEW: Updated toast message to include both tray type and jig type requirement
  let toastMessage = `No compatible models found with same Tray Type (${originalRowData.trayType}) and Jig Type (${originalRowData.jigType}) and matching plating color, polish finish, or model number.`;
  if (excludedByBatchStatus > 0) {
    toastMessage += ` (${excludedByBatchStatus} items were excluded due to "Yet to Release" or "Released" status)`;
  }
  if (excludedByTrayType > 0) {
    toastMessage += ` (${excludedByTrayType} items had different Tray Type)`;
  }
  if (excludedByJigType > 0) {
    toastMessage += ` (${excludedByJigType} items had different Jig Type)`;
  }
  showToast('info', toastMessage, 500);
    } else {
      // Check if we should disable checkboxes based on empty slots
      // Get current empty slots from the modal before it was hidden
      const modalEmptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
      
      if (modalEmptySlots <= 0) {
        // Disable all checkboxes if no empty slots
        tbody.querySelectorAll('tr').forEach(function(row) {
          const checkbox = row.querySelector('.model-select-checkbox');
          if (checkbox && checkbox.style.display !== 'none') {
            checkbox.disabled = true;
            checkbox.style.opacity = '0.5';
            checkbox.style.cursor = 'not-allowed';
            checkbox.title = 'Cannot select - Jig is full';
            
            // Add visual indicator to the row
            row.style.opacity = '0.7';
            row.style.pointerEvents = 'none';
          }
        });
        
        // Update filter indicator to show that selection is disabled
        const filterIndicator = document.getElementById('filterIndicator');
        if (filterIndicator) {
          // NEW: Updated message to include jig type info
          let updatedMessage = `
            <i class="fa fa-filter" style="margin-right: 8px;"></i>
            Filtered view - <strong>${visibleRowCount}</strong> compatible models found for <strong>${originalRowData.modelNo}</strong> with <strong>Jig Type: ${originalRowData.jigType}</strong>
            <br><small style="color: #dc3545;"><strong>Selection Disabled:</strong> Jig is full (0 empty slots)</small>
          `;
          
          if (excludedByBatchStatus > 0) {
            updatedMessage += `<br><small style="color: #dc3545;"><strong>Note:</strong> ${excludedByBatchStatus} items excluded (Yet to Release/Released status)</small>`;
          }
          
          if (excludedByJigType > 0) {
            updatedMessage += `<br><small style="color: #ff9800;"><strong>Note:</strong> ${excludedByJigType} items excluded (Different Jig Type)</small>`;
          }
          
          updatedMessage += `
            <button type="button" id="resetFilterBtn" style="margin-left: 10px; background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset & Close</button>
          `;
          
          filterIndicator.innerHTML = updatedMessage;
          
          // Re-add event listener to the new reset button
          const resetBtn = document.getElementById('resetFilterBtn');
          if (resetBtn) {
            resetBtn.addEventListener('click', function() {
              window.location.reload();
            });
          }
        }
      }
    }
  });
});

  // Add navigation event listeners for slider
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('prev-btn')) {
      if (currentSlideIndex > 0) {
        currentSlideIndex--;
        updateSliderPosition();
      }
    } else if (e.target.classList.contains('next-btn')) {
      const container = document.querySelector('.model-slider-container');
      if (!container) return;
      const containerWidth = container.offsetWidth;
      const visibleItems = Math.floor(containerWidth / itemWidth);
      const totalItems = document.getElementById('modelSliderDynamic').children.length;
      
      if (currentSlideIndex + visibleItems < totalItems) {
        currentSlideIndex++;
        updateSliderPosition();
      }
    }
  });

  // Handle modal close button
  document.querySelectorAll('.close-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const modal = document.getElementById('rightSideModal');
      if (modal) {
        modal.classList.remove('open');
        modal.classList.remove('minimized');
        modal.style.display = 'none';
      }
      
      // Reset table filter and hide all checkboxes
      resetTableFilter();
      
      // Reset everything
      document.querySelectorAll('.model-select-checkbox').forEach(function(cb) {
        cb.checked = false;
        cb.style.display = 'none';
      });
      
      updateSelectedItemsStatus();
      originalModalData = null;
      currentModalLotId = null;
      currentSlideIndex = 0;
    });
  });

  // Global function to reset table filter
  window.resetTableFilter = function() {
    window.location.reload();
  };

  // Handle window resize
  window.addEventListener('resize', updateSliderPosition);

// Action button handlers - Enhanced Add Jig functionality
document.addEventListener('click', function(e) {
  if (e.target.closest('.action-buttons .btn-twitter')) {
    const button = e.target.closest('.action-buttons .btn-twitter');
    if (button.textContent.trim() === 'Add Jig') {
      e.preventDefault();
      
      // Save jig details but keep modal open
      saveJigDetails({ keepModalOpen: true }).then(success => {
        if (success) {
          // The clearModalFieldsAfterAddJig function is called automatically in saveJigDetails
          console.log('Add Jig completed successfully');
        }
      });
    }
  }
});

document.addEventListener('click', function(e) {
  if (e.target.closest('.action-buttons .btn-success')) {
    const button = e.target.closest('.action-buttons .btn-success');
    if (button.textContent.trim() === 'Submit') {
      e.preventDefault();
      
      // Save and close modal, then refresh page
      saveJigDetails().then(success => {
        if (success) {
          // Modal will be closed automatically by saveJigDetails
        }
      });
    }
  }
});

  // Handle other action buttons (Draft, Cancel)
  document.addEventListener('click', function(e) {
    if (e.target.closest('.action-buttons button')) {
      const button = e.target.closest('.action-buttons button');
      const action = button.textContent.trim();
  
      // Skip if this is Add Jig or Submit (they have their own handlers)
      if (action === 'Add Jig' || action === 'Submit') {
        return;
      }
  
      e.preventDefault();
  
      if (action === 'Draft') {
        // Save as draft (send is_draft: true)
        const modalData = collectModalData();
        modalData.is_draft = true;
        if (window.currentDraftId) modalData.draft_id = window.currentDraftId;
  
        fetch('/spider_spindle/save_jig_details/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(modalData)
        })
        .then(res => res.json())
        .then(result => {
          if (result.success) {
            showToast('success', 'Drafted successfully', 100);
            setTimeout(() => {
              window.location.href = "/spider_spindle/spider_pick_table/";
            }, 100);
          } else {
            showModalMessage('error', 'Draft Failed', result.error || 'Could not save draft', { duration: 5000 });
          }
        })
        .catch(() => {
          showModalMessage('error', 'Draft Failed', 'Network error', { duration: 5000 });
        });
      } else if (action === 'Cancel') {
        // Just close the modal and show toast
        document.querySelectorAll('.right-slide-modal').forEach(modal => {
          modal.classList.remove('open');
          modal.style.display = 'none';
        });
        showToast('success', 'Cancelled successfully', 100);
        setTimeout(() => {
          window.location.href = "/spider_spindle/spider_pick_table/";
        }, 100);
      }
    }
  });

  // Helper function for CSRF token
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});
</script>


<!-- Edit Quantity Script -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll('.edit-batch-qty-btn').forEach(function(editBtn) {
    editBtn.addEventListener('click', function(e) {
      e.preventDefault();
      const batchId = editBtn.getAttribute('data-batch-id');
      const row = editBtn.closest('tr');
      const qtyInput = row.querySelector('.edit-qty-input');
      if (qtyInput) {
        qtyInput.removeAttribute('readonly');
        qtyInput.focus();
        qtyInput.select();

        qtyInput.addEventListener('keydown', async function handler(ev) {
          if (ev.key === 'Enter') {
            ev.preventDefault();
            qtyInput.setAttribute('readonly', 'readonly');
            const newQty = qtyInput.value;
            
            // Show loading state
            const originalValue = qtyInput.value;
            qtyInput.style.opacity = '0.5';
            
            try {
              const resp = await fetch("{% url 'jig_update_batch_quantity' %}", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "X-CSRFToken": getCookie('csrftoken')
                },
                body: JSON.stringify({
                  batch_id: batchId,
                  brass_audit_accepted_qty: newQty
                })
              });
              const result = await resp.json();
              
              qtyInput.style.opacity = '1';
              
              if (result.success) {
                // Show success toast
                showToast('success', 'Quantity updated successfully!', 1500);
                
                setTimeout(() => {
                  window.location.reload();
                }, 1200);
              } else {
                // Show error message
                const modal = document.getElementById('rightSideModal');
                if (modal && modal.classList.contains('open')) {
                  showModalMessage('error', 'Update Failed', result.error || 'Update failed', { duration: 4000 });
                } else {
                  showToast('error', result.error || 'Update failed', 4000);
                }
                qtyInput.value = originalValue; // Restore original value
              }
            } catch (err) {
              console.error('Update error:', err);
              qtyInput.style.opacity = '1';
              qtyInput.value = originalValue; // Restore original value
              
              const modal = document.getElementById('rightSideModal');
              if (modal && modal.classList.contains('open')) {
                showModalMessage('error', 'Network Error', 'Failed to update quantity', { duration: 4000 });
              } else {
                showToast('error', 'Network error occurred', 4000);
              }
            }
            qtyInput.removeEventListener('keydown', handler);
          }
        });
      }
    });
  });
});

// Toast function for use in other scripts
function showToast(type, message, duration = 3000) {
  // Remove any existing toast
  const existingToast = document.getElementById('toastMessage');
  if (existingToast) {
    existingToast.remove();
  }

  const toast = document.createElement('div');
  toast.id = 'toastMessage';
  
  let bgColor, textColor, borderColor, icon;
  switch(type) {
    case 'success':
      bgColor = '#d4f7d4';
      textColor = '#218838';
      borderColor = '#28a745';
      icon = 'âœ“';
      break;
    case 'error':
      bgColor = '#ffd6d6';
      textColor = '#b30000';
      borderColor = '#dc3545';
      icon = 'âœ—';
      break;
    case 'warning':
      bgColor = '#fff3cd';
      textColor = '#856404';
      borderColor = '#ffc107';
      icon = 'âš ';
      break;
    case 'info':
      bgColor = '#d1ecf1';
      textColor = '#0c5460';
      borderColor = '#17a2b8';
      icon = 'â“˜';
      break;
    default:
      bgColor = '#d1ecf1';
      textColor = '#0c5460';
      borderColor = '#17a2b8';
      icon = 'â“˜';
  }
  
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${bgColor};
    color: ${textColor};
    border: 1px solid ${borderColor};
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 10000;
    font-size: 14px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    animation: slideInToast 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    max-width: 350px;
  `;
  
  toast.innerHTML = `
    <span style="font-weight: bold; font-size: 16px;">${icon}</span>
    <span>${message}</span>
  `;
  
  document.body.appendChild(toast);
  
  if (duration > 0) {
    setTimeout(() => {
      toast.style.animation = 'slideOutToast 0.3s ease';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 300);
    }, duration);
  }
  
  return toast;
}
</script>

<!-- Delete Batch Script -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll('.jig-delete-batch-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const stockLotId = btn.getAttribute('data-stock-lot-id');

      // Use SweetAlert2 for confirmation
      Swal.fire({
        title: 'Are you sure?',
        text: "This action cannot be undone.",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#dc3545',
        cancelButtonColor: '#6c757d',
        confirmButtonText: 'Yes, delete it!',
        cancelButtonText: 'Cancel'
      }).then((result) => {
        if (result.isConfirmed) {
          // Show loading state
          const originalHTML = btn.innerHTML;
          btn.innerHTML = '<img src="{% static "assets/icons/loading.gif" %}" alt="Loading" style="width: 20px; height: 20px;" />';
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';

          fetch("{% url 'jig_delete_batch' %}", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCookie('csrftoken')
            },
            body: JSON.stringify({ stock_lot_id: stockLotId })
          })
          .then(response => response.json())
          .then(data => {
            // Restore button state
            btn.innerHTML = originalHTML;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';

            if (data.success) {
              Swal.fire('Deleted!', 'Batch deleted successfully!', 'success');
              setTimeout(() => {
                window.location.reload();
              }, 900);
            } else {
              Swal.fire('Error', data.error || 'Delete failed', 'error');
            }
          })
          .catch(error => {
            console.error('Delete error:', error);
            btn.innerHTML = originalHTML;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
            Swal.fire('Error', 'Network error occurred', 'error');
          });
        }
      });
    });
  });
});
</script>

<!-- CSRF Token Helper -->
<script nonce="{{ csp_nonce }}">
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}
</script>
<!-- // --- Child Screen Lock Feature ---
// When child screen (tray scan modal) is open, only allow scroll and Eye icon (view) access on parent.
// All other actions (edit, delete, filter, etc.) are blocked visually and functionally.
-->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function lockParentActions() {
    // Disable all actions except view (eye) icon
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button:not(#closeTrayScanModal_DayPlanning):not(#trayValidateBtn):not(#trayScanRedoBtn)'
    ).forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';
    });

    // Also block all <a> except .tray-scan-btn-Jig
    document.querySelectorAll('a:not(.tray-scan-btn-Jig)').forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.cursor = 'not-allowed';
    });

    // Restrict menu panel access (sidebar) but do NOT make it grey
    var menuPanel = document.querySelector('.sidebar');
    if (menuPanel) {
      menuPanel.style.pointerEvents = 'none';
      menuPanel.style.opacity = '';
      menuPanel.style.filter = '';
      menuPanel.style.cursor = 'not-allowed';
    }
    var mainPanel = document.querySelector('.main-panel');
    if (mainPanel) {
      mainPanel.style.pointerEvents = 'auto'; // keep main-panel interactive for scroll
    }

    // Ensure table scroll is always allowed
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  function unlockParentActions() {
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button'
    ).forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
    });
    document.querySelectorAll('a').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.cursor = '';
    });

    // Restore menu panel access
    var menuPanel = document.querySelector('.sidebar');
    if (menuPanel) {
      menuPanel.style.pointerEvents = '';
      menuPanel.style.opacity = '';
      menuPanel.style.filter = '';
      menuPanel.style.cursor = '';
    }
    var mainPanel = document.querySelector('.main-panel');
    if (mainPanel) {
      mainPanel.style.pointerEvents = '';
    }

    // Restore table scroll (just in case)
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var modal = document.getElementById("trayScanModal_DayPlanning");
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  // When any view icon is clicked and modal opens, lock parent
  document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  // When modal closes, unlock parent
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
</script>
<!-- // --- Child Screen Lock Feature ---
// When child screen (tray scan modal) is open, only allow scroll and Eye icon (view) access on parent.
// All other actions (edit, delete, filter, etc.) are blocked visually and functionally.
 -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function lockParentActions() {
    // Select only buttons/inputs/links in parent panels, exclude modal dialogs
    document.querySelectorAll(
      '.main-panel button, .sidebar button, .main-panel a, .sidebar a, .main-panel img, .sidebar img, .main-panel .hold-toggle-btn, .sidebar .hold-toggle-btn'
    ).forEach(function (el) {
      // Skip allowed elements: view eye, Add Jig
      if (
        el.closest('#rightSideModal') || 
        el.closest('#trayScanModal_DayPlanning') ||
        el.classList.contains('tray-scan-btn-Jig') || 
        el.closest('.open-jig-modal-btn')
      ) {
        return; // donâ€™t lock modal internals or allowed buttons
      }

      // Disable everything else
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';

      if (el.classList.contains('hold-toggle-btn')) el.disabled = true;
    });

    // Keep table scroll active
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }  

  function unlockParentActions() {
    // Reset everything
    document.querySelectorAll('.main-panel *, .sidebar *').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
      if (el.classList.contains('hold-toggle-btn')) el.disabled = false;
    });

    // Restore table scroll
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  // Lock parent when any view or Add Jig is clicked
  document.querySelectorAll('.tray-scan-btn-Jig, .open-jig-modal-btn').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  // Unlock when tray scan modal closes
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }

  // Also unlock when Add Jig modal closes (if you have a close button)
  var addJigClose = document.querySelector('#rightSideModal .close, #rightSideModal [data-bs-dismiss="modal"]');
  if (addJigClose) {
    addJigClose.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
</script>
{% endblock %}
{% endblock content %}